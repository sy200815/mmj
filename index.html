
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title></title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
   
<style>

@font-face {
  font-family: 'MyCustomFont';  
  src: url('https://files.catbox.moe/o17bhh.ttf') format('truetype');
  font-display: swap;
}
@font-face {
  font-family: 'MyDiaryFont';
  src: url('https://files.catbox.moe/nlu6ea.ttf') format('truetype');
  font-display: swap;
}
:root {
    --wechat-green: #07c160;
    --phone-width: 410px;
    --phone-height: 880px;
    --body-bg: #f5f5f7;
    --phone-bg: #f1f1f1;
    --header-bg: #f9f9f9;
    --header-text: #1d1d1f;
    --app-icon-text: #1d1d1f;
    --system-message-color: #a5a5a5;
    --user-bubble-bg: #95ec69;
    --user-bubble-text: #000000;
    --ai-bubble-bg: #ffffff;
    --ai-bubble-text: #1d1d1f;
    --input-area-bg: #f5f5f7;
    --input-bg: #ffffff;
    --input-border: #dcdcdc;
    --button-primary: #9a9a9a;
    --button-secondary: #8e8e8e;
    --button-text: #ffffff;
    --delete-bg: #000;
}
* { -webkit-tap-highlight-color: transparent; }

html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: var(--phone-bg);
    overflow: hidden; 
}

body.dark-mode, #phone-screen.dark-mode {
    --body-bg: #1c1c1e;
    --phone-bg: #000000;
    --header-bg: #000000;
    --header-text: #d9d9d9;
    --app-icon-text: #d9d9d9;
    --system-message-color: #8a8a8a;
    --user-bubble-bg: #27b561;
    --user-bubble-text: #111111;
    --ai-bubble-bg: #2c2c2e;
    --ai-bubble-text: #d9d9d9;
    --input-area-bg: #000000;
    --input-bg: #2c2c2c;
    --input-border: #3a3a3c;
    --button-primary: #07c160;
    --button-secondary: #3a3a3c;
    --button-text: #d9d9d9;
    --delete-bg: #ff3b30;
}
#phone-screen.dark-mode .app-header { background-color: #000000 !important; border-bottom: none !important; }
#phone-screen.dark-mode #tab-bar { background-image: url('https://i.postimg.cc/K8dx3cJv/IMG-6193.png'); background-color: #000000; border-top-color: var(--input-border); }
#phone-screen.dark-mode #status-bar-time, #phone-screen.dark-mode .status-bar-right, #phone-screen.dark-mode .app-header .back-btn, #phone-screen.dark-mode .app-header h2, #phone-screen.dark-mode .app-header .settings-btn, #phone-screen.dark-mode .app-header .action-btn { color: #d9d9d9 !important; }
#phone-screen.dark-mode .signal-icon .bar { background-color: #d9d9d9; }
#phone-screen.dark-mode .battery-icon { border-color: #d9d9d9; }
#phone-screen.dark-mode .battery-icon .battery-level, #phone-screen.dark-mode .battery-icon::after { background-color: #d9d9d9; }
#phone-screen.dark-mode .list-item, #phone-screen.dark-mode .modal-box { background-color: var(--ai-bubble-bg); }
#phone-screen.dark-mode .list-item::after { background-color: var(--input-border); }
#phone-screen.dark-mode .list-container, #phone-screen.dark-mode .settings-page-content { background-color: var(--phone-bg); }
#phone-screen.dark-mode #toggle-actions-panel-btn svg { color: #8a8a8a; }
#phone-screen.dark-mode .action-grid-item .icon { background-color: #2c2c2e; color: #ffffff; }
#phone-screen.dark-mode .action-grid-item .label { color: #8a8a8a; }
#phone-screen.dark-mode .form-group input, #phone-screen.dark-mode .form-group select, #phone-screen.dark-mode .form-group .selection-box, #phone-screen.dark-mode .form-group textarea { background-color: var(--ai-bubble-bg); border-color: var(--input-border); color: #ffffff; }
#phone-screen.dark-mode .form-group label { color: #e5e5e5; }
#phone-screen.dark-mode .form-group .selection-box .placeholder { color: #8a8a8a; }
#phone-screen.dark-mode .settings-actions { border-top-color: var(--input-border); }
#phone-screen.dark-mode .message-bubble.voice-text-translation .content { background-color: #191919 !important; color: #d9d9d9 !important; }

/* --- 新增：日记弹窗美化样式 (内嵌版) --- */

#diary-modal {
    position: absolute; /* <--- 核心修改：改为 absolute 定位 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* 使用带一点透明和模糊的白色背景，效果更好 */
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.4s ease-in-out;
    font-family: 'MyDiaryFont', sans-serif;
    z-index: 150;
}

#diary-modal.active {
    opacity: 1;
}

#diary-text-container {
    width:90%;
    height: 90%;
    padding: 0;
    margin: 0;
    background-image: url('https://files.catbox.moe/gw9rbo.png');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    color: #4a4137;
    font-size: 18px;
    line-height: 2.2;
    transform: scale(1.05);
    transition: transform 0.4s ease-in-out;
}

#diary-modal.active #diary-text-container {
    transform: scale(1);
}

/* 隐藏关闭按钮 */
#close-diary-modal-btn {
    display: none;
}

/* 新增：AI 状态泡泡的样式 */
.ai-status-popup {
    position: absolute;
    transform: translateX(-50%); /* 用于水平居中泡泡 */
    background-color: #ffcddf; /* 粉色 */
    color: #5b3a4c; /* 深粉色字体，保证可读性 */
    padding: 6px 12px;
    border-radius: 16px;
    font-size: 13px;
    font-weight: 500;
    z-index: 5;
    white-space: nowrap; /* 防止文字换行 */
    opacity: 0;
    pointer-events: none; /* 让泡泡不会阻挡鼠标点击 */
    /* 核心：使用下面的动画效果 */
    animation: status-popup-animation 4s ease-out forwards;
}

/* 新增：状态泡泡出现和消失的动画 */
@keyframes status-popup-animation {
    0% {
        opacity: 0;
        transform: translate(-50%, 10px); /* 从头像下方一点点的位置开始 */
    }
    15% {
        opacity: 1;
        transform: translate(-50%, -10px); /* 向上冒出到头像上方 */
    }
    85% {
        opacity: 1;
        transform: translate(-50%, -10px); /* 保持显示 */
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -20px); /* 继续向上并消失 */
    }
}

#phone-screen {
    width: 100%;
    height: 100%;
    background-color: var(--phone-bg);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
   
}

#dynamic-island {
    position: absolute;
    z-index: 110; 
    top: 60px; 
    left: 50%;
    /* 核心：定義動畫效果 */
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), opacity 0.5s ease;
    /* 預設的隱藏狀態 */
    opacity: 0;
    transform: translate(-50%, -150%);
    display: flex;
    align-items: center;
    box-sizing: border-box;
}

#dynamic-island.visible {
    opacity: 1;
    transform: translate(-50%, 0);
}

/* 3. 「通知橫幅」的外觀 (只負責長相) */
/* - 定義了展開為長條通知時的寬高、背景、圓角等 */
#dynamic-island.notification-banner {
    width: 95%;
    height: auto;
    min-height: 85px;
    border-radius: 28px;
    background-color: rgba(28, 28, 30, 0.85);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    padding: 12px 18px;
    justify-content: flex-start;
    gap: 12px;
    cursor: pointer;
}


#dynamic-island.default-pill {
    width: 120px;
    height: 36px;
    background-color: #000000;
    border-radius: 18px;
    top: 15px; /* 微調使其在狀態欄內 */
    padding: 0 15px;
    justify-content: center;
    cursor: default;
}

#dynamic-island.expanded-retraction {
    width: 90%;
    height: auto;
    min-height: 80px;
    border-radius: 40px;
    background-color: #000000;
    padding: 12px 18px;
    justify-content: center;
    cursor: default;
}

.screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--phone-bg); display: flex; flex-direction: column; opacity: 0; visibility: hidden; transition: opacity 0.3s; z-index: 1; }
.screen.active { opacity: 1; visibility: visible; z-index: 10; }
.app-header { flex-shrink: 0; padding: 60px 10px 12px 10px; background-color: #ededed; border-bottom: 1px solid var(--input-border); display: flex; align-items: center; justify-content: space-between; gap: 10px; position: relative; }
.app-header .back-btn { font-size: 24px; color: var(--header-text); cursor: pointer; border: none; background: none; padding: 5px 10px; }
.app-header h2 { margin: 0; font-size: 17px; font-weight: 600; color: var(--header-text); position: absolute; left: 50%; bottom: 12px; transform: translateX(-50%); }
.app-header .header-actions { display: flex; align-items: center; gap: 0px; }
.app-header .action-btn { font-size: 28px; color: var(--button-primary); cursor: pointer; border: none; background: none; font-weight: 300; padding-right: 5px;}
.app-header .settings-btn { font-size: 16px; font-weight: 500; color: var(--button-primary); background: none; border: none; padding: 5px; cursor: pointer; }
#status-bar { position: absolute; top: 5px; left: 0; width: 100%; height: 45px; padding: 0 20px; display: flex; justify-content: space-between; align-items: center; z-index: 15; box-sizing: border-box; pointer-events: none; transition: transform 0.3s ease-in-out; }
#status-bar.hidden { transform: translateY(-150%); }
#status-bar-time { font-size: 15px; font-weight: 800; color: black; position: relative; left: 35px; }
.status-bar-right { display: flex; align-items: center; gap: 7px; position: relative; right: 30px; }
.signal-icon { display: flex; align-items: flex-end; gap: 2px; height: 12px; }
.signal-icon .bar { width: 3px; background-color: black; border-radius: 2px; }
.signal-icon .bar1 { height: 25%; }
.signal-icon .bar2 { height: 50%; }
.signal-icon .bar3 { height: 75%; }
.signal-icon .bar4 { height: 100%; }
.battery-icon { width: 24px; height: 11px; border: 1.5px solid black; border-radius: 5px; position: relative; padding: 1px; }
.battery-icon::after { content: ''; position: absolute; right: -3px; top: 4px; width: 1.5px; height: 4px; background-color: black; border-radius: 0 1px 1px 0; }
.battery-icon .battery-level { height: 100%; width: 100%; background-color: black; border-radius: 4px; }
#dynamic-island { position: absolute; z-index: 110; top: 60px; left: 50%; transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), opacity 0.5s ease; opacity: 0; transform: translate(-50%, -150%); display: flex; align-items: center; box-sizing: border-box; }
#dynamic-island.visible { opacity: 1; transform: translate(-50%, 0); }
#dynamic-island.notification-banner { width: 95%; height: auto; min-height: 85px; border-radius: 28px; background-color: rgba(28, 28, 30, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); padding: 12px 18px; justify-content: flex-start; gap: 12px; cursor: pointer; }
#dynamic-island.default-pill { width: 120px; height: 36px; background-color: #000000; border-radius: 18px; top: 15px; padding: 0 15px; justify-content: center; cursor: default; }
#dynamic-island.expanded-retraction { width: 90%; height: auto; min-height: 80px; border-radius: 40px; background-color: #000000; padding: 12px 18px; justify-content: center; cursor: default; top: 6px; transform: translateX(-50%); }
.notification-content-wrapper, .island-content-wrapper { display: flex; align-items: center; gap: 12px; width: 100%; }
.notification-avatar { width: 45px; height: 45px; border-radius: 12px; object-fit: cover; flex-shrink: 0; }
.notification-text-content { display: flex; flex-direction: column; gap: 2px; color: white; overflow: hidden; text-align: left; }
.notification-title { font-size: 16px; font-weight: 600; white-space: nowrap; }
.notification-body { font-size: 14px; opacity: 0.9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.island-retraction-view { width: 100%; text-align: center; color: white; opacity: 0; animation: fadeInIslandContent 0.5s 0.3s forwards; }
.island-retraction-view p { margin: 0; }
.island-retraction-view .label { font-size: 13px; color: #a0a0a0; margin-bottom: 8px; }
.island-retraction-view .content { font-size: 15px; font-weight: 500; color: #ffffff; word-wrap: break-word; }
.island-retraction-view .timestamp { font-size: 12px; color: #a0a0a0; margin-top: 8px; }
.island-retraction-view.fading-out { animation: fadeOutIslandContent 0.3s ease-out forwards; }
#home-screen { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding: 90px 20px 10px 20px; box-sizing: border-box; background-size: cover; background-position: center; background-repeat: no-repeat; background-color: #ffffff; }
.app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; text-align: center; }
.app-icon .icon-bg { width: 62px; height: 62px; border-radius: 15px; background-color: #ffffff; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; color: #333; margin-bottom: 8px; transition: transform 0.2s; }
.app-icon .app-label { font-size: 12px; color: var(--app-icon-text); background-color: rgba(255,255,255,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 2px 4px; border-radius: 4px;}
.home-content-wrapper { display: flex; justify-content: space-between; width: 100%; margin-top: 10px; gap: 8px; align-items: flex-start; }
.home-widget-area, .home-app-grid-area { width: calc(50% - 6.5px); }
.home-widget-area { display: flex; flex-direction: column; align-items: center; }
.widget-placeholder { width:91%; aspect-ratio: 1 / 1; background-color: #fff; border-radius: 23px; box-shadow: 0 6px 15px rgba(0,0,0,0.1); display: flex; justify-content: center; align-items: center; }
.widget-label { font-size: 12px; margin-top: 8px; color: var(--app-icon-text); background-color: rgba(255,255,255,0.3); backdrop-filter: blur(5px); padding: 2px 5px; border-radius: 4px; }
.home-app-grid-area { aspect-ratio: 1 / 1; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 12px; }
.home-dock-wrapper { width: calc(100% - 20px); padding: 12px; background-color: rgba(255,255,255,0.25); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 25px; display: flex; justify-content: center; gap: 30px; box-sizing: border-box; margin-top: auto; }
#new-decorative-widget { position: relative; width: 95%; margin: 0 auto 30px auto; aspect-ratio: 1 / 1; }
.new-widget-part { position: absolute; cursor: pointer; background-size: cover; background-position: center; transition: all 0.2s ease; background-color: transparent; }
.new-widget-part:active { transform: scale(0.98); }
#new-widget-bg { width: 100%; height: 80%; top: 0; left: 0; border-radius: 24px; z-index: 1; }
#new-widget-footer { width: 100%; height: 50%; bottom: 0; left: 0; border-radius: 24px; z-index: 2; }
#new-widget-avatar { width: 108px; height: 108px; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 50%; z-index: 3; }
.chat-messages { flex: 1; min-height: 0; padding: 15px 15px 1px 15px; overflow-y: auto; display: flex; flex-direction: column; background-size: cover; background-position: center; background-repeat: no-repeat; transition: padding-bottom 0.3s ease-in-out; }
.message-wrapper { display: flex; gap: 10px; max-width: 85%; align-items: flex-start; margin-bottom: 17px; }
.message-wrapper.user { align-self: flex-end; flex-direction: row-reverse; }
.message-wrapper.ai { align-self: flex-start; }
.message-wrapper .avatar { width: 40px; height: 40px; border-radius: 5px; object-fit: cover; flex-shrink: 0; }
.message-bubble { position: relative; max-width: 100%; word-break: break-word; line-height: 1.5; font-size: 17px; }
.message-bubble .content { padding: 8px 14px; border-radius: 5px; position: relative; }
.message-bubble.user .content { background-color: var(--user-bubble-bg); color: var(--user-bubble-text); }
.message-bubble.ai .content { background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
.message-bubble.ai .content:not(.voice-content)::after { content: ''; position: absolute; left: -4px; top: 16px; width: 8px; height: 8px; background-color: var(--ai-bubble-bg); transform: rotate(45deg); z-index: 0; border-bottom-left-radius: 1px; }
.message-bubble.user .content:not(.location-content):not(.voice-content):not(.image-content)::after { content: ''; position: absolute; right: -4px; top: 16px; width: 8px; height: 8px; background-color: var(--user-bubble-bg); transform: rotate(45deg); z-index: 0; border-top-right-radius: 1px; }
.message-bubble.system { align-self: center; background-color: transparent; color: var(--system-message-color); font-size: 12px; padding: 4px 10px; }
.message-bubble.system.retraction-notice { cursor: pointer; text-decoration: underline; transition: color 0.2s; }
.message-bubble.system.retraction-notice:hover { color: #2a3a69; }
.message-bubble.system.clickable-log { cursor: pointer; background-color: #e0e0e0; color: #556693; font-weight: 500; transition: background-color 0.2s, transform 0.1s; }
.message-bubble.system.clickable-log:active { background-color: #d1d1d1; transform: scale(0.98); }
.message-bubble.is-voice-message .content { padding: 0 !important; background-color: transparent !important; }
.voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 10px 14px; border-radius: 5px; }
.message-bubble.user .voice-message-body { flex-direction: row-reverse; background-color: var(--user-bubble-bg); }
.message-bubble.ai .voice-message-body { background-color: var(--ai-bubble-bg); }
.voice-play-icon { height: 20px; width: auto; vertical-align: middle; }
.voice-duration { font-size: 15px; font-weight: normal; color: var(--ai-bubble-text); margin: 0 5px; }
.message-bubble.user .voice-duration { color: var(--user-bubble-text); }
.voice-text-bubble { opacity: 0; transition: opacity 0.3s ease-in-out; margin-top: -12px; }
.voice-text-bubble .avatar { visibility: hidden; }
.message-bubble.voice-text-translation .content { background-color: #ffffff !important; color: #000000 !important; }
.message-bubble.voice-text-translation .content::after { display: none !important; }
.content.just-image-content { padding: 0; background-color: transparent !important; border-radius: 8px; overflow: hidden; }
.content.just-image-content img { max-width: 180px; max-height: 180px; display: block; border-radius: 8px; }
.message-bubble .content.just-image-content::after { display: none; }

.content.image-text-content {
    padding: 0;
    width: 160px; /* 将宽度调整到一个合适的大小 */
    aspect-ratio: 1 / 1; /* 核心：强制宽高比为1:1，实现正方形 */
    background-color: transparent !important;
    border-radius: 8px;
    overflow: hidden;
    cursor: pointer;
    border: 1px solid #e0e0e0;
    position: relative;
}

.content.image-text-content::after { display: none; }

.image-text-cover {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%; /* 核心：高度改为100%，以自动填满父容器 */
    background-color: #ffffff;
    color: #8c8c8c;
    font-size: 14px;
    font-weight: 500;
}

.image-text-details {
    padding: 10px 14px;
    background-color: #ffffff;
    line-height: 1.6;
    font-size: 16px;
    height: 100%; /* <--- 确保它和父容器一样高 */
    box-sizing: border-box; /* <--- 确保内边距不会撑开容器 */
    overflow-y: auto; /* <--- 核心：允许垂直滚动 */
}

.content.location-content { padding: 0; width: 250px; height: 125px; background-image: url('https://i.postimg.cc/W4fnCkhM/IMG-5405.png'); background-size: cover; background-position: center; border-radius: 8px; display: flex; flex-direction: column; justify-content: flex-start; overflow: hidden; border: 1px solid #e5e5e5; }
.location-text-overlay { background-color: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 8px 10px; color: #000; font-size: 14px; font-weight: 500; }
.content.transfer-content { padding: 0; width: 250px; background-color: #F8A94A; border-radius: 5px; color: white; }
.transfer-top-section { display: flex; align-items: center; gap: 12px; padding: 12px; }
.transfer-icon { flex-shrink: 0; width: 38px; height: 38px; background-color: transparent; border: 2px solid white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: 600; color: white; box-sizing: border-box; }
.transfer-details { font-size: 15px; font-weight: 500; line-height: 1.3; }
.transfer-details .transfer-remark { font-size: 13px; font-weight: normal; opacity: 0.9; }
.transfer-footer { padding: 6px 12px; font-size: 12px; color: white; border-top: 1px solid rgba(255, 255, 255, 0.1); }
.message-bubble.user .content.transfer-content { background-color: #F8A94A; color: white; }
.message-bubble.ai .content.transfer-content { color: white; }
.chat-messages.offline-mode { padding-left: 0; padding-right: 0; background-color: #ffffff; color: #3b2f2f; padding-top: 40px; font-family: 'MyCustomFont', serif; }
.chat-messages.offline-mode .message-wrapper { flex-direction: column; align-items: center; gap: 0; max-width: 100%; padding: 8px 0; }
.chat-messages.offline-mode .message-wrapper .avatar { width: 100%; height: 70px; border-radius: 0; object-fit: cover; margin-bottom: 20px; }
.chat-messages.offline-mode .message-bubble { width: 85%; max-width: 500px; font-size: 16px; line-height: 1.7; padding: 0; box-sizing: border-box; }
.chat-messages.offline-mode .message-bubble .content { text-align: left; background-color: transparent !important; color: inherit !important; padding: 0; border-radius: 0; }
.chat-messages.offline-mode .message-bubble .content::after { display: none !important; }
#phone-screen.offline-active #status-bar, #phone-screen.offline-active #ai-status-bubble, #phone-screen.offline-active #toggle-sticker-panel-btn, #phone-screen.offline-active #toggle-actions-panel-btn { display: none; }
#phone-screen.offline-active .app-header { background-color: #ffffff !important; border-bottom: none; padding-top: 8px; padding-bottom: 8px; box-shadow: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
#phone-screen.offline-active .app-header h2 { display: none; }
#phone-screen.offline-active .chat-input-area { background-color: #ffffff; border-top-color: #eee; border-radius: 0; }
#phone-screen.offline-active .app-header .back-btn, #phone-screen.offline-active .app-header .settings-btn { color: #9a9a9a; }
#phone-screen.offline-active #dynamic-action-btn { background-color: transparent !important; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23f3e9db'%3E%3Cpath d='M2.01 21L23 12 2.01 3 2 10l15 2-15 2z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: center; background-size: 90%; width: 36px; height: 36px; border-radius: 0; font-size: 0; transition: none; }
#phone-screen.offline-active #dynamic-action-btn.processing { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M2.01 21L23 12 2.01 3 2 10l15 2-15 2z'/%3E%3C/svg%3E"); }
#phone-screen.offline-active #dynamic-action-btn:active { transform: none; background-color: transparent !important; }
.chat-input-area { position: absolute; bottom: 0; left: 0; width: 100%; background-color: var(--input-area-bg); border-top: 1px solid var(--input-border); transform: translateY(220px); transition: transform 0.3s ease-in-out; } 
.chat-input-area.panel-open { transform: translateY(0); }
.chat-input-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; padding: 8px; box-sizing: border-box; }
#chat-input { flex-grow: 1; border: none; border-radius: 5px; padding: 10px 15px; font-size: 15px; resize: none; max-height: 100px; background-color: var(--input-bg); }
#chat-input:focus { outline: none; box-shadow: none; }
#toggle-actions-panel-btn { width: 27px; height: 27px; background-color: transparent; border: 1.5px solid #000000; border-radius: 50%; cursor: pointer; padding: 0; flex-shrink: 0; transition: all 0.2s ease-in-out; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23000000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 3V21M3 12H21'/%3E%3C/svg%3E"); background-size: 55%; background-repeat: no-repeat; background-position: center; color: #000000; transform: translateY(-4px); }
#toggle-actions-panel-btn.active { transform: translateY(-4px) rotate(45deg); border-color: #000000; }
#toggle-actions-panel-btn:disabled { opacity: 0.4; cursor: not-allowed; }
#dynamic-action-btn { flex-shrink: 0; width: 62px; height: 36px; padding: 0; border: none; border-radius: 18px; font-size: 14px; font-weight: 600; color: white; cursor: pointer; text-align: center; transition: background-color 0.2s ease, transform 0.2s ease; }
#dynamic-action-btn.receive-mode { background-color: #b5b5b5; transition: background-color 0.2s ease-in-out, transform 0.2s ease; }
#dynamic-action-btn.send-mode { background-color: var(--wechat-green); }
#dynamic-action-btn.processing { background-color: #d5d5d5 !important; cursor: not-allowed; }
#dynamic-action-btn:active { transform: scale(0.95); }
#toggle-sticker-panel-btn { display: flex; justify-content: center; align-items: center; width: 27px; height: 27px; background-color: transparent; border: 1.5px solid #000000; border-radius: 50%; cursor: pointer; padding: 1px; box-sizing: border-box; flex-shrink: 0; transition: all 0.2s ease-in-out; color: #000000; transform: translateY(-4px); margin: 0 4px; }
#toggle-sticker-panel-btn svg { width: 100%; height: 100%; }
.add-sticker-slot { width: 70px; height: 70px; border: 2px dashed var(--input-border); border-radius: 8px; display: flex; justify-content: center; align-items: center; font-size: 30px; font-weight: 300; color: var(--input-border); cursor: pointer; background-color: var(--input-bg); transition: background-color 0.2s, border-color 0.2s; }
.add-sticker-slot:hover { background-color: var(--body-bg); border-color: #b5b5b5; }
#chat-actions-panel, #sticker-panel { height: 220px; background-color: var(--input-area-bg); box-sizing: border-box; padding-bottom: 34px; }
#chat-actions-panel { padding: 20px 15px 25px 15px; }
#sticker-panel { display: none; flex-direction: column; align-items: stretch; }
.actions-grid { display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: auto auto; gap: 25px 15px; justify-items: center; }
.action-grid-item { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; }
.action-grid-item .icon { width: 58px; height: 58px; border-radius: 12px; background-color: #FFFFFF; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display: flex; justify-content: center; align-items: center; font-size: 24px; color: #333; }
.action-grid-item .label { font-size: 11px; color: #8a8a8a; }

#chat-sticker-grid, #sticker-grid-container, #manage-sticker-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 15px;
    overflow-y: auto;
    padding: 15px;
    flex-grow: 1;
    min-height: 0; /* <--- 新增这一行 */
}

.sticker-item { width: 70px; height: 70px; background-color: transparent; border-radius: 8px; object-fit: cover; cursor: pointer; transition: transform 0.2s; }
.sticker-item:active { transform: scale(0.9); }
.list-container { overflow-y: auto; flex-grow: 1; background-color: var(--phone-bg); }
.list-item { background-color: #ffffff; display: flex; align-items: center; overflow: hidden; padding: 12px 15px; position: relative; }
.list-item::after { content: ''; position: absolute; bottom: 0; left: 70px; right: 0; height: 1px; background-color: #f0f0f0; }
.list-item:last-child::after { display: none; }
.list-item-content { flex-grow: 1; display: flex; align-items: center; cursor: pointer; min-width: 0; }
.list-item.edit-mode .list-item-content { transform: translateX(35px); }
.delete-button { flex-shrink: 0; width: 22px; height: 22px; border-radius: 50%; background-color: #ff3b30; color: white; font-size: 16px; border: none; cursor: pointer; display: flex; justify-content: center; align-items: center; position: absolute; left: 15px; opacity: 0; transform: scale(0.5); transition: all 0.2s ease-in-out; }
.list-item.edit-mode .delete-button { opacity: 1; transform: scale(1); }
.list-item-avatar { width: 50px; height: 50px; border-radius: 5px; margin-right: 15px; object-fit: cover; flex-shrink: 0; }
.list-item-info { display: flex; flex-direction: column; justify-content: center; gap: 4px; flex-grow: 1; min-width: 0; }
.list-item-name { font-size: 16px; color: var(--header-text); font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.list-item-last-message { font-size: 13px; color: #8e8e93; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.toggle-switch { width: 52px; height: 32px; background-color: #e9e9eb; border-radius: 16px; position: relative; cursor: pointer; transition: background-color 0.2s ease-in-out; }
.toggle-switch.active { background-color: var(--wechat-green); }
.toggle-knob { width: 28px; height: 28px; background-color: white; border-radius: 50%; position: absolute; top: 2px; left: 2px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: transform 0.2s ease-in-out; }
.toggle-switch.active .toggle-knob { transform: translateX(20px); }
.settings-page-content { padding: 20px; overflow-y: auto; flex-grow: 1; }
.form-group { margin-bottom: 20px; }
.form-group label { display: block; margin-bottom: 8px; font-size: 14px; color: #333; font-weight: 500; }
.form-group input, .form-group select, .form-group .selection-box, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--input-border); border-radius: 8px; font-size: 14px; box-sizing: border-box; }
.form-group input:focus, .form-group textarea:focus { border-color: #9dc6cd; box-shadow: 0 0 0 2px rgba(157, 198, 205, 0.4); outline: none; }
.form-group .avatar-preview { width: 40px; height: 40px; border-radius: 5px; object-fit: cover; border: 1px solid var(--input-border); vertical-align: middle; margin-right: 10px; }
.form-group .wallpaper-preview { width: 100%; height: 80px; object-fit: cover; border-radius: 8px; border: 1px solid var(--input-border); margin-top: 5px; cursor: pointer; background-color: #ffffff; }
.form-group .upload-btn { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; color: #696969; }
.form-group .wallpaper-actions { display: flex; gap: 10px; margin-top: 8px; }
.form-group .selection-box { display: flex; justify-content: space-between; align-items: center; background-color: #f9f9f9; cursor: pointer; }
.form-group .selection-box .placeholder { color: #8a8a8a; }
.settings-actions { padding: 15px; border-top: none; background-color: transparent; display: flex; gap: 10px; justify-content: space-between; }
.settings-actions button { padding: 12px 0; border-radius: 50px; border: none; cursor: pointer; font-size: 15px; font-weight: 600; flex: 1; }
.fetch-btn, .action-btn-secondary { background-color: var(--button-secondary); color: var(--button-text); }
.save-btn { background-color: var(--button-primary); color: var(--button-text); }
.post-images-grid { display: grid; gap: 4px; margin-top: 8px; }
.post-image-item { position: relative; aspect-ratio: 1 / 1; background-color: #e9ecef; border-radius: 6px; overflow: hidden; cursor: pointer; }
.post-image-item .image-text-cover { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: #f7f7f7; color: #8c8c8c; font-size: 14px; font-weight: 500; transition: opacity 0.2s ease-out; }

.post-image-item .image-text-details {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 10px;
    background-color: #ffffff;
    color: #333;
    line-height: 1.5;
    font-size: 14px;
    box-sizing: border-box;
    overflow-y: auto;
    display: none;
    touch-action: pan-y; /* <--- 新增这一行，解决移动端滚动问题 */
}

.post-images-grid.image-count-1 { grid-template-columns: 1fr; max-width: 260px; }
.post-images-grid.image-count-2, .post-images-grid.image-count-4 { grid-template-columns: repeat(2, 1fr); max-width: 260px; }
.post-images-grid.image-count-3, .post-images-grid.image-count-5, .post-images-grid.image-count-6, .post-images-grid.image-count-7, .post-images-grid.image-count-8, .post-images-grid.image-count-9 { grid-template-columns: repeat(3, 1fr); max-width: 320px; }
#hub-page-moments { background-color: #FFFFFF; overflow-y: auto; }
#moments-header { position: relative; height: calc(var(--phone-width) * 0.6); flex-shrink: 0;}
#moments-cover-img { width: 100%; height: 100%; object-fit: cover; background-color: #ccc; cursor: pointer; }
#moments-user-avatar { position: absolute; right: 15px; bottom: -20px; width: 70px; height: 70px; border: 2px solid white; border-radius: 8px; object-fit: cover; background-color: #eee; cursor: pointer; }
#moments-feed { padding: 40px 15px 15px 15px; }
.moment-post { display: flex; gap: 10px; padding-bottom: 20px; margin-bottom: 20px; }
.moment-post:not(:last-child) { border-bottom: 1px solid #f0f0f0; }
.moment-post .avatar { width: 45px; height: 45px; border-radius: 5px; object-fit: cover; flex-shrink: 0; }
.moment-post .post-body { display: flex; flex-direction: column; gap: 7px; width: 100%;}
.post-body .author-name { font-weight: 600; color: #556693; }
.post-body .post-text { line-height: 1.5; word-break: break-word; }
.post-body .post-image { width: 180px; height: 180px; }
.post-body .post-location { font-size: 12px; color: #556693; }
.post-interactions { display: flex; align-items: center; justify-content: space-between; font-size: 13px; color: #8a8a8a; margin-top: 10px;}
.interaction-buttons { position: relative; }
.interaction-toggle-btn { background-color: #f7f7f7; color: #576b95; border: none; border-radius: 4px; padding: 0 8px; line-height: 18px; height: 18px; font-size: 20px; font-weight: bold; cursor: pointer; position: relative; top: 4px; }
.interaction-popup { position: absolute; right: 35px; bottom: -2px; display: flex; background-color: #4b5154; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); overflow: hidden; transform: scale(0); transform-origin: right center; transition: transform 0.1s ease-out; white-space: nowrap; }
.interaction-popup.active { transform: scale(1); }
.popup-action { color: white; padding: 8px 15px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; }
.popup-action:hover { background-color: #3a3a3a; }
.popup-divider { width: 1px; background-color: #606060; margin: 6px 0; }
.moment-interaction-area { background-color: #f7f7f7; border-radius: 4px; margin-top: 10px; padding: 1px 10px 8px 10px; position: relative; overflow: hidden; }
.moment-interaction-area::before { content: ''; position: absolute; top: -6px; left: 15px; width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 6px solid #f7f7f7; }
.moment-interaction-area b { font-weight: 500; color: #576b95; }
.moment-interaction-area .comment-item span { color: #333; }
.moment-interaction-area .likes-list { background-color: transparent; padding: 4px 0; margin: 0; color: #556693; font-size: 14px; word-break: break-all; }
.likes-list + .moment-comments-section { border-top: 1px solid #e5e5e5; margin-top: 6px; padding-top: 6px; }
.comments-list { padding-top: 8px; display: flex; flex-direction: column; gap: 5px; font-size: 14px; margin-bottom: 8px; }
.comment-item { line-height: 1.5; }
.comment-item b { margin-right: 5px; }
.comment-input-area { display: flex; gap: 8px; overflow: hidden; max-height: 0; transition: max-height 0.3s ease-out, margin-top 0.3s ease-out; margin-top: 0; }
.comment-input-area.active { max-height: 50px; margin-top: 8px; }
.comment-input-area input { flex-grow: 1; border: 1px solid #e5e5e5; border-radius: 15px; padding: 6px 12px; font-size: 14px; outline: none; }
.comment-input-area button { border: none; background-color: var(--button-primary); color: white; border-radius: 15px; padding: 6px 12px; font-size: 14px; cursor: pointer; }
.videocall-action-item { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 70px; text-align: center; }
.action-label { color: white; font-size: 13px; font-weight: 500; }
.placeholder-action-btn svg { width: 32px; height: 32px; color: white; margin-top: 18px; }
#call-log-screen .videocall-overlay { flex: 1; min-height: 0; overflow-y: auto; }
#videocall-screen { background-color: #1c1c1e; }
.videocall-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.5; }
.videocall-overlay { position: relative; z-index: 2; width: 100%; height: 100%; display: flex; flex-direction: column; padding: 70px 20px 20px 20px; box-sizing: border-box; }
#videocall-my-preview { position: absolute; top: 60px; right: 20px; width: 100px; height: 170px; border: none; border-radius: 8px; overflow: hidden; z-index: 10; }
#videocall-my-avatar { width: 100%; height: 100%; object-fit: cover; }
#videocall-messages { flex-grow: 1; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; gap: 10px; overflow-y: auto; padding-bottom: 10px; padding-top: 90px; }
.videocall-message { color: white; text-align: center; padding: 5px 12px; background-color: rgba(0, 0, 0, 0.4); border-radius: 10px; font-size: 16px; max-width: 90%; word-break: break-word; margin-bottom: 4px; }
.videocall-message.user-call { color: rgba(255, 255, 255, 0.95); }
.videocall-message.ai-call { color: rgba(255, 255, 255, 0.75); }
.videocall-message.ai-call i { font-style: italic; opacity: 0.7; }
.videocall-controls { display: flex; flex-direction: column; gap: 15px; padding-top: 15px; }
.videocall-input-area { display: flex; width: 100%; gap: 10px; }
#videocall-input { flex-grow: 1; background-color: rgba(255, 255, 255, 0.1); border: none; color: white; border-radius: 8px; padding: 10px; transition: background-color 0.2s; }
#videocall-input:focus { outline: none; box-shadow: none; }
#videocall-send-btn { background-color: rgba(0, 0, 0, 0.4); color: rgba(255, 255, 255, 0.6); border: none; border-radius: 8px; padding: 0 15px; }
#videocall-input::placeholder { color: #d1d1d1; }
#videocall-hangup-btn { background-color: #ff3b30; background-image: url('https://i.postimg.cc/bNHGPnGM/IMG-5742.png'); background-size: 80%; background-repeat: no-repeat; background-position: center; width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer; }
.videocall-main-actions { display: flex; justify-content: space-evenly; align-items: center; gap:5px; width: 100%; }
.placeholder-action-btn { width: 70px; height: 70px; background-color: rgba(128, 128, 128, 0.3); border-radius: 50%; }
.videocall-message.loading { display: flex; align-items: center; background-color: transparent; }
.videocall-message.loading span { width: 8px; height: 8px; margin: 0 2px; background-color: rgba(255, 255, 255, 0.6); border-radius: 50%; display: inline-block; animation: bounce-dot 1.4s infinite ease-in-out both; }
.videocall-message.loading span:nth-child(1) { animation-delay: -0.32s; }
.videocall-message.loading span:nth-child(2) { animation-delay: -0.16s; }
#incoming-call-screen, #outgoing-call-screen { background-color: #2E3331; justify-content: space-between; padding: 60px 20px 80px 20px; box-sizing: border-box; }
.incoming-call-overlay { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
.caller-info { color: white; text-align: center; margin-top: 40px; }
.caller-avatar { width: 100px; height: 100px; border-radius: 50%; object-fit: cover; margin-bottom: 20px; }
#incoming-call-name { font-size: 28px; font-weight: 500; margin: 0 0 10px 0; }
#incoming-call-reason { font-size: 16px; opacity: 0.8; }
.call-actions { display: flex; justify-content: space-around; width: 100%; }
.call-action-item { display: flex; flex-direction: column; align-items: center; gap: 10px; color: white; font-size: 14px; }
.call-action-btn { width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer; display: flex; justify-content: center; align-items: center; color: white; }
.call-action-btn img { display: block; width: 100%; height: 100%; object-fit: contain; }
.call-action-btn.decline { background-color: #ff3b30; }
.call-action-btn.accept { background-color: #34c759; }
#call-duration-timer { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); color: white; background-color: rgba(0, 0, 0, 0.4); padding: 4px 12px; border-radius: 10px;  font-size: 14px; font-weight: 500; z-index: 11; display: none; }
.modal-box { background: white; border-radius: 12px; width: 85%; padding: 20px; box-sizing: border-box; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
.modal-box h3 { text-align: center; margin-top: 0; }
.modal-box .settings-actions { border-top: none; padding: 10px 0 0 0; }
#custom-confirm-modal { z-index: 200; }
#custom-confirm-text { text-align: center; margin: 20px 0; line-height: 1.5; }
.main-hub-content { flex-grow: 1; overflow-y: hidden; position: relative; }
.hub-page { display: none; height: 100%; flex-direction: column; overflow-y: auto; }
.hub-page.active { display: flex; }
#hub-page-chat { background-color: var(--phone-bg); }
#tab-bar { flex-shrink: 0; display: flex; justify-content: space-around; padding: 0; background-color: #f7f7f7; border-top: 1px solid #e0e0e0; height: 68px; background-image: url('https://i.postimg.cc/t43vKXtz/IMG-5838.png'); background-size: 100% 100%; background-position: center; background-repeat: no-repeat; }
.tab-item .icon, .tab-item .tab-label { opacity: 0; }
.tab-item { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; color: #7a7e83; cursor: pointer; flex: 1; }
.tab-item .icon { width: 26px; height: 26px; }
.tab-item .icon svg { width: 100%; height: 100%; }
.tab-label { font-size: 10px; line-height: 1.2; }
.persona-checkbox-item { display: flex; align-items: center; padding: 10px 15px; }
.persona-checkbox-item input[type="checkbox"] { width: 20px; height: 20px; margin-right: 15px; accent-color: var(--wechat-green); }
.persona-checkbox-item .list-item-avatar { width: 40px; height: 40px; margin-right: 10px; }
.persona-checkbox-item .list-item-name { font-size: 15px; }
#message-context-menu { position: absolute; display: flex; background-color: #4b5154; border-radius: 8px; padding: 5px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 200; opacity: 0; transform: scale(0.9); pointer-events: none; transition: opacity 0.1s ease-out, transform 0.1s ease-out; }
#message-context-menu.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
.context-menu-item { color: white; padding: 8px 12px; font-size: 14px; cursor: pointer; white-space: nowrap; }
.context-menu-item:hover { background-color: #606060; }
.context-menu-item:first-child:hover { border-radius: 4px 0 0 4px; }
.context-menu-item:last-child:hover { border-radius: 0 4px 4px 0; }
#reply-preview-container { padding: 0 8px; background-color: var(--input-area-bg); }
#reply-preview-bar { display: none; align-items: center; justify-content: space-between; padding: 8px 10px; border-radius: 4px; margin-bottom: 5px; animation: slideDownReply 0.2s ease-out; }
.reply-preview-content { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 13px; color: var(--system-message-color); }
.reply-to-author { font-weight: 600; color: var(--ai-bubble-text); margin-right: 5px; }
#cancel-reply-btn { border: none; background: none; font-size: 20px; color: var(--system-message-color); cursor: pointer; padding: 0 5px; }
.quote-reply-container { display: flex; margin-top: -10px; margin-bottom: 17px; padding: 0 50px; box-sizing: border-box; width: 100%; }
.quote-reply-container.ai { justify-content: flex-start; }
.quote-reply-container.user { justify-content: flex-end; }
.quote-reply-box { background-color: #E1E1E1; padding: 7px 10px; border-radius: 5px; font-size: 13px; color: #656565; display: inline-block; max-width: calc(100% - 100px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.group-avatar-container { width: 50px; height: 50px; border-radius: 5px; margin-right: 15px; flex-shrink: 0; background-color: #e5e5e5; overflow: hidden; display: flex; flex-wrap: wrap; justify-content: center; align-content: center; gap: 2px; padding: 2px; box-sizing: border-box; }
.group-avatar-container .member-avatar { width: 14px; height: 14px; object-fit: cover; border-radius: 2px; }
.segmented-control { display: flex; background-color: #e9e9eb; border-radius: 8px; padding: 2px; }
.segmented-control-button { background-color: transparent; border: none; border-radius: 6px; padding: 4px 12px; font-size: 14px; font-weight: 500; color: #000000; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
.segmented-control-button.active { background-color: #ffffff; color: #000000; box-shadow: 0 1px 4px rgba(0,0,0,0.1); }
#create-chat-screen, #create-chat-screen .app-header, #create-group-chat-screen, #create-group-chat-screen .app-header, #icon-settings-screen, #icon-settings-screen .app-header, #widget-settings-screen, #widget-settings-screen .app-header, #prompt-list-screen, #prompt-editor-screen, #prompt-list-screen .app-header, #prompt-editor-screen .app-header, #api-settings-screen, #api-settings-screen .app-header, #persona-editor-screen, #persona-editor-screen .app-header, #ai-persona-list-screen, #my-persona-list-screen, #ai-persona-list-screen .app-header, #my-persona-list-screen .app-header { background-color: #ffffff; border-bottom: none; }
#create-chat-screen .settings-page-content, #create-group-chat-screen .settings-page-content, #icon-settings-screen .settings-page-content, #widget-settings-screen .settings-page-content, #prompt-list-screen .list-container, #prompt-editor-screen .settings-page-content { background-color: #ffffff; }
#create-chat-screen .form-group input[type="text"], #create-chat-screen .form-group .selection-box, #create-group-chat-screen .form-group input[type="text"], #create-group-chat-screen .form-group .selection-box { border-radius: 12px; border: 1px solid #e0e0e0; background-color: #f9f9f9; }
#create-chat-screen .form-group input[type="text"]:focus, #create-group-chat-screen .form-group input[type="text"]:focus { box-shadow: none; outline: none; background-color: #ffffff; border-color: #c7c7c7; }
#create-group-chat-screen .persona-checkbox-item { position: relative; padding: 12px 15px; }
#create-group-chat-screen .persona-checkbox-item::after { content: ''; position: absolute; bottom: 0; left: 85px; right: 0; height: 1px; background-color: #f0f0f0; }
#create-group-chat-screen .persona-checkbox-item:last-child::after { display: none; }
#create-group-chat-screen .settings-page-content { display: flex; flex-direction: column; gap: 15px; }
#create-group-chat-screen .form-group input[type="text"] { padding-left: 14px; padding-right: 14px; }
#create-group-chat-screen .form-group:last-of-type { flex-grow: 1; display: flex; flex-direction: column; min-height: 0; }
#create-group-chat-screen #group-ai-persona-list-container { flex-grow: 1; border: none; background-color: #ffffff; border-radius: 0; }
#create-group-chat-screen .persona-checkbox-item input[type="checkbox"] { -webkit-appearance: none; appearance: none; background-color: #f0f0f0; margin: 0 5px 0 0; font: inherit; color: currentColor; width: 20px; height: 20px; border: none; border-radius: 50%; transform: translateY(0); display: grid; place-content: center; cursor: pointer; transition: all 0.2s ease-in-out; }
#create-group-chat-screen .persona-checkbox-item input[type="checkbox"]:checked { background-color: var(--wechat-green); }
#create-group-chat-screen .persona-checkbox-item input[type="checkbox"]:checked::before { content: ''; width: 4px; height: 8px; border: solid white; border-width: 0 2px 2px 0; transform: rotate(45deg) translate(-1px, -2px); }
#create-group-chat-screen .persona-checkbox-item { gap: 12px; }
#widget-actions-container .upload-btn { background-color: rgba(241, 241, 241, 0.5); color: #000000; }
#widget-actions-container .upload-btn:active { background-color: rgba(241, 241, 241, 0.8); }
#widget-settings-screen .settings-actions { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 380px; display: flex; gap: 15px; z-index: 10; }
#widget-settings-screen .settings-actions button { flex: 1; padding: 14px 0; border-radius: 50px; border: none; font-size: 16px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; }
#widget-settings-screen .settings-actions .action-btn-secondary { background-color: #f1f1f1; color: #000000; }
#widget-settings-screen .settings-actions .save-btn { background-color: #000000; color: #ffffff; }
#icon-settings-screen #cancel-icon-changes-btn { background-color: #ffffff; color: #000000; border: 1px solid #e0e0e0; }
#icon-settings-screen #save-icon-changes-btn { background-color: #000000; color: #ffffff; border: none; }
#icon-settings-screen .actions-grid { grid-template-columns: repeat(3, 1fr); gap: 25px; }
#icon-settings-screen .actions-grid .action-grid-item:first-child { grid-column: 1 / -1; margin-bottom: 25px; }
#icon-settings-screen .actions-grid .action-grid-item:first-child .icon { width: 95px; height: 95px; box-shadow: 0 8px 25px rgba(0,0,0,0.1); }
#icon-settings-screen .action-grid-item .icon { transition: transform 0.2s ease, box-shadow 0.2s ease; }
#icon-settings-screen .action-grid-item:hover .icon { transform: scale(1.05); box-shadow: 0 6px 15px rgba(0,0,0,0.1); }
.widget-settings-content { flex-grow: 1; position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden; }
#widget-preview-container { position: relative; width: 90%; max-width: 380px; aspect-ratio: 1 / 1; transform: translateY(-90px); }
#widget-preview-container .new-widget-part { position: absolute; background-size: cover; background-position: center; background-repeat: no-repeat; background-color: #ffffff; box-shadow: 0 8px 25px rgba(0,0,0,0.1); }
#widget-preview-bg { width: 100%; height: 80%; top: 0; left: 0; border-radius: 28px; z-index: 1; }
#widget-preview-footer { width: 100%; height: 50%; bottom: 0; left: 0; border-radius: 28px; z-index: 2; }
#widget-preview-avatar { width: 108px; height: 108px; top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 50%; z-index: 3; border: none; }

#widget-actions-container {
    position: absolute;
    bottom: 120px; /* 调整了垂直位置，使其在“保存”按钮的上方 */
    left: 50%;
    transform: translateX(-50%);
    width: 90%; /* 稍微加宽以适应水平布局 */
    max-width: 380px;
    display: flex;
    flex-direction: row; /* [核心修改] 将布局方向改为水平 */
    justify-content: space-between; /* [核心修改] 使按钮均匀分布 */
    gap: 10px; /* 调整按钮之间的间距 */
    z-index: 10;
}

#widget-actions-container .upload-btn {
    background-color: rgba(241, 241, 241, 0.5);
    color: #000000;
    padding: 12px 0; /* 略微增加垂直内边距 */
    border-radius: 40px;
    border: 1px solid #eee;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s;
    flex: 1; /* [核心修改] 让按钮平分容器宽度 */
    margin: 0; /* [核心修改] 移除不必要的边距 */
}

#settings-hub-screen .settings-page-content, #settings-hub-screen .app-header { background-color: var(--body-bg); border-bottom: none; }
#settings-hub-screen .settings-page-content { padding-top: 20px; }
#prompt-editor-screen input[type="text"], #prompt-editor-screen textarea { border-radius: 12px; border: 1px solid #dde2e8; background-color: #ffffff; }
#prompt-editor-screen input[type="text"]:focus, #prompt-editor-screen textarea:focus { box-shadow: none; border-color: #dde2e8; outline: none; }
#persona-selection-modal { justify-content: flex-end !important; }
#persona-selection-modal .modal-box { background-color: #ffffff; padding-bottom: 0; width: 100%; max-width: 100%; border-radius: 20px 20px 0 0; padding-bottom: 30px; margin-bottom: 0; transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.1, 0.7, 0.5, 1); }
#persona-selection-modal.active .modal-box { transform: translateY(0); }
#persona-selection-modal .app-header { background-color: #ffffff !important; border-bottom: none !important; position: relative; height: 25px; padding: 15px 0 !important; }
#persona-selection-modal .app-header h2 { position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -90%) !important; color: #000000; }
#modal-persona-list { background-color: #ffffff; display: flex; flex-direction: column; gap: 8px; padding: 15px; padding-top: 8px; padding-bottom: 30px; max-height: 450px; overflow-y: auto; -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%); mask-image: linear-gradient(to bottom, black 90%, transparent 100%); }
#modal-persona-list .list-item-content { position: relative; display: flex; align-items: center; height: 65px; flex-shrink: 0; padding: 0 16px 0 24px; border-radius: 12px; overflow: hidden; background-size: auto 400%; background-position: right; background-repeat: no-repeat; justify-content: flex-start; border-bottom: none; }
#modal-persona-list .list-item-content::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to right, rgba(240, 240, 245, 0.98) 15%, rgba(240, 240, 245, 0) 85% ); z-index: 1; }
#modal-persona-list .list-item-name { font-size: 18px; font-weight: 500; color: #000000; text-shadow: none; position: relative; z-index: 2; margin-left: 20px; }
#persona-selection-modal .settings-actions { background-color: #ffffff !important; border-top: none !important; padding: 15px 15px 30px 15px; }
#persona-selection-modal .settings-actions .action-btn-secondary { background-color: #f0f0f0; color: #000000; }
#persona-selection-modal .settings-actions .save-btn { background-color: #000000; color: #ffffff; }
#modal-persona-list .list-item-avatar { display: none; }
.gossip-post-item { background-color: var(--ai-bubble-bg); border-radius: 5px; box-shadow: none; overflow: hidden; display: flex; flex-direction: column; border: none; padding: 0; margin-bottom: 25px; }
.gossip-post-image { width: 100%; height: auto; aspect-ratio: 7 / 3; object-fit: cover; background-color: #f0f0f0; }
.gossip-post-text-wrapper { padding: 15px; }
.gossip-post-title { font-size: 18px; font-weight: 600; color: var(--header-text); margin: 0 0 8px 0; }
.gossip-post-content { font-size: 15px; line-height: 1.6; color: var(--ai-bubble-text); white-space: pre-wrap; word-break: break-word; margin: 0; }
.edited-tag { font-size: 11px; color: var(--system-message-color); margin-left: 8px; vertical-align: bottom; }
.inline-edit-textarea { width: 100%; box-sizing: border-box; border: 1px solid #dcdcdc; border-radius: 12px; padding: 10px 14px; font-size: 17px; line-height: 1.5; resize: none; overflow-y: hidden; background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); transition: border-color 0.2s; }
.inline-edit-textarea:focus { outline: none; border-color: #b0b0b0; }
.inline-edit-buttons { display: flex; justify-content: center; gap: 12px; margin-top: 10px; }
.inline-edit-buttons button { border-radius: 20px; }
.message-wrapper.editing-highlight .content { background-color: #d8f5c6 !important; }
#edit-message-bar { width: 100%; box-sizing: border-box; }
.message-bubble .content.transfer-content::after { display: none !important; }
.transfer-details .transfer-amount { font-weight: 600; }

.action-grid-item .icon {
    background-color: #ffffff; /* [核心修改] 將底色改為白色 */
    color: #000000;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08); /* 加上一點細微的陰影，避免和白色背景融為一體 */
    border-radius: 18px;
}

#persona-editor-screen .settings-actions { flex-direction: column; gap: 12px; padding: 15px 35px 40px 35px; }
#persona-editor-screen .settings-actions button { flex: none; width: 100%; }
#persona-editor-screen .settings-actions .save-btn { background-color: #000000; color: #ffffff; }
#persona-editor-screen .settings-actions .action-btn-secondary { background-color: #f1f1f1; color: #000000; }
#home-settings-screen { background-color: #f1f1f1; position: relative; }
#home-settings-screen .app-header { background-color: transparent; border-bottom: none; position: relative; z-index: 2; }
#home-settings-screen #home-wallpaper-preview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border: none; z-index: 1; margin: 0; }
#home-settings-screen .wallpaper-actions { position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%); width: 80%; display: flex; flex-direction: column; gap: 12px; z-index: 2; }
#home-settings-screen .settings-actions { position: relative; z-index: 2; background-color: transparent; border-top: none; padding: 15px 35px 40px 35px; width: 100%; box-sizing: border-box; }
#home-settings-screen .settings-actions button, #home-settings-screen .wallpaper-actions button { width: 100%; border-radius: 50px; border: none; font-weight: 600; padding-top: 12px; padding-bottom: 12px; }
#home-settings-screen .wallpaper-actions button { background-color: rgba(241, 241, 241, 0.4); color: #000000; }
#home-settings-screen .settings-actions .save-btn { background-color: #000000; color: #ffffff; }
#persona-editor-screen textarea { border-radius: 15px !important; }
#persona-editor-screen .settings-page-content { display: flex; flex-direction: column; }
#persona-editor-screen .form-group:nth-of-type(1) { order: 2; }
#persona-editor-screen .form-group:nth-of-type(2) { order: 1; }
#persona-editor-screen .form-group:nth-of-type(3) { order: 3; }
#persona-editor-screen .form-group:nth-of-type(2) > div { display: flex; flex-direction: column; align-items: center; gap: 15px; transform: translateX(8px); }
#persona-editor-screen .form-group:nth-of-type(2) > label { display: none; }
#persona-editor-screen #preset-avatar-preview { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: none; box-shadow: 0 0 0 1px #dde2e8; }
#persona-editor-screen input[type="text"], #persona-editor-screen textarea { background-color: #ffffff; border-radius: 15px; border: 1px solid #dde2e8; padding: 12px 16px; }
#persona-editor-screen input[type="text"]:focus, #persona-editor-screen textarea:focus { outline: none; box-shadow: none; border-color: #dde2e8; }
#persona-editor-screen .upload-btn { background: none; border: none; padding: 0; color: #8a8a8a; font-size: 15px; font-weight: 500; cursor: pointer; }
#ai-persona-list-screen .list-container, #my-persona-list-screen .list-container { flex-grow: 1; overflow-y: auto; min-height: 0; display: grid; grid-template-columns: repeat(2, 1fr); grid-auto-rows: min-content; gap: 15px; align-content: start; padding: 20px; background-color: transparent; }
#ai-persona-list-screen .list-item, #my-persona-list-screen .list-item { position: relative; padding: 0; border-radius: 12px; overflow: hidden; aspect-ratio: 1 / 1; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background-color: #eee; }
#ai-persona-list-screen .list-item-content, #my-persona-list-screen .list-item-content { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; cursor: pointer; }
#ai-persona-list-screen .list-item-avatar, #my-persona-list-screen .list-item-avatar { width: 100%; height: 100%; object-fit: cover; margin: 0; border-radius: 0; }
#ai-persona-list-screen .list-item-name, #my-persona-list-screen .list-item-name { position: absolute; bottom: 0; left: 0; right: 0; margin: 0; padding: 20px 12px 12px 12px; color: white; font-size: 16px; font-weight: 600; text-shadow: 0 1px 4px rgba(0, 0, 0, 0.6); background: linear-gradient(to top, rgba(0,0,0,0.7), transparent); text-align: center; }
#ai-persona-list-screen .list-item.edit-mode .delete-button, #my-persona-list-screen .list-item.edit-mode .delete-button { position: absolute; top: 8px; right: 8px; z-index: 2; }
#ai-persona-list-screen .list-item::after, #my-persona-list-screen .list-item::after { display: none; }
#action-view-diary .icon { background-image: url('https://files.catbox.moe/56re65.png'); background-size: 85%; background-position: center; background-repeat: no-repeat; background-color: transparent; }
#chat-settings-screen .settings-page-content { background-color: var(--body-bg); padding: 0 15px; }
#settings-profile-item { padding-top: 15px; padding-bottom: 15px; }
#settings-profile-item .settings-profile-avatar { width: 60px; height: 60px; border-radius: 50%; box-shadow: none; }
#settings-profile-item .settings-profile-name { font-size: 18px; font-weight: 500; }
.settings-profile-avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
.settings-profile-name { font-size: 22px; font-weight: 600; color: var(--header-text); }
.settings-section { background-color: var(--ai-bubble-bg); border-radius: 12px; margin-bottom: 20px; overflow: hidden; }
.settings-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; position: relative; cursor: pointer; min-height: 24px; }
.settings-item:not(:last-child)::after { content: ''; position: absolute; bottom: 0; left: 15px; right: 0; height: 1px; background-color: var(--input-border); }
.settings-item .item-label { font-size: 16px; color: var(--header-text); }
.settings-item .item-value-container { display: flex; align-items: center; gap: 8px; color: var(--system-message-color); font-size: 16px; }
.settings-item .disclosure-indicator { font-size: 20px; font-weight: 200; color: var(--system-message-color); opacity: 0.5; }
.settings-item input[type="text"] { border: none; background: none; text-align: right; color: var(--system-message-color); font-size: 16px; padding: 0; width: 150px; }
.settings-item input[type="text"]:focus { outline: none; box-shadow: none; }
.settings-item .upload-btn { display: none; }
.settings-item .avatar-preview { width: 32px; height: 32px; border-radius: 5px; object-fit: cover; border: none; }
.settings-item input[type="number"] { border: none; background-color: transparent; font-size: 16px; color: var(--system-message-color); text-align: right; outline: none; -moz-appearance: textfield; appearance: textfield; }
.settings-item input[type="number"]::-webkit-outer-spin-button, .settings-item input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
#chat-settings-btn { font-size: 24px; font-weight: bold; letter-spacing: 2px; line-height: 1; padding-bottom: 5px; }
#delete-contact-btn { cursor: pointer; transition: background-color 0.2s; }
#delete-contact-btn:active { background-color: #f0f0f0; }
#api-settings-screen .settings-page-content { padding-left: 35px; padding-right: 35px; }
#api-settings-screen .form-group input, #api-settings-screen .form-group select { background-color: #f1f1f1; border: none; border-radius: 14px; text-align: center; }
#api-settings-screen .form-group input:focus, #api-settings-screen .form-group select:focus { box-shadow: none; outline: none; }
#api-settings-screen .settings-actions { flex-direction: column; border-top: none; gap: 12px; align-items: center; padding: 60px 35px 40px 60px; }
#api-settings-screen .settings-actions button { width: 60%; flex: none; border-radius: 50px; border: none; padding-top: 12px; padding-bottom: 12px; }
#api-settings-screen .fetch-btn { background-color: #f1f1f1; color: #000000; }
#api-settings-screen .save-btn { background-color: #000000; color: #ffffff; }
@keyframes slideUpFadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
@keyframes fadeOutIslandContent { from { opacity: 1; } to { opacity: 0; } }
@keyframes fadeInIslandContent { to { opacity: 1; } }
@keyframes bounce-dot { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
@keyframes slideDownReply { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
.message-appear-animation { animation: slideUpFadeIn 0.4s cubic-bezier(0.21, 0.6, 0.25, 1) forwards; }
@media (max-width: 420px) {
    html, body { display: block; background-color: var(--phone-bg); }
    #phone-screen { border-radius: 0; position: relative; }
}

/* 这段代码的意思是：当屏幕宽度大于 480px 时，应用以下样式 */
@media (min-width: 481px) {
    body {
        /* 在大屏幕上，让body变回灰色背景并居中内容 */
        background-color: var(--body-bg);
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #phone-screen {
        /* 在大屏幕上，让内容容器变回带圆角和阴影的手机形状 */
        width: 410px;  /* 您原来设定的宽度 */
        height: 880px; /* 您原来设定的高度 */
        border-radius: 47px;
        box-shadow: 0 0 0 1px #dcdcdc;
    }
}

/* 新增：免责声明和打赏页面的样式 */
#disclaimer-screen .settings-page-content,
#donation-page-screen .settings-page-content {
    background-color: var(--body-bg); /* 保持背景色与设置页一致 */
}

.disclaimer-text-container {
    padding: 20px 15px;
    font-size: 16px;
    line-height: 1.8;
    color: var(--ai-bubble-text);
}

.disclaimer-text-container p {
    margin-bottom: 1.5em;
}

#donation-qr-container {
    text-align: center;
    padding: 40px 20px;
}

#donation-qr-container img {
    max-width: 80%;
    height: auto;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

</style>

</head>

<body>
    <div id="phone-screen">

        <div id="status-bar">
            <span id="status-bar-time"></span>
            <div id="dynamic-island">
                <div class="island-content-wrapper"></div>
            </div>
            <div class="status-bar-right">
                <div class="signal-icon">
                    <div class="bar bar1"></div>
                    <div class="bar bar2"></div>
                    <div class="bar bar3"></div>
                    <div class="bar bar4"></div>
                </div>
                <div class="battery-icon">
                    <div class="battery-level"></div>
                </div>
            </div>
        </div>

        <div id="message-context-menu">
            <div class="context-menu-item" id="context-menu-view">查看</div>
            <div class="context-menu-item" id="context-menu-quote">引用</div>
            <div class="context-menu-item" id="context-menu-regenerate">重置</div>
            <div class="context-menu-item" id="context-menu-copy">复制</div>
            <div class="context-menu-item" id="context-menu-edit">编辑</div>
            <div class="context-menu-item" id="context-menu-delete">删除</div>
        </div>


        <div id="home-screen" class="screen active">
            <div id="new-decorative-widget">
                <div id="new-widget-bg" class="new-widget-part"></div>
                <div id="new-widget-footer" class="new-widget-part"></div>
                <div id="new-widget-avatar" class="new-widget-part"></div>
            </div>
            <div class="home-content-wrapper">
                <div class="home-widget-area" id="home-btn-main-hub">
                    <div class="widget-placeholder">
                        <img id="widget-main-image" src="https://i.postimg.cc/6qpVkNwj/IMG-5799.jpg" style="width: 100%; height: 100%; border-radius: 22px; object-fit: cover;">
                    </div>
                    <div class="widget-label">微信</div>
                </div>
                <div class="home-app-grid-area">
                    <div class="app-icon" id="home-btn-ai-persona"><div id="icon-contacts" class="icon-bg">💬</div><div class="app-label">联系人</div></div>
                    <div class="app-icon" id="home-btn-my-persona"><div id="icon-me" class="icon-bg">🩹</div><div class="app-label">我</div></div>
                    <div class="app-icon" id="home-btn-settings"><div id="icon-settings" class="icon-bg">⚙️</div><div class="app-label">设置</div></div>
                    <div class="app-icon" id="home-btn-prompt"><div id="icon-prompt" class="icon-bg">💭</div><div class="app-label">提示词</div></div>
                </div>
            </div>
            <div style="display: none;">
                <input type="file" id="new-bg-upload" accept="image/*">
                <input type="file" id="new-footer-upload" accept="image/*">
                <input type="file" id="new-avatar-upload" accept="image/*">
            </div>
            <div class="home-dock-wrapper">
                <div class="app-icon"><div id="icon-dock-1" class="icon-bg">🤍</div><div class="app-label"></div></div>
                <div class="app-icon"><div id="icon-dock-2" class="icon-bg">🩶</div><div class="app-label"></div></div>
                <div class="app-icon"><div id="icon-dock-3" class="icon-bg">🖤</div><div class="app-label"></div></div>
            </div>
        </div>

        <div id="main-hub-screen" class="screen">
            <header id="main-hub-header" class="app-header">
                <button id="main-hub-back-btn" class="back-btn">‹</button>
                <h2 id="main-hub-title">聊天</h2>
                <div class="header-actions">
                    <button id="main-hub-edit-btn" class="settings-btn" style="display: none;">编辑</button>
                    <button id="main-hub-add-btn" class="action-btn">+</button>
                </div>
            </header>
            <div class="main-hub-content">
                <div id="hub-page-chat" class="hub-page active">
                    <div id="chat-list-container" class="list-container"></div>
                </div>
                <div id="hub-page-contacts" class="hub-page">
                    <div id="contacts-list-container" class="list-container"></div>
                </div>
                <div id="hub-page-moments" class="hub-page">
                    <div id="moments-header">
                        <img id="moments-cover-img" src="">
                        <img id="moments-user-avatar" src="">
                        <input type="file" id="moments-cover-upload" accept="image/*" style="display:none;">
                        <input type="file" id="moments-avatar-upload" accept="image/*" style="display:none;">
                    </div>
                    <div id="moments-feed"></div>
                </div>
                <div id="hub-page-me" class="hub-page">
                    <div class="list-container" style="background-color: transparent; padding: 20px 0;">
                        <div class="list-item" id="me-page-profile-item" style="cursor: pointer; background-color: var(--ai-bubble-bg); padding: 15px; margin: 0 15px 20px 15px; border-radius: 8px;">
                            <div class="list-item-content" style="justify-content: space-between; align-items: flex-start;">
                                <img id="me-page-avatar" class="list-item-avatar" style="width: 60px; height: 60px; margin-right: 15px;">
                                <div class="list-item-info" style="gap: 6px;">
                                    <span id="me-page-name" class="list-item-name" style="font-size: 18px;"></span>
                                    <span id="me-page-description" class="list-item-last-message"></span>
                                </div>
                                <span style="color: var(--system-message-color); font-size: 20px; align-self: center;">›</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <footer id="tab-bar">
                <div id="tab-btn-chat" class="tab-item active" data-title="聊天"><div class="icon">1</div><span class="tab-label">聊天</span></div>
                <div id="tab-btn-contacts" class="tab-item" data-title="通讯录"><div class="icon">2</div><span class="tab-label">通讯录</span></div>
                <div id="tab-btn-moments" class="tab-item" data-title="朋友圈"><div class="icon">2</div><span class="tab-label">朋友圈</span></div>
                <div id="tab-btn-me" class="tab-item" data-title=""><div class="icon">2</div><span class="tab-label">我</span></div>
            </footer>
        </div>

        <div id="chat-screen" class="screen">
            <header class="app-header">
                <button id="chat-back-btn" class="back-btn">‹</button>
                <h2 id="chat-title">聊天</h2>
                <button id="chat-settings-btn" class="action-btn settings-btn" style="font-size: 16px;"> ... </button>
            </header>
            <div id="ai-status-bubble"></div>
            <main class="chat-messages" id="chat-messages"></main>
            <footer class="chat-input-area">
                <div id="edit-message-bar" style="display: none; padding: 8px; gap: 8px; align-items: center;">
                    <textarea id="edit-message-input" rows="1" style="flex-grow: 1; border-radius: 5px; padding: 10px 15px; font-size: 15px; resize: none;"></textarea>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <button id="save-edit-btn" class="save-btn" style="padding: 5px 12px; font-size: 14px; flex: none;">保存</button>
                        <button id="cancel-edit-btn" class="action-btn-secondary" style="padding: 5px 12px; font-size: 14px; flex: none;">取消</button>
                    </div>
                </div>
                <div id="reply-preview-container">
                    <div id="reply-preview-bar">
                        <div class="reply-preview-content">
                            <span class="reply-to-author"></span>
                            <span class="reply-to-text"></span>
                        </div>
                        <button id="cancel-reply-btn">&times;</button>
                    </div>
                </div>
                <div class="chat-input-row">
                    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
                    <button id="toggle-actions-panel-btn"></button>
                    <textarea id="chat-input" placeholder="" rows="1"></textarea>
                    <button id="toggle-sticker-panel-btn" title="表情">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                            <line x1="9" y1="9" x2="9.01" y2="9"></line>
                            <line x1="15" y1="9" x2="15.01" y2="9"></line>
                        </svg>
                    </button>
                    <button id="dynamic-action-btn"></button>
                </div>
                <div id="chat-actions-panel">
                    <div class="actions-grid">
                        <div id="action-send-image" class="action-grid-item"><div class="icon">📷</div><div class="label">相册</div></div>
                        <div id="action-start-videocall" class="action-grid-item"><div class="icon">📞</div><div class="label">视频通话</div></div>
                        <div id="action-send-location" class="action-grid-item"><div class="icon">🎵</div><div class="label">位置</div></div>
                        <div id="action-send-voice" class="action-grid-item"><div class="icon">🕸️</div><div class="label">语音</div></div>
                        <div id="action-send-image-text" class="action-grid-item"><div class="icon">♠️</div><div class="label">图片描述</div></div>
                        <div id="action-send-transfer" class="action-grid-item"><div class="icon">🎹</div><div class="label">转账</div></div>
                        <div id="action-view-diary" class="action-grid-item">
                           <div class="icon"></div>
                           <div class="label">查看随笔</div>
                        </div>
                    </div>
                </div>
                <div id="sticker-panel" class="chat-actions-panel">
                    <div id="chat-sticker-grid"></div>
                </div>
                <div id="home-indicator-bar"></div>
            </footer>
        </div>
        
        <div id="public-account-screen" class="screen">
            <header class="app-header">
                <button id="public-account-back-btn" class="back-btn">‹</button>
                <h2>公众号</h2>
            </header>
            <div id="public-account-feed" class="list-container" style="padding: 15px;">
            </div>
        </div>

        <div id="videocall-screen" class="screen">
            <img id="videocall-bg-image" class="videocall-bg">
            <div class="videocall-overlay">
                <div id="videocall-my-preview"><img id="videocall-my-avatar"></div>
                <div id="call-duration-timer">00:00</div>
                <div id="videocall-messages"></div>
                <div class="videocall-controls">
                    <div class="videocall-main-actions">
                        <div class="videocall-action-item">
                            <div class="placeholder-action-btn">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>
                            </div>
                            <div class="action-label">扬声器</div>
                        </div>
                        <div class="videocall-action-item">
                            <button id="videocall-hangup-btn"></button>
                            <div class="action-label">挂断</div>
                        </div>
                        <div class="videocall-action-item">
                            <div class="placeholder-action-btn">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                            </div>
                            <div class="action-label">切语音</div>
                        </div>
                    </div>
                    <div class="videocall-input-area">
                        <input type="text" id="videocall-input" placeholder="">
                        <button id="videocall-send-btn">发送</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="incoming-call-screen" class="screen">
            <div class="incoming-call-overlay">
                <div class="caller-info">
                    <img id="incoming-call-avatar" class="caller-avatar" src="">
                    <h3 id="incoming-call-name">AI 角色</h3>
                    <p id="incoming-call-reason">正在邀请你进行视频通话...</p>
                </div>
                <div class="call-actions">
                    <div class="call-action-item">
                        <button id="decline-call-btn" class="call-action-btn decline"><img src="https://i.postimg.cc/bNHGPnGM/IMG-5742.png" alt="拒绝来电"></button>
                        <span>拒绝</span>
                    </div>
                    <div class="call-action-item">
                        <button id="accept-call-btn" class="call-action-btn accept"><img src="https://i.postimg.cc/pLLdt6Mh/IMG-5743.png" alt="接听来电"></button>
                        <span>接听</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="outgoing-call-screen" class="screen">
            <div class="incoming-call-overlay">
                <div class="caller-info">
                    <img id="outgoing-call-avatar" class="caller-avatar" src="">
                    <h3 id="outgoing-call-name">AI 角色</h3>
                    <p id="outgoing-call-status">正在呼叫...</p>
                </div>
                <div class="call-actions" style="justify-content: center;">
                    <div class="call-action-item">
                        <button id="cancel-outgoing-call-btn" class="call-action-btn decline">
                            <img src="https://i.postimg.cc/bNHGPnGM/IMG-5742.png" alt="取消呼叫">
                        </button>
                        <span>取消</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="call-log-screen" class="screen">
            <header class="app-header">
                <button id="call-log-back-btn" class="back-btn">‹</button>
                <h2>通话记录</h2>
            </header>
            <div class="videocall-overlay" style="padding-top: 0;">
                <div id="call-log-messages" class="videocall-messages" style="justify-content: flex-start; padding: 15px; gap: 15px;"></div>
            </div>
        </div>

        <div id="ai-persona-list-screen" class="screen">
            <header class="app-header">
                <button id="ai-persona-list-back-btn" class="back-btn">‹</button>
                <h2>AI 人设库</h2>
                <div class="header-actions">
                    <button id="ai-persona-edit-btn" class="settings-btn">编辑</button>
                    <button id="add-ai-persona-btn" class="action-btn">+</button>
                </div>
            </header>
            <div class="list-container" id="ai-persona-list-container"></div>
        </div>

        <div id="my-persona-list-screen" class="screen">
            <header class="app-header">
                <button id="my-persona-list-back-btn" class="back-btn">‹</button>
                <h2>我的面具</h2>
                <div class="header-actions">
                    <button id="my-persona-edit-btn" class="settings-btn">编辑</button>
                    <button id="add-my-persona-btn" class="action-btn">+</button>
                </div>
            </header>
            <div class="list-container" id="my-persona-list-container"></div>
        </div>
        
        <div id="prompt-list-screen" class="screen">
            <header class="app-header">
                <button id="prompt-list-back-btn" class="back-btn">‹</button>
                <h2>提示词库</h2>
                <div class="header-actions">
                    <button id="prompt-edit-btn" class="settings-btn">编辑</button>
                    <button id="add-prompt-btn" class="action-btn">+</button>
                </div>
            </header>
            <div class="list-container" id="prompt-list-container"></div>
        </div>

        <div id="sticker-screen" class="screen">
            <header class="app-header">
                <button id="sticker-screen-back-btn" class="back-btn">‹</button>
                <h2>我的表情包</h2>
                <button id="add-sticker-btn" class="settings-btn" style="font-size: 16px;">添加</button>
            </header>
            <div id="manage-sticker-grid" class="settings-page-content" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; justify-items: center; align-content: flex-start;"></div>
            <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
        </div>

        <div id="persona-editor-screen" class="screen">
            <header class="app-header">
                <button id="persona-editor-back-btn" class="back-btn">‹</button>
                <h2 id="persona-editor-title">编辑预设</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><label for="preset-name-input">预设名称</label><input type="text" id="preset-name-input" placeholder="例如:图书馆魔法师"></div>
                <div class="form-group"><label>Avatar</label><div><img id="preset-avatar-preview" class="avatar-preview" src=""><button class="upload-btn" onclick="document.getElementById('preset-avatar-upload').click()"> ๑ᵒᯅᵒ๑…  </button><input type="file" id="preset-avatar-upload" accept="image/*" style="display:none;"></div></div>
                <div class="form-group"><label for="preset-content-input">详细设定</label><textarea id="preset-content-input" rows="10" style="width:100%;padding:12px;border:1px solid var(--input-border);border-radius:8px;font-size:14px;box-sizing:border-box;"></textarea></div>
            </div>
            <div class="settings-actions">
                <button class="save-btn" id="start-chat-from-editor-btn">开始聊天</button>
                <button class="action-btn-secondary" id="save-preset-btn">储存预设</button>
            </div>
        </div>

        <div id="prompt-editor-screen" class="screen">
            <header class="app-header">
                <button id="prompt-editor-back-btn" class="back-btn">‹</button>
                <h2 id="prompt-editor-title">编辑提示词</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><label for="prompt-title-input">提示词标题 (方便自己识别)</label><input type="text" id="prompt-title-input" placeholder="例如：线上规则"></div>
                <div class="form-group"><label for="prompt-content-input">提示词内容 (System Prompt)</label><textarea id="prompt-content-input" rows="15" placeholder="在这里输入详细的系统提示词..."></textarea></div>
            </div>
            <div class="settings-actions"><button class="save-btn" id="save-prompt-btn">储存提示词</button></div>
        </div>

        <div id="create-chat-screen" class="screen">
            <header class="app-header">
                <button id="create-chat-back-btn" class="back-btn">‹</button>
                <h2>建立新对话</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><label for="new-chat-name-input">备注</label><input type="text" id="new-chat-name-input" placeholder="给这个对话取个名字"></div>
                <div class="form-group"><label>选择人物</label><div class="selection-box" id="select-new-ai-persona-btn"><span id="new-chat-ai-selection-text" class="placeholder">从人设库选择</span></div></div>
                <div class="form-group"><label>选择我的面具</label><div class="selection-box" id="select-new-my-persona-btn"><span id="new-chat-my-selection-text" class="placeholder">从我的素材库选择</span></div></div>
            </div>
            <div class="settings-actions"><button class="save-btn" id="create-chat-btn">开始聊天</button></div>
        </div>

        <div id="create-group-chat-screen" class="screen">
            <header class="app-header">
                <button id="create-group-chat-back-btn" class="back-btn">‹</button>
                <h2>发起群聊</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><label for="group-chat-name-input">群聊名称</label><input type="text" id="group-chat-name-input" placeholder="给这个群聊取个名字"></div>
                <div class="form-group"><label>选择我的面具</label><div class="selection-box" id="select-group-my-persona-btn"><span id="group-my-persona-selection-text" class="placeholder">从我的预设选择</span></div></div>
                <div id="group-ai-persona-list-container" class="list-container" style="max-height: 500px;"></div>
            </div>
            <div class="settings-actions"><button class="save-btn" id="create-group-chat-btn">创建并开始聊天</button></div>
        </div>

        <div id="create-post-screen" class="screen">
            <header class="app-header">
                <button id="cancel-post-btn" class="back-btn" style="font-size: 16px; font-weight: normal;">取消</button>
                <h2>发表动态</h2>
                <button id="send-post-btn" class="save-btn" style="padding: 5px 10px; font-size: 15px;">发表</button>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><textarea id="post-text-input" rows="5" placeholder="此刻的想法..." style="border: none; outline: none;"></textarea></div>
                <div class="form-group">
                    <label for="post-image-text-input">配图想法 (多个请用逗号或中文逗号隔开)</label>
                    <input type="text" id="post-image-text-input" placeholder="例如：一只猫在睡觉,夕阳下的海滩">
                </div>
                <div class="form-group"><label>位置</label><input type="text" id="post-location-input" placeholder="你的位置"></div>
            </div>
        </div>

        <div id="settings-hub-screen" class="screen">
            <header class="app-header">
                <button id="settings-hub-back-btn" class="back-btn">‹</button>
                <h2>设置</h2>
            </header>
            <div class="settings-page-content">
                <div class="settings-section">
                    <div id="settings-hub-api-btn" class="settings-item">
                        <span class="item-label">API 设定</span>
                        <div class="item-value-container">
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                </div>
        
                <div class="settings-section">
                    <div id="settings-hub-widget-btn" class="settings-item">
                        <span class="item-label">小组件设定</span>
                        <div class="item-value-container">
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                    <div id="settings-hub-wallpaper-btn" class="settings-item">
                        <span class="item-label">壁纸设定</span>
                        <div class="item-value-container">
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                    <div id="settings-hub-icon-btn" class="settings-item">
                        <span class="item-label">图示设定</span>
                        <div class="item-value-container">
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                </div>
        
                <div class="settings-section">
                    <div class="settings-item">
                        <span class="item-label">夜间模式</span>
                        <div id="settings-hub-dark-mode-toggle" class="toggle-switch">
                            <div class="toggle-knob"></div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div id="settings-hub-disclaimer-btn" class="settings-item">
                        <span class="item-label">免责声明</span>
                        <div class="item-value-container">
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                </div>
                <div class="settings-section">
                    <div id="export-data-btn" class="settings-item" style="cursor: pointer;">
                        <span class="item-label" style="color: #007aff;">汇出全部资料</span>
                    </div>
                    <div id="import-data-btn" class="settings-item" style="cursor: pointer;">
                        <span class="item-label" style="color: #007aff;">汇入备份档案</span>
                    </div>
                </div>

                <div id="donation-btn" style="text-align: center; margin-top: 30px; cursor: pointer;">
                    <span>☕️ </span>
                </div>
                
                <input type="file" id="import-file-input" accept=".json,.txt" style="display: none;">
            </div>
        </div>
        
        <div id="widget-settings-screen" class="screen">
            <header class="app-header" style="background-color: transparent; border-bottom: none; z-index: 10;">
                <button id="widget-settings-back-btn" class="back-btn" style="color: #000000;">‹</button>
                <h2 style="color: #000000;">小组件设定</h2>
            </header>
            <div class="widget-settings-content">
                <div id="widget-preview-container">
                    <div id="widget-preview-bg" class="new-widget-part"></div>
                    <div id="widget-preview-footer" class="new-widget-part"></div>
                    <div id="widget-preview-avatar" class="new-widget-part"></div>
                </div>
                <div id="widget-actions-container">
                    <button id="change-widget-bg-btn" class="upload-btn">更换背景</button>
                    <button id="change-widget-footer-btn" class="upload-btn">更换页脚</button>
                    <button id="change-widget-avatar-btn" class="upload-btn">更换头像</button>
                </div>
            </div>
            <div style="display: none;">
                <input type="file" id="widget-bg-upload-input" accept="image/*">
                <input type="file" id="widget-footer-upload-input" accept="image/*">
                <input type="file" id="widget-avatar-upload-input" accept="image/*">
            </div>
            <div class="settings-actions">
                <button id="clear-all-widget-btn" class="action-btn-secondary">清除全部</button>
                <button id="save-widget-settings-btn" class="save-btn">保存</button>
            </div>
        </div>

        <div id="chat-settings-screen" class="screen">
            <header class="app-header">
                <button id="chat-settings-back-btn" class="back-btn">‹</button>
                <h2>对话设定</h2>
            </header>
            <div class="settings-page-content">
                <div class="settings-section">
                    <div class="settings-item" id="settings-profile-item">
                        <div class="item-value-container" style="gap: 15px;">
                            <img id="settings-main-avatar" class="settings-profile-avatar" src="">
                            <span id="settings-main-name" class="settings-profile-name"></span>
                        </div>
                        <span class="disclosure-indicator">›</span>
                    </div>
                </div>
                <div class="settings-section">
                    <div id="select-ai-persona-btn" class="settings-item">
                        <span class="item-label">AI 人物设定</span>
                        <div class="item-value-container">
                            <span id="chat-ai-persona-selection-text"></span>
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                    <div id="select-my-persona-btn" class="settings-item">
                        <span class="item-label">我的角色设定</span>
                        <div class="item-value-container">
                            <span id="chat-my-persona-selection-text"></span>
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                    <div id="select-prompt-btn" class="settings-item">
                        <span class="item-label">系统提示词</span>
                        <div class="item-value-container">
                            <span id="chat-prompt-selection-text" class="placeholder">默认</span>
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-item">
                        <label for="chat-name-input" class="item-label">对方备注</label>
                        <input type="text" id="chat-name-input">
                    </div>
                    <div id="trigger-chat-wallpaper-upload" class="settings-item">
                        <span class="item-label">聊天背景</span>
                        <div class="item-value-container">
                            <span id="chat-wallpaper-status">未设置</span>
                            <span class="disclosure-indicator">›</span>
                        </div>
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-item">
                        <span class="item-label">感知现实时间</span>
                        <div id="time-awareness-toggle" class="toggle-switch">
                            <div class="toggle-knob"></div>
                        </div>
                    </div>
                    <div class="settings-item">
                        <span class="item-label">线下阅读模式</span>
                        <div id="offline-mode-toggle" class="toggle-switch">
                            <div class="toggle-knob"></div>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="chat-memory-rounds-input" class="item-label">记忆轮数</label>
                        <input type="number" id="chat-memory-rounds-input" min="0" value="0" style="width: 60px;">
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-item">
                        <span class="item-label">AI 主动搭话</span>
                            <div id="proactive-messaging-toggle" class="toggle-switch">
                       <div class="toggle-knob"></div>
                   </div>
                 </div>
                 <div class="settings-item">
                     <span class="item-label">主动搭话频率</span>
                      <div class="item-value-container">
                          <div id="proactive-frequency-selector" class="segmented-control">
                              <button class="segmented-control-button" data-value="60">低</button>
                              <button class="segmented-control-button" data-value="30">中</button>
                              <button class="segmented-control-button" data-value="10">高</button>
                           </div>
                       </div>
                    </div>
                   
                </div>
                <input type="file" id="chat-wallpaper-upload" accept="image/*" style="display:none;">
                <div class="settings-section" id="block-contact-section">
                    <div class="settings-item" id="block-contact-btn">
                        <span class="item-label" style="color: #ff9500; text-align: center; width: 100%;">拉黑联系人</span>
                    </div>
                </div>
                <div class="settings-section" id="unblock-contact-section" style="display: none;">
                    <div class="settings-item" id="unblock-contact-btn">
                        <span class="item-label" style="color: #34c759; text-align: center; width: 100%;">解除拉黑</span>
                    </div>
                </div>
                <div class="settings-section" id="delete-contact-section" style="margin-top: 30px;">
                    <div class="settings-item" id="delete-contact-btn">
                        <span class="item-label" style="color: #ff3b30; text-align: center; width: 100%;">删除联系人</span>
                    </div>
                </div>
            </div>
            <div class="settings-actions">
                <button class="save-btn" id="save-chat-settings-btn">储存设定</button>
            </div>
        </div>

        <div id="api-settings-screen" class="screen">
            <header class="app-header">
                <button id="api-settings-back-btn" class="back-btn">‹</button>
                <h2>API 设定</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group"><label for="api-url-input">API (OpenAI 格式)</label><input type="text" id="api-url-input" placeholder="例如：https://api.openai.com/v1"></div>
                <div class="form-group"><label for="api-key-input">API Key (金钥)</label><input type="password" id="api-key-input" placeholder="sk-..."></div>
                <div class="form-group"><label for="api-model-input">API 模型名称</label><select id="api-model-select" style="display: none; margin-bottom: 8px;"></select><input type="text" id="api-model-input" placeholder="点击下方获取或手动输入"></div>
            </div>
            <div class="settings-actions">
                <button id="fetch-models-btn" class="fetch-btn">获取模型</button>
                <button class="save-btn" id="save-api-btn">储存全部设定</button>
            </div>
        </div>

        <div id="home-settings-screen" class="screen">
            <header class="app-header">
                <button id="home-settings-back-btn" class="back-btn">‹</button>
                <h2>壁纸设定</h2>
            </header>
            <div class="settings-page-content">
                <div class="form-group">
                    <label>壁纸设定</label>
                    <div>
                        <img id="home-wallpaper-preview" class="wallpaper-preview" src="" alt="">
                        <div class="wallpaper-actions">
                            <button class="upload-btn" onclick="document.getElementById('home-wallpaper-upload').click()">更换背景</button>
                            <button id="clear-home-wallpaper-btn" class="upload-btn">清除背景</button>
                        </div>
                        <input type="file" id="home-wallpaper-upload" accept="image/*" style="display:none;">
                    </div>
                </div>
            </div>
            <div class="settings-actions"><button id="save-home-settings-btn" class="save-btn">储存设定</button></div>
        </div>

        <div id="icon-settings-screen" class="screen">
            <header class="app-header">
                <button id="icon-settings-back-btn" class="back-btn">‹</button>
                <h2>图示设定</h2>
            </header>
            <div class="settings-page-content">
                <p style="text-align: center; color: var(--system-message-color); font-size: 13px; padding: 0 20px 10px;">点击下方的图示，即可更换图片。</p>
                <div id="icon-grid-container" class="actions-grid" style="padding: 15px; gap: 20px;">
                </div>
            </div>
            <input type="file" id="icon-upload-input" accept="image/*" style="display: none;">
            <div class="settings-actions" style="padding: 15px 35px 40px 35px;">
                <button id="cancel-icon-changes-btn" class="action-btn-secondary">清除全部</button>
                <button id="save-icon-changes-btn" class="save-btn">保存全部图示</button>
            </div>
        </div>

        <div id="persona-selection-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box">
                <header class="app-header" style="border-bottom: 1px solid #eee; padding-left:0; padding-right: 0;">
                    <h2 id="persona-selection-modal-title" style="position: static; transform: none;">选择一个预设</h2>
                </header>
                <div class="list-container" id="modal-persona-list" style="max-height: 400px;"></div>
                <div class="settings-actions" style="border-top: 1px solid #eee; padding: 15px 0 0 0;">
                    <button id="cancel-selection-btn" class="action-btn-secondary">取消</button>
                    <button id="save-selection-btn" class="save-btn">储存</button>
                </div>
            </div>
        </div>
        
        <div id="select-chat-for-moment-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box">
                <header class="app-header" style="border-bottom: 1px solid #eee; padding-left:0; padding-right: 0;">
                    <h2 style="position: static; transform: none;">选择对话生成动态</h2>
                </header>
                <div class="list-container" id="modal-chat-list"></div>
                <div class="settings-actions" style="border-top: 1px solid #eee; padding: 15px 0 0 0;"><button id="cancel-chat-selection-btn" class="action-btn-secondary" style="width: 100%;">取消</button></div>
            </div>
        </div>

        <div id="create-new-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: flex-end; align-items: center; z-index: 110;">
            <div class="modal-box" style="width: 100%; border-radius: 12px 12px 0 0; margin-bottom: -20px; padding: 10px;">
                <div class="list-container" style="background: transparent;">
                    <div id="modal-btn-new-chat" class="list-item" style="text-align: center; display: block; cursor: pointer; padding: 15px;"><span class="list-item-name">新增对话框</span></div>
                    <div id="modal-btn-new-group" class="list-item" style="text-align: center; display: block; cursor: pointer; padding: 15px;"><span class="list-item-name">发起群聊</span></div>
                    <div id="modal-btn-add-contact" class="list-item" style="text-align: center; display: block; cursor: pointer; padding: 15px;"><span class="list-item-name">添加联系人</span></div>
                </div>
                <div class="settings-actions" style="padding: 10px 0 20px 0;"><button id="modal-btn-cancel-create" class="action-btn-secondary" style="width: 100%;">取消</button></div>
            </div>
        </div>

        <div id="moments-action-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: flex-end; align-items: center; z-index: 110;">
            <div class="modal-box" style="width: 100%; border-radius: 12px 12px 0 0; margin-bottom: -20px; padding: 10px;">
                <div class="list-container" style="background: transparent;">
                    <div id="modal-btn-post-my-moment" class="list-item" style="text-align: center; display: block; cursor: pointer; padding: 15px;"><span class="list-item-name">发表朋友圈</span></div>
                    <div id="modal-btn-generate-ai-moment" class="list-item" style="text-align: center; display: block; cursor: pointer; padding: 15px;"><span class="list-item-name">查看最近朋友圈</span></div>
                </div>
                <div class="settings-actions" style="padding: 10px 0 20px 0;"><button id="modal-btn-cancel-moments-action" class="action-btn-secondary" style="width: 100%;">取消</button></div>
            </div>
        </div>
        
        <div id="location-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box"><h3>发送位置</h3><div class="form-group"><input type="text" id="location-input-text" placeholder="输入地址..."></div><div class="settings-actions"><button id="cancel-location-btn" class="action-btn-secondary">取消</button><button id="send-location-btn" class="save-btn">发送</button></div></div>
        </div>
        <div id="voice-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box"><h3>录入语音文字</h3><div class="form-group"><textarea id="voice-input-text" rows="5" placeholder="请输入语音 ..."></textarea></div><div class="settings-actions"><button id="cancel-voice-btn" class="action-btn-secondary">取消</button><button id="send-voice-btn" class="save-btn">发送</button></div></div>
        </div>
        <div id="image-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box"><h3>输入图片内容</h3><div class="form-group"><input type="text" id="image-input-text" placeholder="输入图片ID或内容..."></div><div class="settings-actions"><button id="cancel-image-btn" class="action-btn-secondary">取消</button><button id="send-image-btn" class="save-btn">发送</button></div></div>
        </div>
        <div id="transfer-modal" class="screen" style="background: rgba(0,0,0,0.4); justify-content: center; align-items: center; z-index: 100;">
            <div class="modal-box">
                <h3>微信转账</h3>
                <div class="form-group"><label for="transfer-amount-input">转账金额</label><input type="number" id="transfer-amount-input" placeholder="￥0.00"></div>
                <div class="form-group"><label for="transfer-remark-input">备注 (可不填)</label><input type="text" id="transfer-remark-input" placeholder="给对方的留言"></div>
                <div class="settings-actions"><button id="cancel-transfer-btn" class="action-btn-secondary">取消</button><button id="send-transfer-btn" class="save-btn">转账</button></div>
            </div>
        </div>

        <div id="custom-confirm-modal" class="screen" style="background: rgba(0,0,0,0.6); justify-content: center; align-items: center; display: none;">
            <div class="modal-box">
                <h3 id="custom-confirm-title" style="text-align: center;">确定操作</h3>
                <p id="custom-confirm-text" style="text-align: center; margin: 20px 0; line-height: 1.5;"></p>
                <div class="settings-actions">
                    <button id="custom-confirm-cancel-btn" class="action-btn-secondary">取消</button>
                    <button id="custom-confirm-ok-btn" class="save-btn" style="background-color: var(--delete-bg);">确定</button>
                </div>
            </div>
        </div>

        <div id="diary-modal" class="screen" style="display: none; z-index: 150;">
            <div id="diary-text-container"></div>
            <button id="close-diary-modal-btn" class="save-btn">关闭</button>
        </div>
        
    </div> <div id="donation-modal" class="screen" style="background: rgba(0,0,0,0.6); justify-content: center; align-items: center; display: none; z-index: 250;">
        <div id="donation-image-container" style="padding: 10px; background: white; border-radius: 12px;">
            <img src="https://i.postimg.cc/15XLzBHS/IMG-0693.jpg" style="max-width: 80vw; max-height: 80vh; display: block; border-radius: 8px;">
        </div>
    </div>
    <div id="disclaimer-screen" class="screen">
            <header class="app-header">
                <button id="disclaimer-back-btn" class="back-btn">‹</button>
                <h2>免责声明</h2>
            </header>
            <div class="settings-page-content">
                <div class="disclaimer-text-container">
                    <p>本网页仅供个人学习和娱乐，所有聊天内容、朋友圈、通话记录等均为虚拟生成，不代表任何真实人物、事件或观点。</p>
                    <p>用户生成和使用的所有AI角色设定、对话、图片等内容的责任由用户自行承担。</p>
                    <p>请勿将本网页用于任何非法或侵犯他人权益的用途。开发者不对因使用本应用而产生的任何直接或间接后果负责。</p>
                    <p>作者：长尾蜥   网页名：喵喵机   禁止任何二传二改，本网页唯一获取途径QQ群：1048686068</p>
                    <p>邮箱留言：2768107102@qq.com</p>
                    <p> =^._.^= </p>
                </div>
            </div>
        </div>

        <div id="donation-page-screen" class="screen">
            <header class="app-header">
                <button id="donation-page-back-btn" class="back-btn">‹</button>
                <h2>支持开发者</h2>
            </header>
            <div class="settings-page-content">
                <div id="donation-qr-container">
                    <p style="color: var(--system-message-color); margin-bottom: 20px;">如果觉得这个应用有趣，可以请我喝杯咖啡☕️</p>
                    <img src="https://i.postimg.cc/15XLzBHS/IMG-0693.jpg" alt="Donation QR Code">
                    <p style="color: var(--system-message-color); font-size: 14px; margin-top: 20px;">感谢您的支持！</p>
                </div>
            </div>
        </div>

<script>

document.addEventListener('DOMContentLoaded', () => {

// ▼▼▼ 步骤1：新增这个“洗-牌”辅助函数 ▼▼▼
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        // 生成一个从 0 到 i 的随机索引
        const j = Math.floor(Math.random() * (i + 1));
        // 交换当前元素 array[i] 和随机选中的元素 array[j]
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
// ▲▲▲ 新增函数结束 ▲▲▲

const db = new Dexie('AIRP_Beautified_DB');

// ▼▼▼ 使用这个【修改版】，完整替换旧的 renderPublicAccountFeed 函数 ▼▼▼

const renderPublicAccountFeed = () => {
    const feedContainer = document.getElementById('public-account-feed');
    feedContainer.innerHTML = ''; // 清空旧内容

    if (appState.publicAccountPosts.length === 0) {
        feedContainer.innerHTML = `<p style="text-align:center; color:#8a8a8a; margin-top: 40px;">这里还没有任何内容...</p>`;
        return;
    }

    appState.publicAccountPosts.forEach((post, index) => { // 注意这里我们加入了 index
        // 1. 创建卡片的最外层容器
        const item = document.createElement('div');
        item.className = 'gossip-post-item';

        // 2. 创建图片元素
        const image = document.createElement('img');
        image.className = 'gossip-post-image';
        image.src = post.imageUrl;

        // 3. 创建包裹标题和内容的容器
        const textWrapper = document.createElement('div');
        textWrapper.className = 'gossip-post-text-wrapper';

        // 4. 创建标题元素
        const title = document.createElement('h3');
        title.className = 'gossip-post-title';
        title.textContent = post.title;

        // 5. 创建内容段落
        const content = document.createElement('p');
        content.className = 'gossip-post-content';
        content.textContent = post.content;

        // 6. 按照“洋葱模型”把元素一层层组装起来
        textWrapper.appendChild(title);
        textWrapper.appendChild(content);

        item.appendChild(image);
        item.appendChild(textWrapper);
        
        // --- 新增：为公众号卡片添加长按删除功能 ---
        let pressTimer = null;

        const handleLongPress = () => {
            clearTimeout(pressTimer);
            pressTimer = setTimeout(() => {
                deletePublicAccountPost(index); // 调用我们新增的删除函数
            }, 700); // 700毫秒触发长按
        };

        const clearLongPressTimer = () => {
            clearTimeout(pressTimer);
        };

        // 为整个卡片绑定事件
        item.addEventListener('mousedown', handleLongPress);
        item.addEventListener('touchstart', handleLongPress, { passive: true });

        // 当用户松开手指或鼠标移开时，取消计时器
        item.addEventListener('mouseup', clearLongPressTimer);
        item.addEventListener('mouseleave', clearLongPressTimer);
        item.addEventListener('touchend', clearLongPressTimer);
        item.addEventListener('touchcancel', clearLongPressTimer);
        // --- 长按功能添加结束 ---

        // 7. 把最终成型的卡片添加到页面中
        feedContainer.appendChild(item);
    });
};

const updatePromptSelectionDisplay = (chat) => {
    const selectionText = document.getElementById('chat-prompt-selection-text');
    if (!chat.promptIds || chat.promptIds.length === 0) {
        selectionText.textContent = '默认';
        selectionText.classList.add('placeholder');
    } else {
        const selectedTitles = chat.promptIds.map(id => {
            const prompt = appState.prompts.find(p => p.id === id);
            return prompt ? prompt.title : '';
        }).filter(Boolean);

        selectionText.textContent = selectedTitles.join('，') || '默认';
        selectionText.classList.remove('placeholder');
    }
};

const savePromptSelection = async () => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const selectedIds = [];
    document.querySelectorAll('#modal-persona-list input[type="checkbox"]:checked').forEach(checkbox => {
        selectedIds.push(checkbox.value);
    });

    chat.promptIds = selectedIds;

    // 将更改保存到数据库
    await dbStorage.set(KEYS.CHATS, appState.chats);

    updatePromptSelectionDisplay(chat);
    
    closePersonaSelectionModal();
};

// ▼▼▼ 在这里新增这一行 ▼▼▼
let proactiveTimers = {};

    const conditionalTypingStatuses = [
        // 规则1: 检查是否处于“线下阅读模式” (这个是我上次忘了加回去的，现在补上)
        {
            condition: (chat, lastMessage) => chat.isOfflineMode,
            statuses: [
                
                "...",
            ]
        },
        // 规则2: 检查玩家上一句话是否在“质问”
        {
            condition: (chat, lastMessage) => {
                if (typeof lastMessage?.content !== 'string') return false;
                const keywords = ["为什么", "搞什么", "说清楚", "真的吗", "你确定"];
                return keywords.some(word => lastMessage.content.includes(word));
            },
            statuses: [
                "对方正在狡辩...",
                "对方正在编造理由...",
                "对方似乎被问住了...",
                "对方正在思考如何蒙混过关...",
            ]
        },
        // 规则3: 检查 AI 是否心情好 (这是您新增的规则，已修正)
        { // <-- 【修正】加上了开始的大括号
            condition: (chat, lastMessage) => {
                const lastStatusUpdate = chat.history.slice().reverse().find(m => m.role === 'system' && m.content?.type === 'status_update');
                if (!lastStatusUpdate) return false;
                const statusText = lastStatusUpdate.content.status;
                return statusText.includes("开心") || statusText.includes("高兴");
            },
            statuses: [
                "对方的心情似乎很不错...",
                "对方正哼着小曲打字...",
                "对方的指尖在屏幕上轻快地跳跃...",
            ]
        }, // <-- 【修正】这里现在是正确的结束大括号和逗号

      
        {
            condition: (chat, lastMessage) => true, // 这个条件永远为真
            statuses: [
                "对方正在输入中...",
                "对方正在组织语言...",
                "对方打字太慢了...",
                "对方正在想怎么回复你...",
            ]
        }
    ];
    // ▲▲▲ 替换结束 ▲▲▲

    let islandRevertTimeout = null;
    let longPressTriggered = false;
let callTimerInterval = null;

const plusBtn = document.getElementById('toggle-actions-panel-btn');
    const stickerBtn = document.getElementById('toggle-sticker-panel-btn');
    const chatInputArea = document.querySelector('.chat-input-area');
    const actionsPanel = document.getElementById('chat-actions-panel');
    const stickerPanel = document.getElementById('sticker-panel');
    const messagesDiv = document.getElementById('chat-messages');

    const PANEL_OPEN_PADDING = '280px';
    const PANEL_CLOSED_PADDING = '60px';

    const openPanel = (mode) => {
        chatInputArea.classList.add('panel-open');
        messagesDiv.style.transition = 'padding-bottom 0.3s ease-in-out';
        messagesDiv.style.paddingBottom = PANEL_OPEN_PADDING;
        plusBtn.classList.add('active');

        if (mode === 'actions') {
            actionsPanel.style.display = 'grid';
            stickerPanel.style.display = 'none';
            stickerBtn.classList.remove('active');
        } else {
            actionsPanel.style.display = 'none';
            stickerPanel.style.display = 'flex';
            stickerBtn.classList.add('active');
            renderStickers();
        }
    };

    const closePanel = () => {
        chatInputArea.classList.remove('panel-open');
        messagesDiv.style.paddingBottom = PANEL_CLOSED_PADDING;
        plusBtn.classList.remove('active');
        stickerBtn.classList.remove('active');
    };

    // --- 数据库设置 ---
    db.version(1).stores({
        kvStore: 'key',
    });

    const DEFAULT_AVATAR = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAARFJREFUeJzt2LEJACEMxEAJ//9/dk8eEMVpU2ecK5eCynLpdDrdz+c55/vnaa3dD5/b2Wtrj/ZgB/ZgB/ZgB/ZgB/bAJ1hrf4s0n2vZTb8d2IMd2IMd2IMd2IMd2IE/sLZe7WubXw/swQ7swQ7swQ7swQ7swR/Y2trZDuxhD3ZgB3ZgB3ZgB3ZgB/ZgB3ZgB3ZgB3ZgB3bA9g7swQ7swQ7swQ7swQ7sAR/Y2tpu9b/ZvwN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN7sAN/fAERpA3b/e8YAgAAAABJRU5ErkJggg==';

// ▼▼▼ 使用这个【正确】的 appState 对象进行替换 ▼▼▼
const appState = { 
    apiConfig: { url: '', key: '', model: '' }, 
    personas: { ai: [], my: [] }, 
    chats: {},
    activeChatId: null,
    contacts: [],
    homeWallpaper: null,
    momentsData: { cover: null, avatar: null, posts: [] },
    currentPersonaType: 'ai', 
    editingPresetIndex: -1,
    editingPromptIndex: -1,
    personaSelectionContext: 'ai', 
    newChatTempPersonas: { ai: null, my: null }, 
    videoCallMessages: [],
    currentCallId: null,
    activeTab: 'chat',
    editMode: { chat: false, ai_persona: false, my_persona: false, prompt: false },
    pendingImage: null,
    widgetImages: { bg: null, footer: null, avatar: null },
    stickers: [],
    isDarkMode: false,
    prompts: [],
    hasNewPublicPosts: false,
    publicAccountPosts: [], // <--- 看，逗号在这里补上了！
    activeContextMenu: null,
    replyingToMessage: null,
    editingMessage: null,
    customIcons: {} ,
    tempCustomIcons: {}, // <--- ▼▼▼ 新增这一行 ▼▼▼
    currentMomentsRenderIndex: 0, // <--- 新增這一行
};
    
    const dbStorage = {
        async get(key, defaultValue) {
            const item = await db.kvStore.get(key);
            return item ? item.value : defaultValue;
        },
        async set(key, value) {
            try {
                await db.kvStore.put({ key, value });
            } catch (e) {
                console.error(`数据库保存失败 (key: ${key}):`, e);
                alert(`数据库保存失败，可能是储存空间已满或发生未知错误: ${e.message}`);
            }
        }
    };
    // ▼▼▼ 使用这段【正确】的代码进行替换 ▼▼▼
const KEYS = {
    API: 'apiConfig',
    CHATS: 'chats',
    CONTACTS: 'user_contacts_list', // <--- 修正：补上了这一行
    PERSONA_AI: 'persona_ai',
    PERSONA_MY: 'persona_my',
    HOME_WALLPAPER: 'home_wallpaper',
    MOMENTS_DATA: 'moments_data',
    DECORATIVE_WIDGET_IMAGES: 'decorative_widget_images',
    STICKERS: 'stickers_collection',
   
    PROMPTS: 'prompts_library',
    DARK_MODE: 'app_dark_mode_status',
    PUBLIC_ACCOUNT_POSTS: 'public_account_posts', // <--- 补上这个逗号
    CUSTOM_ICONS: 'custom_app_icons', 
};

    const showScreen = (screenId) => {
         document.querySelectorAll('.screen').forEach(s => {
            if (s.id !== screenId && !s.id.includes('-modal')) {
                s.classList.remove('active');
            }
         });
         const screen = document.getElementById(screenId);
         if (screen) screen.classList.add('active');
    };

    const showCustomConfirm = (title, text, onOkCallback) => {
        const modal = document.getElementById('custom-confirm-modal');
        const customConfirmTitle = document.getElementById('custom-confirm-title');
        const customConfirmText = document.getElementById('custom-confirm-text');
        const customConfirmOkBtn = document.getElementById('custom-confirm-ok-btn');

        customConfirmTitle.textContent = title;
        customConfirmText.innerHTML = text;
        customConfirmOkBtn.onclick = () => {
            if(onOkCallback) onOkCallback();
            hideCustomConfirm();
        };
        modal.style.display = 'flex';
        modal.style.visibility = 'visible';
        setTimeout(() => { modal.style.opacity = '1'; }, 10);
    };

    const hideCustomConfirm = () => {
        const modal = document.getElementById('custom-confirm-modal');
        modal.style.opacity = '0';
        setTimeout(() => {
            modal.style.display = 'none';
            modal.style.visibility = 'hidden';
            modal.querySelector('#custom-confirm-ok-btn').onclick = null;
        }, 300); 
    };
    
    const animateAndRemoveItem = (itemElement, onComplete) => {
        return new Promise(resolve => {
            if (!itemElement) {
                if (onComplete) onComplete();
                resolve();
                return;
            }
            // 使用一個稍微快一點的動畫，讓連續消除效果更流暢
            itemElement.style.transition = 'all 0.25s ease-out';
            itemElement.style.transform = 'scale(0.9)';
            itemElement.style.opacity = '0';
            setTimeout(() => {
                if (itemElement) itemElement.remove();
                if (onComplete) onComplete(); // 為了向下相容，仍然呼叫舊的回呼函數
                resolve(); // Promise 完成，通知下一步可以開始了
            }, 250); // 與 CSS transition 時間匹配
        });
    };
    
    const setupFileUploadHelper = (uploadInputId, previewImgId, callback) => {
        const uploadInput = document.getElementById(uploadInputId);
        uploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewImg = document.getElementById(previewImgId);
                    if (previewImg) previewImg.src = e.target.result;
                    if (callback) callback(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            uploadInput.value = '';
        });
    };

const handleViewAction = (message) => {
    if (!message) return;
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const contentType = message.type || message.content?.type;

    switch (contentType) {
        case 'retraction':
            const island = document.getElementById('dynamic-island');
            const islandContentWrapper = island.querySelector('.island-content-wrapper');
            const originalContent = message.originalContent;
            if (originalContent && islandContentWrapper) {
                islandContentWrapper.innerHTML = `
                    <div class="island-retraction-view">
                        <p class="label">对方撤回了</p>
                        <p class="content">${originalContent}</p>
                    </div>`;
                
                // 【关键】移除其他外观，添加“查看撤回”外观和“显示”类
                island.classList.remove('default-pill', 'notification-banner');
                island.classList.add('expanded-retraction', 'visible');
                
                islandRevertTimeout = setTimeout(revertIslandToDefault, 5000);
            }
            break;
        // ... (其他 case 保持不变)
        case 'call_log':
            openCallLogView(message.timestamp);
            break;
        default:
            let lastStatus = "AI 目前沒有特殊狀態";
            if (chat.history) {
                for (let i = chat.history.length - 1; i >= 0; i--) {
                    const msg = chat.history[i];
                    if (msg.role === 'system' && msg.content?.type === 'status_update') {
                        lastStatus = msg.content.status;
                        break;
                    }
                }
            }
            updateStatusBubble(lastStatus);
            break;
    }
};

// ▼▼▼ 全新功能：行内编辑 (替换旧的 handleEditAction) ▼▼▼

// 一个辅助函数，用于自动调整textarea的高度
const autoResizeTextarea = (element) => {
    element.style.height = 'auto';
    element.style.height = (element.scrollHeight) + 'px';
};

// 1. 开始行内编辑的核心函数
const startInlineEdit = (message, messageElement) => {
    // 如果已经有正在编辑的消息，或消息不是纯文本，则阻止操作
    if (appState.editingMessage || typeof message.content !== 'string') {
        if (typeof message.content !== 'string') alert('只能编辑纯文本消息。');
        return;
    }

    appState.editingMessage = { timestamp: message.timestamp }; // 标记正在编辑

    const bubble = messageElement.querySelector('.message-bubble');
    const contentDiv = bubble.querySelector('.content');

    // 隐藏原始的消息内容
    contentDiv.style.display = 'none';

    // 创建一个新的 textarea
    const textarea = document.createElement('textarea');
    textarea.className = 'inline-edit-textarea';
    // 将消息内容填入，注意把<br>换回换行符\n
    textarea.value = message.content.replace(/<br\s*\/?>/gi, '\n');

    // 创建按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'inline-edit-buttons';

    // 创建保存按钮
    const saveBtn = document.createElement('button');
    saveBtn.textContent = '保存';
    saveBtn.className = 'save-btn'; // 复用已有样式
    saveBtn.style.padding = '5px 15px'; // 微调样式
    saveBtn.onclick = () => saveInlineEdit(message, textarea.value, messageElement);

    // 创建取消按钮
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = '取消';
    cancelBtn.className = 'action-btn-secondary'; // 复用已有样式
    cancelBtn.style.padding = '5px 15px'; // 微调样式
    cancelBtn.onclick = () => cancelInlineEdit(messageElement);

    // 将按钮添加到容器，再将所有新元素添加到气泡中
    buttonContainer.appendChild(cancelBtn);
    buttonContainer.appendChild(saveBtn);
    bubble.appendChild(textarea);
    bubble.appendChild(buttonContainer);

    // 绑定输入事件以自动调整高度，并立即执行一次
    textarea.addEventListener('input', () => autoResizeTextarea(textarea));
    autoResizeTextarea(textarea);
    textarea.focus();
};

// 2. 保存修改
const saveInlineEdit = async (message, newText, messageElement) => {
    const chat = appState.chats[appState.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === message.timestamp);

    if (messageIndex > -1) {
        chat.history[messageIndex].content = newText;
        chat.history[messageIndex].edited = true; // 标记为已编辑
        await dbStorage.set(KEYS.CHATS, appState.chats);

        // 更新UI上的内容
        const contentDiv = messageElement.querySelector('.content');
        contentDiv.innerHTML = newText.replace(/\n/g, '<br>');

       
    }
    cancelInlineEdit(messageElement); // 调用取消函数来恢复UI
};

// 3. 取消编辑 (也用于保存后恢复UI)
const cancelInlineEdit = (messageElement) => {
    const bubble = messageElement.querySelector('.message-bubble');
    const contentDiv = bubble.querySelector('.content');
    const textarea = bubble.querySelector('.inline-edit-textarea');
    const buttonContainer = bubble.querySelector('.inline-edit-buttons');

    // 移除我们后加的输入框和按钮
    if (textarea) textarea.remove();
    if (buttonContainer) buttonContainer.remove();

    // 把原始的内容显示回来
    contentDiv.style.display = 'block';

    appState.editingMessage = null; // 清除正在编辑的标记
};
// ▲▲▲ 全新功能代码结束 ▲▲▲

// ▼▼▼ 将这个【遗漏的】函数，完整地添加到你的 <script> 标签内 ▼▼▼
const saveMessageEdit = async () => {
    // 检查是否有正在编辑的消息
    if (!appState.editingMessage || !appState.editingMessage.timestamp) {
        // 如果没有，则安全退出，防止错误
        cancelMessageEdit(); // 顺便清理一下状态
        return;
    }

    const { timestamp, element } = appState.editingMessage;
    
    const newContent = document.getElementById('edit-message-input').value.trim();
    if (!newContent) {
        alert('消息内容不能为空！');
        return;
    }

    const chat = appState.chats[appState.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);

    if (messageIndex > -1) {
        // 1. 更新内存中的数据
        chat.history[messageIndex].content = newContent;
        chat.history[messageIndex].edited = true; // 添加一个“已编辑”的标记

        // 2. 将更新保存到数据库
        await dbStorage.set(KEYS.CHATS, appState.chats);

        // 3. 更新界面上的消息气泡
        const contentDiv = element.querySelector('.content');
        contentDiv.innerHTML = newContent.replace(/\n/g, '<br>');

       
    }

    // 4. 退出编辑模式
    cancelMessageEdit();
};
// ▲▲▲ 添加到此结束 ▲▲▲

// ▼▼▼ 使用这个版本，替换旧的 cancelMessageEdit 函数 ▼▼▼
const cancelMessageEdit = () => {
    if (!appState.editingMessage) return;

    appState.editingMessage.element.classList.remove('editing-highlight');

    // 【核心修正】: 使用 querySelector 并选择 class 来正确显示主输入框
    document.getElementById('edit-message-bar').style.display = 'none';
    document.querySelector('.chat-input-row').style.display = 'flex';

    appState.editingMessage = null;
};

const handleRegenerateAction = async (clickedMessage) => {
    // 安全檢查：此功能只對AI的消息有效
    if (clickedMessage.role !== 'assistant') return;

    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    // 1. 尋找被點擊消息的索引
    const clickedMessageIndex = chat.history.findIndex(m => m.timestamp === clickedMessage.timestamp);
    if (clickedMessageIndex === -1) return;

    // 2. 向上和向下查找，確定AI這次完整回覆的範圍（這部分邏輯不變）
    let startIndex = clickedMessageIndex;
    let endIndex = clickedMessageIndex;

    for (let i = clickedMessageIndex - 1; i >= 0; i--) {
        const msg = chat.history[i];
        if (msg.role === 'assistant' || (msg.role === 'system' && (msg.content?.type === 'status_update' || msg.type === 'retraction'))) {
            startIndex = i;
        } else {
            break;
        }
    }
    for (let i = clickedMessageIndex + 1; i < chat.history.length; i++) {
        const msg = chat.history[i];
        if (msg.role === 'assistant' || (msg.role === 'system' && (msg.content?.type === 'status_update' || msg.type === 'retraction'))) {
            endIndex = i;
        } else {
            break;
        }
    }

    // ▼▼▼【核心動畫修改】▼▼▼
    // 3. 收集所有需要刪除的消息
    const messagesToDelete = chat.history.slice(startIndex, endIndex + 1);

    // 4. 建立一個反轉的陣列，這樣我們可以從下往上（從新到舊）依序刪除消息氣泡
    const reversedMessages = messagesToDelete.slice().reverse();
    for (const msg of reversedMessages) {
        const element = document.getElementById(`message-${msg.timestamp}`);
        if (element) {
            // 先處理附屬的元素（如引用條），等待它消失
            const nextElement = element.nextElementSibling;
            if (nextElement && (nextElement.classList.contains('quote-reply-container') || nextElement.classList.contains('voice-text-bubble'))) {
                await animateAndRemoveItem(nextElement);
            }
            // 再處理消息氣泡本身，並等待它消失
            await animateAndRemoveItem(element);
        }
    }
    // ▲▲▲ 修改結束 ▲▲▲

    // 5. 從 appState 的歷史記錄中一次性刪除這些消息
    const deleteCount = endIndex - startIndex + 1;
    chat.history.splice(startIndex, deleteCount);

    // 6. 保存狀態到資料庫
    await dbStorage.set(KEYS.CHATS, appState.chats);

    // 7. 觸發重新生成
    await receiveMessageHandler();
};

    const deleteMessage = (timestamp) => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        const messageIndex = chat.history.findIndex(msg => msg.timestamp === timestamp);
        if (messageIndex > -1) {
            showCustomConfirm('删除消息', '您确定要删除这条消息吗?', async () => {
                chat.history.splice(messageIndex, 1);
                await dbStorage.set(KEYS.CHATS, appState.chats);
                const messageElement = document.getElementById(`message-${timestamp}`);
                if (messageElement) animateAndRemoveItem(messageElement);
                const transcriptionBubble = document.getElementById(`transcription-${timestamp}`);
                if (transcriptionBubble) transcriptionBubble.remove();
            });
        }
    };

const addInteractionHandlers = (element, message) => {
    let pressTimer = null;
    let isLongPress = false;
    const longPressTime = 500; 

    // 1. 定義【單擊】時要執行的操作
    const handleShortPress = (targetElement) => {
        if (!message || typeof message.content !== 'object' || message.content === null) return;
        
        // ▼▼▼【BUG修正】▼▼▼
        // 修正了判斷條件，使其能正確識別 AI 發送的轉帳 (type 為 'send_transfer')
        if (message.role === 'assistant' && (message.content.type === 'transfer' || message.content.type === 'send_transfer')) {
            if (targetElement.closest('.transfer-content')) {
                // 如果尚未被收款，則執行收款操作
                if (!message.content.isReceived) {
                    handleReceiveTransfer(message, element);
                }
                return; // 處理完畢，終止後續點擊判斷
            }
        }
        // ▲▲▲ 修正結束 ▲▲▲
        
        // 舊有的單擊邏輯 (處理“點擊查看”類型的消息)
        switch (message.content.type) {
            case 'retraction':
                clearTimeout(islandRevertTimeout);
                const island = document.getElementById('dynamic-island');
                const islandContentWrapper = island.querySelector('.island-content-wrapper');
                const originalContent = message.content.originalContent;
                if (originalContent && islandContentWrapper) {
                    islandContentWrapper.innerHTML = `
                        <div class="island-retraction-view">
                            <p class="label">对方撤回了</p>
                            <p class="content">${originalContent}</p>
                        </div>`;
                    // ...
island.classList.add('expanded-retraction', 'visible'); // 同时添加外观和显示类
islandRevertTimeout = setTimeout(revertIslandToDefault, 5000);
// ...
                }
                return;

            case 'call_log':
                openCallLogView(message.timestamp);
                return;
        }
    };

    // 2. 定義【長按】時要執行的操作 (此部分邏輯不變)
    const handleLongPress = (targetElement) => {
        const imageTextCard = targetElement.closest('.image-text-content');
        if (imageTextCard) {
            const cover = imageTextCard.querySelector('.image-text-cover');
            const details = imageTextCard.querySelector('.image-text-details');
            if (cover && details) {
                const isCoverVisible = cover.style.display !== 'none';
                cover.style.display = isCoverVisible ? 'none' : 'flex';
                details.style.display = isCoverVisible ? 'block' : 'none';
            }
            return;
        }

        if (message && typeof message.content === 'object' && message.content !== null) {
            if (message.content.type === 'voice' || message.content.type === 'send_voice') {
                if (targetElement.closest('.voice-message-body')) {
                    toggleTranscription(message.timestamp);
                    return;
                }
            }
        }
        
        showContextMenu(message, element);
    };


    // 3. 統一的事件綁定邏輯 (此部分邏輯不變)
    const startPress = (e) => {
        isLongPress = false;
        pressTimer = setTimeout(() => {
            isLongPress = true;
            handleLongPress(e.target);
        }, longPressTime);
    };

    const endPress = (e) => {
        clearTimeout(pressTimer);
        if (!isLongPress) {
            handleShortPress(e.target);
        }
    };

    element.addEventListener('mousedown', startPress);
    element.addEventListener('mouseup', endPress);
    element.addEventListener('mouseleave', () => clearTimeout(pressTimer));

    element.addEventListener('touchstart', startPress, { passive: true });
    element.addEventListener('touchend', endPress);
    element.addEventListener('touchcancel', () => clearTimeout(pressTimer));
};

// 重写 toggleTranscription，使其更健壮
const toggleTranscription = (timestamp) => { 
    const parentWrapper = document.getElementById(`message-${timestamp}`);
    if (!parentWrapper) return;

    const existingBubble = parentWrapper.nextElementSibling;
    if (existingBubble && existingBubble.classList.contains('voice-text-bubble')) {
        existingBubble.remove();
        return;
    }
    
    document.querySelector('.voice-text-bubble')?.remove();

    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    // 安全检查：确保消息和语音文本都存在
    if (!message || typeof message.content !== 'object' || !message.content.text) return;

    const senderClass = message.role === 'user' ? 'user' : 'ai';
    
    const textBubbleWrapper = document.createElement('div');
    textBubbleWrapper.className = `message-wrapper ${senderClass} voice-text-bubble`;

    const newBubble = document.createElement('div');
    newBubble.className = `message-bubble ${senderClass} voice-text-translation`;
    
    const newAvatar = document.createElement('img');
    newAvatar.className = 'avatar';
    newAvatar.src = (senderClass === 'user' ? chat.personas.my.avatar : chat.personas.ai.avatar) || DEFAULT_AVATAR;

    const newContentDiv = document.createElement('div');
    newContentDiv.className = 'content';
    newContentDiv.innerHTML = message.content.text.replace(/\n/g, '<br>');

    newBubble.appendChild(newContentDiv);
    textBubbleWrapper.appendChild(newAvatar);
    textBubbleWrapper.appendChild(newBubble);
    
    parentWrapper.insertAdjacentElement('afterend', textBubbleWrapper);
    setTimeout(() => { textBubbleWrapper.style.opacity = '1'; }, 10);
};

// ▼▼▼ 新增此函数 ▼▼▼
const prependMessage = (message, container) => {
    const chat = appState.chats?.[appState.activeChatId];
    if (!chat) return;

    // --- 这部分逻辑和 appendMessage 完全一样 ---
    const { role, content: contentData, timestamp, author: authorName, replyTo, edited } = message;

    if (role.toLowerCase() === 'system') {
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system';
        bubble.id = `message-${timestamp}`;
        const systemContent = (typeof contentData === 'object' && contentData.content) ? contentData.content : contentData;
        bubble.textContent = systemContent;
        if (typeof contentData === 'object' && contentData.type === 'retraction') {
            bubble.classList.add('retraction-notice');
            bubble.title = '点击查看被撤回的内容';
        } else if (typeof contentData === 'object' && contentData.type === 'call_log') {
            bubble.classList.add('clickable-log');
            bubble.title = '点击查看通话记录';
        }
        addInteractionHandlers(bubble, message);
        container.prepend(bubble); // 【核心区别】使用 prepend
        return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper';
    wrapper.id = `message-${timestamp}`;
    const isUser = role.toLowerCase() !== 'assistant';
    const senderClass = isUser ? 'user' : 'ai';
    wrapper.classList.add(senderClass);

    const avatar = document.createElement('img');
    avatar.className = 'avatar';
    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${senderClass}`;

    if (isUser) {
        avatar.src = chat.personas.my.avatar || DEFAULT_AVATAR;
    } else {
        const persona = (chat.type === 'group' ? chat.personas.ai.find(p => p.name === authorName) : chat.personas.ai) || {};
        avatar.src = persona.avatar || DEFAULT_AVATAR;
        if (chat.type === 'group' && authorName) {
            const nameDiv = document.createElement('div'); nameDiv.className = 'sender-name'; nameDiv.textContent = authorName; bubble.appendChild(nameDiv);
        }
    }
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'content';
    
    // (此处省略了所有 contentData 的 switch-case 判断，因为它们和 appendMessage 完全相同)
    // ... 为了简洁，这里省略了和 appendMessage 中完全一样的 switch-case 逻辑 ...
    const isString = typeof contentData === 'string';
    if (isString) {
        contentDiv.innerHTML = contentData.replace(/\n/g, '<br>');
    } else if (contentData && typeof contentData === 'object') {
        switch(contentData.type) {
             case 'voice':
            case 'send_voice':
                bubble.classList.add('is-voice-message'); 
                const duration = contentData.duration || 5; 
                const durationFormatted = `${duration}"`; 
                const minWidth = 65; const maxWidth = 220; 
                let width = minWidth + (duration - 1) * 2.8; 
                width = Math.min(width, maxWidth); 
                const playIconSrc = senderClass === 'user' ? "https://i.postimg.cc/T33ZcS3N/IMG-5037.gif" : "https://i.postimg.cc/MHMVmzjb/IMG-5046.gif"; 
                contentDiv.innerHTML = `<div class="voice-message-body" style="width: ${width}px;" data-text="${contentData.text}"><img src="${playIconSrc}" class="voice-play-icon"><span class="voice-duration">${durationFormatted}</span></div>`;
                break;
            case 'location':
                contentDiv.classList.add('location-content'); 
                contentDiv.innerHTML = `<div class="location-text-overlay">${contentData.address}</div>`;
                break;
            case 'transfer':
            case 'send_transfer':
                contentDiv.classList.add('transfer-content');
                const amount = Number(contentData.amount).toFixed(2);
                let detailsHTML = '';
                let footerText = '微信转账';
                if (senderClass === 'user' && contentData.statusText === '已收款') {
                    detailsHTML = `<div class="transfer-details"><div class="transfer-amount">¥${amount}</div><div class="transfer-remark">已收款</div></div>`;
                    contentDiv.style.backgroundColor = '#fde1c3';
                } else {
                    const remarkHTML = contentData.remark ? `<div class="transfer-remark">${contentData.remark}</div>` : '';
                    detailsHTML = `<div class="transfer-details"><div class="transfer-amount">¥${amount}</div>${remarkHTML}</div>`;
                    if (contentData.isReceived) {
                        footerText = '已被收款';
                        contentDiv.style.backgroundColor = '#fde1c3';
                    } else {
                        footerText = '微信转账';
                        contentDiv.style.backgroundColor = '#F8A94A';
                    }
                }
                contentDiv.innerHTML = `<div class="transfer-top-section"><div class="transfer-icon">¥</div>${detailsHTML}</div><div class="transfer-footer">${footerText}</div>`;
                break;
            case 'just_image':
                contentDiv.className = 'content just-image-content'; 
                contentDiv.innerHTML = `<img src="${contentData.url}" alt="image-message">`;
                break;
            case 'image':
    contentDiv.className = 'content image-text-content';
    contentDiv.innerHTML = `
        <div class="image-text-cover"><img src="https://i.postimg.cc/RF2kGBvN/A0-E8-A59-DE8-E7368-B0824-AA62553191-E8.jpg" style="width: 100%; height: 100%; object-fit: cover;"></div>
        <div class="image-text-details" style="display: none;">${contentData.text.replace(/\n/g, '<br>')}</div>
    `;
    break;
        }
    }


    bubble.appendChild(contentDiv);
   
    wrapper.appendChild(avatar);
    wrapper.appendChild(bubble);
    addInteractionHandlers(wrapper, message);
    
    // --- 引用消息的处理 ---
    if (replyTo && replyTo.timestamp) {
        const quoteContainer = document.createElement('div');
        quoteContainer.className = `quote-reply-container ${senderClass}`;
        const quoteBox = document.createElement('div');
        quoteBox.className = 'quote-reply-box';
        let quoteAuthorName = '';
        if (replyTo.role === 'user') { quoteAuthorName = chat.personas.my.name; } else { const persona = (chat.type === 'group' ? chat.personas.ai.find(p => p.name === replyTo.author) : chat.personas.ai) || {}; quoteAuthorName = persona.name || 'AI'; }
        quoteBox.textContent = `${quoteAuthorName}: ${summarizeLastMessage(replyTo)}`;
        quoteContainer.appendChild(quoteBox);
        
        // 【核心区别】因为消息本身是往前插，所以引用条要插在消息后面
        wrapper.insertAdjacentElement('afterend', quoteContainer);
    }
    
    container.prepend(wrapper); // 【核心区别】使用 prepend
};

const handleAIPokeUser = async () => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return; // 安全检查

    // 1. 在界面上显示“[AI]拍了拍你”
    const pokeText = `“${chat.personas.ai.name}”拍了拍你`;
    // 使用我们现有的函数来添加系统消息，它会自动应用样式
    await appendSystemMessageToChat({ content: pokeText, type: 'poke' });

        const hiddenSystemMessage = {
        role: 'system',
        content: '[重要系统事件：用户刚刚“拍了拍”你。这是一个需要你立即回应的互动。请你放下正在做的事情，用符合你角色设定的口吻，对这个“拍一拍”动作本身做出反应。例如，你可以表现出惊讶、好奇、被打扰或开心的情绪。]',
        hidden: true, 
        timestamp: Date.now() + 1
    };
    chat.history.push(hiddenSystemMessage);

    await dbStorage.set(KEYS.CHATS, appState.chats);

};

// ▼▼▼ 请使用这个【外观修改版】来完整替换旧的 handlePokeAi 函数 ▼▼▼
const handlePokeAi = async (message) => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat || message.role !== 'assistant') return; // 安全检查

    const pokeText = `你拍了拍“${message.author || chat.personas.ai.name}”`;
    const timestamp = Date.now();

    // 1. 【核心修改】创建一个带有特殊类型 'user_poke' 的用户消息对象
    //    它的 role 依然是 'user'，这保证了逻辑的正确性。
    const userPokeMessage = {
        role: 'user',
        content: {
            type: 'user_poke',
            text: pokeText
        },
        timestamp: timestamp
    };

    // 2. 调用 appendMessage 来处理这条特殊消息
    //    我们将在下一步修改 appendMessage，让它能识别并特殊处理 'user_poke' 类型。
    appendMessage(userPokeMessage);
    chat.history.push(userPokeMessage);

    // 3. (保留) 继续在后台添加隐藏的系统指令，确保AI能准确回应
    const hiddenSystemMessage = {
        role: 'system',
        content: `[重要系统事件：用户刚刚通过“拍一拍”的动作，发送了消息：“${pokeText}”。这是一个需要你立即回应的互动。请你放下正在做的事情，用符合你角色设定的口吻，对这个动作本身做出反应。]`,
        hidden: true,
        timestamp: timestamp + 1 
    };
    chat.history.push(hiddenSystemMessage);

    // 4. 保存并触发AI回应 (不变)
    await dbStorage.set(KEYS.CHATS, appState.chats);
};

// ▼▼▼ 请使用这个【移除了“(已编辑)”角标】的函数，完整替换你代码中旧的 appendMessage 函数 ▼▼▼
const appendMessage = (message) => {
    const messagesDiv = document.getElementById('chat-messages');
    const chat = appState.chats?.[appState.activeChatId];
    if (!chat) return;

    const { role, content: contentData, timestamp, author: authorName, replyTo, edited } = message;

    // --- 处理系统消息 (system) ---
    if (role.toLowerCase() === 'system') {
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system';

        if (typeof contentData === 'object' && contentData.type === 'poke') {
            bubble.classList.add('poke-notice');
        }

        bubble.id = `message-${timestamp}`;
        const systemContent = (typeof contentData === 'object' && contentData.content) ? contentData.content : contentData;
        bubble.textContent = systemContent;

        if (typeof contentData === 'object' && contentData.type === 'retraction') {
            bubble.classList.add('retraction-notice');
            bubble.title = '点击查看被撤回的内容';
        } else if (typeof contentData === 'object' && contentData.type === 'call_log') {
            bubble.classList.add('clickable-log');
            bubble.title = '点击查看通话记录';
        }
        
        addInteractionHandlers(bubble, message);
        messagesDiv.appendChild(bubble);
        bubble.classList.add('message-appear-animation');
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        return; // 处理完系统消息后结束
    }

    // --- 处理用户和AI消息 (user & assistant) ---
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper';
    wrapper.id = `message-${timestamp}`;
    const isUser = role.toLowerCase() !== 'assistant';

    // --- 【新增】专门处理用户“拍一拍”的特殊显示逻辑 ---
    if (isUser && typeof contentData === 'object' && contentData.type === 'user_poke') {
        const pokeBubble = document.createElement('div');
        pokeBubble.className = 'message-bubble system poke-notice'; // 复用系统消息的样式
        pokeBubble.id = `message-${timestamp}`;
        pokeBubble.textContent = contentData.text;
        
        // 注意：这里我们直接将灰色小字添加到聊天区域，而不是放在wrapper里
        messagesDiv.appendChild(pokeBubble);
        pokeBubble.classList.add('message-appear-animation');
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        return; // 显示完毕，直接结束函数，不执行下面的普通气泡渲染
    }

    // --- 正常的聊天气泡渲染逻辑 ---
    const senderClass = isUser ? 'user' : 'ai';
    wrapper.classList.add(senderClass);

    const avatar = document.createElement('img');
    avatar.className = 'avatar';

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${senderClass}`;

    if (isUser) {
        avatar.src = chat.personas.my.avatar || DEFAULT_AVATAR;
    } else { // AI
        const persona = (chat.type === 'group' ? chat.personas.ai.find(p => p.name === authorName) : chat.personas.ai) || {};
        avatar.src = persona.avatar || DEFAULT_AVATAR;

        if (senderClass === 'ai') {
             avatar.addEventListener('dblclick', () => {
                handlePokeAi(message);
            });
        }
        
        if (chat.type === 'group' && authorName) {
            const nameDiv = document.createElement('div'); nameDiv.className = 'sender-name'; nameDiv.textContent = authorName; bubble.appendChild(nameDiv);
        }
    }
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'content';

    const isString = typeof contentData === 'string';
    if (isString) {
        if (senderClass === 'ai' && chat.isOfflineMode && contentData.length > 200) {
            const paragraphs = contentData.split('\n');
            paragraphs.forEach(p_text => {
                if (p_text.trim() !== '') {
                    const p_element = document.createElement('p');
                    p_element.textContent = p_text;
                    contentDiv.appendChild(p_element);
                }
            });
        } else {
            contentDiv.innerHTML = contentData.replace(/\n/g, '<br>');
        }
    } else if (contentData && typeof contentData === 'object') {
        switch(contentData.type) {
            case 'voice':
            case 'send_voice':
                bubble.classList.add('is-voice-message'); 
                const duration = contentData.duration || 5; 
                const durationFormatted = `${duration}"`; 
                const minWidth = 65; const maxWidth = 220; 
                let width = minWidth + (duration - 1) * 2.8; 
                width = Math.min(width, maxWidth); 
                const playIconSrc = senderClass === 'user' ? "https://i.postimg.cc/T33ZcS3N/IMG-5037.gif" : "https://i.postimg.cc/MHMVmzjb/IMG-5046.gif"; 
                contentDiv.innerHTML = `<div class="voice-message-body" style="width: ${width}px;" data-text="${contentData.text}"><img src="${playIconSrc}" class="voice-play-icon"><span class="voice-duration">${durationFormatted}</span></div>`;
                break;
            case 'location':
                contentDiv.classList.add('location-content'); 
                contentDiv.innerHTML = `<div class="location-text-overlay">${contentData.address}</div>`;
                break;
            case 'transfer':
            case 'send_transfer':
                contentDiv.classList.add('transfer-content');
                const amount = Number(contentData.amount).toFixed(2);
                let detailsHTML = '';
                let footerText = '微信转账';
                const remarkHTML = contentData.remark ? `<div class="transfer-remark">${contentData.remark}</div>` : '';
                detailsHTML = `<div class="transfer-details"><div class="transfer-amount">¥${amount}</div>${remarkHTML}</div>`;
                if (contentData.statusText === '已收款') {
                    detailsHTML = `<div class="transfer-details"><div class="transfer-amount">¥${amount}</div><div class="transfer-remark">已收款</div></div>`;
                    contentDiv.style.backgroundColor = '#fde1c3';
                } else {
                    if (contentData.isReceived) {
                        footerText = (senderClass === 'user') ? '对方已收款' : '已被收款';
                        contentDiv.style.backgroundColor = '#fde1c3';
                    } else {
                        footerText = '微信转账';
                        contentDiv.style.backgroundColor = '#F8A94A';
                    }
                }
                contentDiv.innerHTML = `<div class="transfer-top-section"><div class="transfer-icon">¥</div>${detailsHTML}</div><div class="transfer-footer">${footerText}</div>`;
                break;
            case 'just_image':
                contentDiv.className = 'content just-image-content'; 
                contentDiv.innerHTML = `<img src="${contentData.url}" alt="image-message">`;
                break;
            case 'image':
                contentDiv.className = 'content image-text-content';
                contentDiv.innerHTML = `
                    <div class="image-text-cover"><img src="https://i.postimg.cc/RF2kGBvN/A0-E8-A59-DE8-E7368-B0824-AA62553191-E8.jpg" style="width: 100%; height: 100%; object-fit: cover;"></div>
                    <div class="image-text-details" style="display: none;">${contentData.text.replace(/\n/g, '<br>')}</div>
                `;
                break;
        }
    }

    bubble.appendChild(contentDiv);

    // ▼▼▼ 核心修改：移除“(已编辑)”角标 ▼▼▼
    /* // 我们将这一整块 if 语句注释掉，这样它就不会被执行了
    if (edited) {
        const editedTag = document.createElement('span');
        editedTag.className = 'edited-tag';
        editedTag.textContent = '(已编辑)';
        bubble.appendChild(editedTag); 
    }
    */
    // ▲▲▲ 修改结束 ▲▲▲
    
    wrapper.appendChild(avatar);
    wrapper.appendChild(bubble);
    
    if (senderClass === 'ai' && chat.isBlocked) {
        const failedIndicator = document.createElement('div');
        failedIndicator.className = 'message-failed-indicator';
        failedIndicator.textContent = '!';
        failedIndicator.title = '消息发送失败';
        wrapper.appendChild(failedIndicator);
    }

    addInteractionHandlers(wrapper, message);
    
    messagesDiv.appendChild(wrapper);
    wrapper.classList.add('message-appear-animation');

    if (replyTo && replyTo.timestamp) {
        const quoteContainer = document.createElement('div');
        quoteContainer.className = `quote-reply-container ${senderClass}`;
        const quoteBox = document.createElement('div');
        quoteBox.className = 'quote-reply-box';
        let quoteAuthorName = '';
        if (replyTo.role === 'user') {
            quoteAuthorName = chat.personas.my.name;
        } else {
            const persona = (chat.type === 'group' ? chat.personas.ai.find(p => p.name === replyTo.author) : chat.personas.ai) || {};
            quoteAuthorName = persona.name || 'AI';
        }
        quoteBox.textContent = `${quoteAuthorName}: ${summarizeLastMessage(replyTo)}`;
        quoteContainer.appendChild(quoteBox);
        messagesDiv.appendChild(quoteContainer);
        quoteContainer.classList.add('message-appear-animation');
    }
    
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
};

    const appendSystemMessageToChat = async (textOrObject) => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;

        const timestamp = Date.now();
        const contentObject = (typeof textOrObject === 'object' && textOrObject !== null) ? textOrObject : { content: textOrObject };
        
        const historyEntry = {
            role: 'system',
            ...contentObject,
            timestamp: timestamp
        };

        appendMessage(historyEntry);
        chat.history.push(historyEntry);
        
        await dbStorage.set(KEYS.CHATS, appState.chats);
    };

    const checkAndInsertTimestamp = async () => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat || !chat.history || chat.history.length === 0) return;
        const lastMessage = chat.history[chat.history.length - 1];
        const threeMinutes = 3 * 60 * 1000;
        if (lastMessage && (Date.now() - lastMessage.timestamp > threeMinutes) && lastMessage.role !== 'system') {
            const timeString = new Date().toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit', hour12: false });
            await appendSystemMessageToChat(timeString);
        }
    };
    const summarizeLastMessage = (lastMsg) => {
        if (!lastMsg) return ' ';
        const content = lastMsg.content;
        if (typeof content === 'string') return content;
        if (typeof content === 'object' && content !== null) {
            switch (content.type) {
                case 'user_poke': return content.text; // 【新增这一行】
                case 'voice': case 'send_voice': return '[语音讯息]';
                case 'image': return '[图片]';
                case 'vision': return content.text ? `[图片] ${content.text}` : '[图片]';
                case 'send_image_url': return content.caption || '[图片]';
                case 'location': return `[位置] ${content.address}`;
                case 'transfer': case 'send_transfer': return '[转帐]';
                case 'moment_post': return `[朋友圈] ${content.text}`;
                case 'call_log': return content.content;
                case 'retraction': return content.content;
                default:
                    if (lastMsg.role === 'system' && content.content) return content.content;
                    return '[訊息]';
            }
        }
        return ' ';
    };

// ▼▼▼ 使用这个【最终解决版】，完整替换旧的 showContextMenu 函数 ▼▼▼
const showContextMenu = (message, element) => {
    const menu = document.getElementById('message-context-menu');
    appState.activeContextMenu = { message, element };

    // --- 【核心修正】为每个按钮的点击事件添加 event.stopPropagation() ---
    
    document.getElementById('context-menu-view').onclick = (event) => { 
        event.stopPropagation(); // 阻止事件继续传播
        handleViewAction(message); 
        hideContextMenu(); 
    };
    document.getElementById('context-menu-quote').onclick = (event) => { 
        event.stopPropagation(); // 阻止事件继续传播
        startReplying(message); 
        hideContextMenu(); 
    };
    document.getElementById('context-menu-copy').onclick = (event) => { 
        event.stopPropagation(); // 阻止事件继续传播
        copyMessageContent(message); 
        hideContextMenu(); 
    };
    document.getElementById('context-menu-delete').onclick = (event) => { 
        event.stopPropagation(); // 阻止事件继续传播
        deleteMessage(message.timestamp); 
        hideContextMenu(); 
    };
    
    const editBtn = document.getElementById('context-menu-edit');
    const regenerateBtn = document.getElementById('context-menu-regenerate');

// 1. 设置“编辑”按钮
if (typeof message.content === 'string') {
    editBtn.style.display = 'block';
    editBtn.onclick = (event) => {
        event.stopPropagation(); // 阻止事件继续传播
        startInlineEdit(message, element); // <--- 修改这里，调用我们的新函数
        hideContextMenu(); 
    };

    } else {
        editBtn.style.display = 'none';
        editBtn.onclick = null;
    }

    // 2. 设置“重置”按钮
    if (message.role === 'assistant') {
        regenerateBtn.style.display = 'block';
        regenerateBtn.onclick = (event) => {
            event.stopPropagation(); // 阻止事件继续传播
            handleRegenerateAction(message); 
            hideContextMenu(); 
        };
    } else {
        regenerateBtn.style.display = 'none';
        regenerateBtn.onclick = null;
    }

    // --- 定位菜单的逻辑（不变） ---
    const rect = element.getBoundingClientRect();
    const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();
    let top = rect.top - phoneScreenRect.top - menu.offsetHeight - 10;
    let left = rect.left - phoneScreenRect.left;
    if (top < 10) { top = rect.bottom - phoneScreenRect.top + 10; }
    if (left + menu.offsetWidth > phoneScreenRect.width - 10) { left = rect.right - phoneScreenRect.left - menu.offsetWidth; }
    if (left < 10) { left = 10; }
    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;
    menu.classList.add('visible');
};
// ▲▲▲ 替换到此结束 ▲▲▲

const hideContextMenu = () => {
    const menu = document.getElementById('message-context-menu');
    if (menu) menu.classList.remove('visible');
    appState.activeContextMenu = null;
};

const copyMessageContent = (message) => {
    let contentToCopy = '';
    if (typeof message.content === 'string') {
        contentToCopy = message.content;
    } else if (typeof message.content === 'object' && message.content !== null) {
        contentToCopy = message.content.text || `[${message.content.type || '特殊消息'}]`;
    }
    
    if (navigator.clipboard) {
        navigator.clipboard.writeText(contentToCopy).then(() => {
            // 可以选择性地显示一个“已复制”的提示
        }).catch(err => console.error('复制失败', err));
    }
};

const startReplying = (message) => {
    appState.replyingToMessage = message;
    const previewBar = document.getElementById('reply-preview-bar');
    const previewContainer = document.getElementById('reply-preview-container');
    const authorSpan = previewBar.querySelector('.reply-to-author');
    const textSpan = previewBar.querySelector('.reply-to-text');

    // 查找发言人名称
    let authorName = '';
    const chat = appState.chats[appState.activeChatId];
    if (message.role === 'user') {
        authorName = chat.personas.my.name;
    } else { // assistant
        const persona = chat.type === 'group' 
            ? chat.personas.ai.find(p => p.name === message.author) 
            : chat.personas.ai;
        authorName = persona?.name || 'AI';
    }

    authorSpan.textContent = `回复 ${authorName}:`;
    textSpan.textContent = summarizeLastMessage(message);

    // 将预览条添加到容器并显示
    previewContainer.appendChild(previewBar);
    previewBar.style.display = 'flex';
    document.getElementById('chat-input').focus();
};

const cancelReplying = () => {
    appState.replyingToMessage = null;
    const previewBar = document.getElementById('reply-preview-bar');
    if (previewBar) {
        previewBar.style.display = 'none';
    }
};

const renderChatList = () => {
    const container = document.getElementById('chat-list-container');
    container.innerHTML = '';
    const isEditMode = appState.editMode.chat;
    const chatIds = Object.keys(appState.chats);
    const editBtn = document.getElementById('main-hub-edit-btn');

    if (chatIds.length === 0) {
        if(editBtn) editBtn.style.display = 'none';
        container.innerHTML = `<p style="text-align:center; color:#8a8a8a; margin-top: 40px;">點擊右上角“+”來創建第一個對話吧！</p>`;
        return;
    }
    if(editBtn) editBtn.style.display = 'block';

    chatIds.sort((a, b) => {
        const chatA = appState.chats[a];
        const chatB = appState.chats[b];
        if (chatA.pinned && !chatB.pinned) return -1;
        if (!chatA.pinned && chatB.pinned) return 1;
        const timeA = chatA.history.slice(-1)[0]?.timestamp || 0;
        const timeB = chatB.history.slice(-1)[0]?.timestamp || 0;
        return timeB - timeA;
    });

    chatIds.forEach(chatId => {
        const chatData = appState.chats[chatId];
        const item = document.createElement('div');
        item.className = 'list-item';

        if (chatData.pinned) {
            item.style.backgroundColor = 'var(--body-bg)';
        }
        if (isEditMode) item.classList.add('edit-mode');

        const content = document.createElement('div');
        content.className = 'list-item-content';
        content.addEventListener('click', () => { if (!isEditMode) openChat(chatId); });

        // ▼▼▼ 核心修改开始 ▼▼▼
        let avatarElement;

        if (chatData.type === 'group') {
            // 如果是群聊，创建一个九宫格容器
            avatarElement = document.createElement('div');
            avatarElement.className = 'group-avatar-container'; // 使用我们新增的CSS class

            // 最多只取前9个AI成员的头像
            const membersToDisplay = chatData.personas.ai.slice(0, 9);

            membersToDisplay.forEach(member => {
                const memberAvatar = document.createElement('img');
                memberAvatar.className = 'member-avatar'; // 使用我们新增的CSS class
                memberAvatar.src = member.avatar || DEFAULT_AVATAR;
                avatarElement.appendChild(memberAvatar);
            });
        } else {
            // 如果是单人聊天，保持原来的逻辑
            avatarElement = document.createElement('img');
            avatarElement.className = 'list-item-avatar';
            const aiPersona = Array.isArray(chatData.personas.ai) ? chatData.personas.ai[0] : chatData.personas.ai;
            avatarElement.src = aiPersona?.avatar || DEFAULT_AVATAR;
        }
        // ▲▲▲ 核心修改结束 ▲▲▲

        const info = document.createElement('div');
        info.className = 'list-item-info';

        const name = document.createElement('span');
        name.className = 'list-item-name';
        name.textContent = chatData.name;

        const lastMessage = document.createElement('span');
        lastMessage.className = 'list-item-last-message';
        const lastMessageObj = chatData.history.slice(-1)[0];
        lastMessage.textContent = summarizeLastMessage(lastMessageObj);

        info.appendChild(name);
        info.appendChild(lastMessage);
        
        // ▼▼▼ 将修改后的 avatarElement 添加到内容中 ▼▼▼
        content.appendChild(avatarElement); 
        content.appendChild(info);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-button';
        deleteBtn.textContent = '－';
        deleteBtn.addEventListener('click', async (e) => { e.stopPropagation(); await deleteChat(chatId, item); });

        item.appendChild(deleteBtn);
        item.appendChild(content);
        container.appendChild(item);
    });
};

    const renderPersonaList = (type) => {
        const container = document.getElementById(`${type}-persona-list-container`);
        const editBtn = document.getElementById(`${type}-persona-edit-btn`);
        const isEditMode = appState.editMode[`${type}_persona`];
        container.innerHTML = '';
        const presets = appState.personas[type];
        if (presets.length === 0) {
            if (editBtn) editBtn.style.display = 'none';
            container.innerHTML = `<p style="text-align:center; color:#8a8a8a; margin-top: 40px;">點擊右上角“+”來創建第一個預設吧！</p>`;
            return;
        }
        if(editBtn) editBtn.style.display = 'block';
        presets.forEach((preset, index) => {
            const item = document.createElement('div');
            item.className = 'list-item';
            if (isEditMode) item.classList.add('edit-mode');
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-button';
            deleteBtn.textContent = '－';
            deleteBtn.addEventListener('click', async (e) => { e.stopPropagation(); await deletePersonaPreset(type, index, item); });
            const content = document.createElement('div');
            content.className = 'list-item-content';

            // --- 修正部分開始 ---
            const avatar = document.createElement('img');
            avatar.className = 'list-item-avatar';
            avatar.src = preset.avatar || DEFAULT_AVATAR; // 修正：使用正確的 preset 物件

            const name = document.createElement('span');
            name.className = 'list-item-name';
            name.textContent = preset.name; // 修正：使用正確的 preset 物件
            
            content.appendChild(avatar);
            content.appendChild(name);
            // --- 修正部分結束 ---

            content.addEventListener('click', () => { if (!isEditMode) openPersonaEditor(type, index); });
            item.appendChild(deleteBtn);
            item.appendChild(content);
            container.appendChild(item);
        });
    };

// --- 新增：从通讯录发起或打开聊天的功能 ---
const startChatFromContacts = async (contact) => {
    // 1. 检查一个与该AI的1对1聊天是否已经存在
    let existingChatId = null;
    for (const chatId in appState.chats) {
        const chat = appState.chats[chatId];
        // 查找条件：必须是单人聊天，且AI角色的名字要匹配
        if (chat.type === 'single' && chat.personas.ai.name === contact.name) {
            existingChatId = chatId;
            break;
        }
    }


    if (existingChatId) {
        console.log(`找到与 ${contact.name} 的现有聊天，正在打开...`);
        openChat(existingChatId);
    } else {
     
        console.log(`未找到与 ${contact.name} 的聊天。正在创建新聊天...`);
        const myPersona = appState.personas.my[0]; // 获取用户的默认角色
        if (!myPersona) {
            alert('错误：请先在“我的素材库”中创建您自己的角色！');
            return;
        }

        const newChatId = 'chat_' + Date.now();
        appState.chats[newChatId] = {
            name: contact.name,
            type: 'single',
            history: [],
            pinned: true, // 关键：新建的聊天自动置顶
            personas: {
                ai: contact,
                my: myPersona
            },
            wallpaper: null,
            memoryRounds: 0,
            isOfflineMode: false
        };
        await dbStorage.set(KEYS.CHATS, appState.chats);
        openChat(newChatId); // 打开新建的聊天
    }

    switchTab('chat');
};

const renderContactsList = () => {
    const container = document.getElementById('contacts-list-container');
    container.innerHTML = '';

   
    const publicAccountListItem = document.createElement('div');
    publicAccountListItem.className = 'list-item';
    publicAccountListItem.style.cursor = 'pointer';

   
    const publicAccountContact = {
        name: '公众号',
       
        avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0iIzQ2ODJlZiIvPjwvc3ZnPg==',
        content: '这是一个官方公众号。' 
    };

publicAccountListItem.onclick = () => {
    appState.hasNewPublicPosts = false; 
  
    renderPublicAccountFeed(); 
    showScreen('public-account-screen');
};

   
    const content = document.createElement('div');
    content.className = 'list-item-content';
    content.style.justifyContent = 'flex-start';
    content.style.gap = '15px';
    const avatar = document.createElement('img');
    avatar.src = publicAccountContact.avatar; 
    avatar.style.width = '40px';
    avatar.style.height = '40px';
    avatar.style.borderRadius = '5px';
    const name = document.createElement('span');
    name.className = 'list-item-name';
    name.textContent = publicAccountContact.name; 
    content.appendChild(avatar);
    content.appendChild(name);
    if (appState.hasNewPublicPosts) {
    const redDot = document.createElement('span');
    redDot.style.cssText = `
        width: 8px; 
        height: 8px; 
        background-color: #ff3b30; 
        border-radius: 50%;
        position: absolute;
        right: 15px; /* 调整红点位置 */
        top: 15px;  /* 调整红点位置 */
    `;
    content.appendChild(redDot); // 把红点加到内容里
}

// ...后面拼接头像和名字的代码...
publicAccountListItem.append(content);

    // 5. 将创建好的公众号列表项添加到通讯录容器的顶部
    container.appendChild(publicAccountListItem);

    // ▲▲▲ 新增代码结束 ▲▲▲

    // --- 以下是原有的、渲染普通联系人的逻辑，保持不变 ---
    const contacts = appState.contacts;
    if (contacts.length === 0 && !container.hasChildNodes()) { // 修正判断条件，如果已有公众号则不显示此消息
        container.innerHTML = `<p style="text-align:center; color:#8a8a8a; margin-top: 40px;">点击右上角“+”号并选择“添加联系人”</p>`;
        return;
    }
    contacts.forEach((contact) => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.style.cursor = 'pointer';
        item.onclick = () => startChatFromContacts(contact);

        const content = document.createElement('div');
        content.className = 'list-item-content';
        content.style.justifyContent = 'flex-start';
        content.style.gap = '15px';
        const avatar = document.createElement('img');
        avatar.src = contact.avatar || DEFAULT_AVATAR;
        avatar.style.width = '40px';
        avatar.style.height = '40px';
        avatar.style.borderRadius = '5px';
        const name = document.createElement('span');
        name.className = 'list-item-name';
        name.textContent = contact.name;
        content.appendChild(avatar);
        content.appendChild(name);
        item.append(content);
        container.appendChild(item);
    });
};

    const deleteChat = async (chatId, itemElement) => {
        const chatName = appState.chats[chatId]?.name;
        if (!chatName) return;
        showCustomConfirm('删除对话', `您确定要删除对话 <b>"${chatName}"</b> 吗?<br>此操作无法复原。`, async () => {
            delete appState.chats[chatId];
            if (appState.activeChatId === chatId) appState.activeChatId = null;
            await dbStorage.set(KEYS.CHATS, appState.chats);
            animateAndRemoveItem(itemElement, () => renderChatList());
        });
    };

// 【新增】拉黑联系人的核心功能
const blockContact = async (chatId) => {
    const chat = appState.chats[chatId];
    if (!chat || chat.type !== 'single') {
        alert('错误：只能拉黑单人对话的联系人。');
        return;
    }

    const contactName = chat.personas.ai.name;

    // 1. 弹出确认框
    showCustomConfirm(
        '拉黑联系人',
        `您确定要拉黑 <b>"${contactName}"</b> 吗？<br><br>拉黑后，对方将无法正常与您通讯。`,
        async () => {
            // 2. 标记该聊天为“已拉黑”
            chat.isBlocked = true;

            // 3. 在AI的人设中追加一条规则，让它知道自己被拉黑了
            const blockInstruction = "\n\n[重要系统指令：你已被对方拉黑。你发送的所有消息都将失败。请在回复中体现出消息发送失败后的困惑、尝试或无奈。]";
            chat.personas.ai.content += blockInstruction;

            // 4. 在聊天记录中添加一条隐藏的系统消息，作为触发AI回应的上下文
            const hiddenSystemMessage = {
                role: 'system',
                content: '[系统事件：对方已将你拉黑。]',
                hidden: true,
                timestamp: Date.now()
            };
            chat.history.push(hiddenSystemMessage);

            // 5. 保存所有更改到数据库
            await dbStorage.set(KEYS.CHATS, appState.chats);
            console.log(`联系人 "${contactName}" 已被拉黑。`);

            // 6. 切换回聊天界面并触发AI的回应
            showScreen('chat-screen');
            await receiveMessageHandler();
        }
    );
};

// 【新增】解除拉黑的核心功能
const unblockContact = async (chatId) => {
    const chat = appState.chats[chatId];
    if (!chat) return;

    // 1. 移除 isBlocked 标记
    delete chat.isBlocked;

    // 2. 从 AI 的核心设定中，移除那条关于被拉黑的指令
    //    【重要】这里的字符串必须和 blockContact 函数里添加的完全一致才能被替换掉
    const blockInstruction = "\n\n[重要系统指令：你已被对方拉黑。你发送的所有消息都将失败。请在回复中体现出消息发送失败后的困惑、尝试或无奈。]";
    chat.personas.ai.content = chat.personas.ai.content.replace(blockInstruction, ""); // 替换为空字符串，即删除

    // 3. 在聊天记录中添加一条隐藏的系统消息，通知 AI
    const hiddenSystemMessage = {
        role: 'system',
        content: '[系统事件：对方已将你解除拉黑。]',
        hidden: true,
        timestamp: Date.now()
    };
    chat.history.push(hiddenSystemMessage);

    // 4. 保存更改到数据库
    await dbStorage.set(KEYS.CHATS, appState.chats);
    console.log(`联系人 "${chat.personas.ai.name}" 已被解除拉黑。`);

    // 5. 提示用户并返回聊天界面，然后触发 AI 的回应
    alert('解除拉黑成功！');
    showScreen('chat-screen');
    await receiveMessageHandler();
};

const deleteContact = async (chatId) => {
    const chat = appState.chats[chatId];
    if (!chat || chat.type !== 'single') {
        alert('错误：只能删除单人对话的联系人。');
        return;
    }

    const contactName = chat.personas.ai.name;

    showCustomConfirm(
        '删除联系人',
        `您确定要删除联系人 <b>"${contactName}"</b> 吗？<br><br>此操作将：<br>1. 删除这个对话框。<br>2. 从您的通讯录中移除此人。<br><br><b>此操作无法复原。</b>`,
        async () => {
            // 1. 从通讯录列表中删除
            appState.contacts = appState.contacts.filter(contact => contact.name !== contactName);
            await dbStorage.set(KEYS.CONTACTS, appState.contacts);
            console.log(`联系人 "${contactName}" 已从通讯录删除。`);

            // 2. 从对话列表中删除
            delete appState.chats[chatId];
            if (appState.activeChatId === chatId) {
                appState.activeChatId = null;
            }
            await dbStorage.set(KEYS.CHATS, appState.chats);
            console.log(`与 "${contactName}" 的对话已删除。`);

            // 3. 操作完成后，返回到主界面并切换到通讯录标签页
            alert(`联系人 "${contactName}" 已被彻底删除。`);
            switchTab('contacts'); // 切换到通讯录，让用户看到变化
            showScreen('main-hub-screen');
        }
    );
};

    const deletePersonaPreset = async (type, index, itemElement) => {
        const presetName = appState.personas[type][index]?.name;
        if (!presetName) return;
        showCustomConfirm('删除预设', `您确定要删除预设 <b>"${presetName}"</b> 吗?`, async () => {
            appState.personas[type].splice(index, 1);
            const key = type === 'ai' ? KEYS.PERSONA_AI : KEYS.PERSONA_MY;
            await dbStorage.set(key, appState.personas[type]);
            animateAndRemoveItem(itemElement, () => renderPersonaList(type));
        });
    };
    

// ▼▼▼ 从这里开始，是新增的提示词功能JS逻辑 ▼▼▼

// 渲染提示词列表
const renderPromptList = () => {
    const container = document.getElementById('prompt-list-container');
    container.innerHTML = '';
    const isEditMode = appState.editMode.prompt; // 我们将使用一个新的编辑模式状态
    const editBtn = document.getElementById('prompt-edit-btn');

    if (appState.prompts.length === 0) {
        if(editBtn) editBtn.style.display = 'none';
        container.innerHTML = `<p style="text-align:center; color:#8a8a8a; margin-top: 40px;">点击右上角“+”来创建第一个提示词吧！</p>`;
        return;
    }
    if(editBtn) editBtn.style.display = 'block';

    appState.prompts.forEach((prompt, index) => {
        const item = document.createElement('div');
        item.className = 'list-item';
        if (isEditMode) item.classList.add('edit-mode');

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-button';
        deleteBtn.textContent = '－';
        deleteBtn.onclick = (e) => { e.stopPropagation(); deletePrompt(index, item); };

        const content = document.createElement('div');
        content.className = 'list-item-content';
        // 提示词没有头像，所以我们只显示标题和内容预览
        content.innerHTML = `
            <div class="list-item-info">
                <span class="list-item-name">${prompt.title}</span>
                <span class="list-item-last-message">${prompt.content.substring(0, 30)}...</span>
            </div>
        `;
        content.onclick = () => { if (!isEditMode) openPromptEditor(index); };
        
        item.appendChild(deleteBtn);
        item.appendChild(content);
        container.appendChild(item);
    });
};

// 打开提示词编辑器 (新增或编辑)
const openPromptEditor = (index = -1) => {
    appState.editingPromptIndex = index;
    const titleInput = document.getElementById('prompt-title-input');
    const contentInput = document.getElementById('prompt-content-input');
    const title = document.getElementById('prompt-editor-title');

    if (index === -1) { // 新增
        title.textContent = '新增提示词';
        titleInput.value = '';
        contentInput.value = '';
    } else { // 编辑
        const prompt = appState.prompts[index];
        title.textContent = '编辑提示词';
        titleInput.value = prompt.title;
        contentInput.value = prompt.content;
    }
    showScreen('prompt-editor-screen');
};

// 删除提示词
const deletePrompt = async (index, itemElement) => {
    const promptTitle = appState.prompts[index]?.title;
    if (!promptTitle) return;
    showCustomConfirm('删除提示词', `您确定要删除提示词 <b>"${promptTitle}"</b> 吗?`, async () => {
        appState.prompts.splice(index, 1);
        await dbStorage.set(KEYS.PROMPTS, appState.prompts);
        animateAndRemoveItem(itemElement, renderPromptList);
    });
};

// ▲▲▲ 新增JS逻辑结束 ▲▲▲

const openPromptSelectionModal = () => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const modalTitle = document.getElementById('persona-selection-modal-title');
    const modalList = document.getElementById('modal-persona-list');
    
    modalTitle.textContent = '选择提示词';
    modalList.innerHTML = '';

    const selectedIds = new Set(chat.promptIds || []);

    appState.prompts.forEach((prompt) => {
        const item = document.createElement('div');
        item.className = 'persona-checkbox-item';
        
        const isChecked = selectedIds.has(prompt.id);

        item.innerHTML = `
            <input type="checkbox" id="prompt-checkbox-${prompt.id}" value="${prompt.id}" ${isChecked ? 'checked' : ''}>
            <div class="list-item-info" style="cursor: pointer;">
                <label for="prompt-checkbox-${prompt.id}" class="list-item-name" style="cursor: pointer;">${prompt.title}</label>
                <label for="prompt-checkbox-${prompt.id}" class="list-item-last-message" style="cursor: pointer; white-space: normal;">${prompt.content.substring(0, 40)}...</label>
            </div>
        `;
        modalList.appendChild(item);
    });

    // 绑定事件
    document.getElementById('save-selection-btn').onclick = savePromptSelection; // 注意这里没有 ()
    document.getElementById('cancel-selection-btn').onclick = closePersonaSelectionModal;

    document.getElementById('persona-selection-modal').classList.add('active');
};


const selectPrompt = (prompt) => {
    const chat = appState.chats[appState.activeChatId];
    const selectionText = document.getElementById('chat-prompt-selection-text');
    if (prompt) {
        chat.promptId = prompt.id;
        selectionText.textContent = prompt.title;
        selectionText.classList.remove('placeholder');
    } else {
        delete chat.promptId; // 清除自定义提示词ID
        selectionText.textContent = '默认 (基于AI人设)';
        selectionText.classList.add('placeholder');
    }
    closePersonaSelectionModal(); // 复用关闭模态框的函数
};

const openCreateGroupChatScreen = () => {
    // 清空旧的输入和选择
    document.getElementById('group-chat-name-input').value = '';
    const myPersonaText = document.getElementById('group-my-persona-selection-text');
    myPersonaText.textContent = '从我的素材库选择';
    myPersonaText.classList.add('placeholder');
    appState.newChatTempPersonas = { ai: null, my: null };

    // 动态生成 AI 成员选择列表
    const container = document.getElementById('group-ai-persona-list-container');
    container.innerHTML = '';
    appState.personas.ai.forEach(persona => {
        const item = document.createElement('div');
        item.className = 'persona-checkbox-item';
        item.innerHTML = `
            <input type="checkbox" id="persona-checkbox-${persona.name}" value="${persona.name}">
            <img src="${persona.avatar || DEFAULT_AVATAR}" class="list-item-avatar">
            <label for="persona-checkbox-${persona.name}" class="list-item-name">${persona.name}</label>
        `;
        container.appendChild(item);
    });
    
    showScreen('create-group-chat-screen');
};

// ▼▼▼ 使用这个【懒加载版】完整替换旧的 openChat 函数 ▼▼▼

// 在 appState 外部或顶部定义一个常量
const MESSAGES_PER_PAGE = 60; 
const MOMENTS_PER_PAGE = 10; // <-- 这是您需要新增的那一行

const openChat = (chatId) => {
    if (appState.editMode.chat) return;
    const chat = appState.chats[chatId];
    if (!chat) { showScreen('main-hub-screen'); return; }

    appState.activeChatId = chatId;
    document.getElementById('chat-title').textContent = chat.name;
    
    const messagesDiv = document.getElementById('chat-messages');
    messagesDiv.innerHTML = ''; 

    cancelReplying();
    closePanel();

    updateChatScreenVisuals(chat.isOfflineMode);

    let lastStatus = null;
    if (chat.history) {
        for (let i = chat.history.length - 1; i >= 0; i--) {
            const msg = chat.history[i];
            if (msg.role === 'system' && msg.content?.type === 'status_update') {
                lastStatus = msg.content.status; break;
            }
        }
    }
    updateStatusBubble(lastStatus); 

    messagesDiv.style.backgroundImage = chat.wallpaper ? `url(${chat.wallpaper})` : 'none';

    // 【核心改造】
    if (chat.history && chat.history.length > 0) {
        // 1. 计算要显示的最近消息的起始索引
        const totalMessages = chat.history.length;
        const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE);
        // 在 appState 中记录我们这次加载到了哪里，方便下次继续
        appState.currentChatRenderIndex = startIndex; 

        // 2. 如果还有更早的消息未加载，就在顶部显示“加载更多”按钮
        if (startIndex > 0) {
            const loadMoreBtn = document.createElement('div');
            loadMoreBtn.textContent = '加载更早的消息';
            loadMoreBtn.style.cssText = `
                text-align: center; 
                padding: 10px; 
                color: var(--system-message-color); 
                font-size: 13px; 
                cursor: pointer;
                background-color: #e8e8e8;
                border-radius: 8px;
                margin: 5px auto 15px auto;
                width: fit-content;
            `;
            loadMoreBtn.id = 'load-more-btn';
            loadMoreBtn.onclick = loadMoreMessages; // 点击时调用我们下一步要创建的函数
            messagesDiv.appendChild(loadMoreBtn);
        }

        // 3. 只渲染最近的一批消息
        const messagesToRender = chat.history.slice(startIndex);
        messagesToRender.forEach(msg => {
            if (!msg.hidden) { 
                appendMessage(msg); 
            }
        });

        // 4. 滚动到底部
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    showScreen('chat-screen');
};
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 使用这个【最终修正版】，完整替换旧的 loadMoreMessages 函数 ▼▼▼
const loadMoreMessages = async () => {
    const chat = appState.chats[appState.activeChatId];
    const messagesDiv = document.getElementById('chat-messages');
    let loadMoreBtn = document.getElementById('load-more-btn'); // 获取当前的按钮

    if (!chat || appState.currentChatRenderIndex <= 0) {
        if (loadMoreBtn) loadMoreBtn.remove();
        return;
    }

    // 【核心修正 1】: 在加载新消息前，先将旧的按钮从 DOM 中移除
    if (loadMoreBtn) {
        loadMoreBtn.remove();
    }

    // (这部分逻辑不变) 保存当前的滚动条高度，以防止页面跳动
    const oldScrollHeight = messagesDiv.scrollHeight;

    // (这部分逻辑不变) 计算要加载的消息范围
    const endIndex = appState.currentChatRenderIndex;
    const startIndex = Math.max(0, endIndex - MESSAGES_PER_PAGE);
    const messagesToPrepend = chat.history.slice(startIndex, endIndex);

    // (这部分逻辑不变) 倒序循环，将旧消息一条条插入到顶部
    for (let i = messagesToPrepend.length - 1; i >= 0; i--) {
        const msg = messagesToPrepend[i];
        if (!msg.hidden) {
            prependMessage(msg, messagesDiv);
        }
    }

    // (这部分逻辑不变) 恢复滚动条位置
    const newScrollHeight = messagesDiv.scrollHeight;
    messagesDiv.scrollTop = newScrollHeight - oldScrollHeight;

    // (这部分逻辑不变) 更新下一次加载的起始点
    appState.currentChatRenderIndex = startIndex;

    // 【核心修正 2】: 如果检查后发现还有更早的消息，就重新创建一个新的按钮并插入到最顶部
    if (startIndex > 0) {
        const newLoadMoreBtn = document.createElement('div');
        newLoadMoreBtn.textContent = '加载更早的消息';
        // (按钮的样式和 ID 保持不变)
        newLoadMoreBtn.style.cssText = `
            text-align: center; 
            padding: 10px; 
            color: var(--system-message-color); 
            font-size: 13px; 
            cursor: pointer;
            background-color: #e8e8e8;
            border-radius: 8px;
            margin: 5px auto 15px auto;
            width: fit-content;
        `;
        newLoadMoreBtn.id = 'load-more-btn';
        newLoadMoreBtn.onclick = loadMoreMessages; // 为新按钮绑定点击事件
        
        messagesDiv.prepend(newLoadMoreBtn); // 将新按钮插入到所有消息的最前面
    }
};
// ▲▲▲ 替换到此结束 ▲▲▲

const showPersonaList = (type) => { 
    appState.currentPersonaType = type; 
    renderPersonaList(type); 
    showScreen(`${type}-persona-list-screen`); 
};

    
    const openPersonaEditor = (type, index = -1) => {
    if (appState.editMode[`${type}_persona`]) return;
    appState.currentPersonaType = type; 
    appState.editingPresetIndex = index;
    const nameInput = document.getElementById('preset-name-input');
    const avatarPreview = document.getElementById('preset-avatar-preview');
    const contentInput = document.getElementById('preset-content-input');
    const title = document.getElementById('persona-editor-title');
    
    // ▼▼▼ 新增逻辑 ▼▼▼
    const startChatBtn = document.getElementById('start-chat-from-editor-btn');
    // 只在编辑一个已存在的“AI人设”时，才显示“开始聊天”按钮
    if (type === 'ai' && index > -1) {
        startChatBtn.style.display = 'block';
    } else {
        startChatBtn.style.display = 'none';
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    if (index === -1) { 
        title.textContent = '新增預設'; 
        nameInput.value = ''; 
        avatarPreview.src = DEFAULT_AVATAR; 
        contentInput.value = ''; 
    } else { 
        const preset = appState.personas[type][index]; 
        title.textContent = '編輯預設'; 
        nameInput.value = preset.name; 
        avatarPreview.src = preset.avatar || DEFAULT_AVATAR; 
        contentInput.value = preset.content; 
    }
    showScreen('persona-editor-screen');
};

    const openPersonaSelectionModal = (context) => {
    appState.personaSelectionContext = context;
    let presets = [];
    const modalList = document.getElementById('modal-persona-list');
    modalList.innerHTML = '';

    if (context === 'add_contact') {
        presets = appState.personas.ai.filter(p =>
            !appState.contacts.some(c => c.name === p.name)
        );
    } else {
        const type = context.includes('ai') ? 'ai' : 'my';
        presets = appState.personas[type];
    }

    if (presets.length === 0) {
        const message = context === 'add_contact'
            ? '所有 AI 人设都已是您的联系人。'
            : '没有可選的預設。';
        modalList.innerHTML = `<p style="text-align:center; color:#8a8a8a; padding: 20px;">${message}</p>`;
    } else {
        presets.forEach((preset) => {
            const item = document.createElement('div');
            item.className = 'list-item-content';
            item.style.cursor = 'pointer';
            item.style.padding = '8px 0'; // 增加一點垂直内邊距

item.style.backgroundImage = `url('${preset.avatar || DEFAULT_AVATAR}')`;
item.innerHTML = `<span class="list-item-name">${preset.name}</span>`;
// ▲▲▲ 修改结束 ▲▲▲

            item.onclick = () => selectPersona(preset);
            modalList.appendChild(item);
        });
    }
    document.getElementById('persona-selection-modal').classList.add('active');
};

    const closePersonaSelectionModal = () => document.getElementById('persona-selection-modal').classList.remove('active');

const addContactAndCreateChat = async (persona) => {
    // 1. 检查是否已经是联系人 (双重保险)
    if (appState.contacts.some(c => c.name === persona.name)) {
        alert('该联系人已存在！');
        return;
    }

    // 2. 添加到联系人列表
    appState.contacts.push(persona);
    await dbStorage.set(KEYS.CONTACTS, appState.contacts);
    console.log(`联系人 ${persona.name} 已添加。`);

    // 3. 自动创建与该联系人的1对1聊天
    const myPersona = appState.personas.my[0];
    if (!myPersona) {
        alert('错误：请先在“我的素材库”中创建您自己的角色！');
        // 回滚操作
        appState.contacts = appState.contacts.filter(c => c.name !== persona.name);
        await dbStorage.set(KEYS.CONTACTS, appState.contacts);
        return;
    }

    const newChatId = 'chat_' + Date.now();
    appState.chats[newChatId] = {
        name: persona.name,
    type: 'single',
    history: [],
    pinned: true, // <--- 新增这一行，给新聊天打上置顶标记
    personas: {
            ai: persona, // AI方是这个新联系人
            my: myPersona // “我”是默认的第一个人设
        },
        wallpaper: null,
        memoryRounds: 0,
        isOfflineMode: false
    };
    await dbStorage.set(KEYS.CHATS, appState.chats);
    console.log(`与 ${persona.name} 的新聊天已创建。`);

    // 4. 打开新创建的聊天窗口
    openChat(newChatId);
};

    const selectPersona = (preset) => {
    const context = appState.personaSelectionContext;

    if (context === 'add_contact') {
        addContactAndCreateChat(preset); // <--- 调用我们新增的核心函数
        closePersonaSelectionModal();
        return;
    }

    // --- 以下是旧的逻辑，保持不变 ---
    const personaType = context.includes('ai') ? 'ai' : 'my';
    let targetElementId;

    if (context === 'group_my') {
        appState.newChatTempPersonas.my = preset;
        targetElementId = 'group-my-persona-selection-text';
    } else if (context.includes('new')) {
        appState.newChatTempPersonas[personaType] = preset;
        targetElementId = `new-chat-${personaType}-selection-text`;
    } else {
        appState.chats[appState.activeChatId].personas[personaType] = preset;
        targetElementId = `chat-${personaType}-selection-text`;
    }

    const targetElement = document.getElementById(targetElementId);
    if (targetElement) {
        targetElement.textContent = preset.name;
        targetElement.classList.remove('placeholder');
    }
    closePersonaSelectionModal();
};
    

// ▼▼▼ 【V2 - 升级版】替换旧的 openChatSettings 函数 ▼▼▼
const openChatSettings = () => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) {
        alert("错误：找不到当前的对话资料。");
        return;
    }

    document.getElementById('settings-main-avatar').src = chat.personas?.ai?.avatar || DEFAULT_AVATAR;
    document.getElementById('settings-main-name').textContent = chat.name || '对话设定';
    document.getElementById('chat-ai-persona-selection-text').textContent = chat.personas?.ai?.name || '未设定AI角色';
    document.getElementById('chat-my-persona-selection-text').textContent = chat.personas?.my?.name || '未设定我的角色';

    // ▼▼▼ 【核心修改】调用新的辅助函数来显示多选状态 ▼▼▼
    updatePromptSelectionDisplay(chat);
    // ▲▲▲ 修改结束 ▲▲▲

    document.getElementById('chat-name-input').value = chat.name || '';
    document.getElementById('chat-wallpaper-status').textContent = chat.wallpaper ? '已设置' : '未设置';
    document.getElementById('chat-memory-rounds-input').value = chat.memoryRounds || 0;

    const timeToggle = document.getElementById('time-awareness-toggle');
    if (timeToggle) {
        timeToggle.classList.toggle('active', !!chat.timeAwareness);
    }
    
    const offlineToggle = document.getElementById('offline-mode-toggle');
    if (offlineToggle) {
        offlineToggle.classList.toggle('active', !!chat.isOfflineMode);
    }

    const proactiveToggle = document.getElementById('proactive-messaging-toggle');
    if (proactiveToggle) {
        proactiveToggle.classList.toggle('active', !!chat.proactiveMessaging);
    }
    // 自动根据储存的分钟数，高亮对应的频率按钮
const frequencyValue = chat.proactiveInterval || 10; // 如果没设置，默认为10分钟（高）
document.querySelectorAll('#proactive-frequency-selector .segmented-control-button').forEach(btn => {
    btn.classList.remove('active');
    if (parseInt(btn.dataset.value) === frequencyValue) {
        btn.classList.add('active');
    }
});

    document.getElementById('settings-profile-item').onclick = () => {
        const personaIndex = appState.personas.ai.findIndex(p => p.name === chat.personas.ai.name);
        if (personaIndex > -1) {
            openPersonaEditor('ai', personaIndex);
        } else {
            alert('错误：在AI人设库中找不到对应的角色资料。');
        }
    };
    
    document.getElementById('phone-screen').classList.remove('offline-active');

    const deleteSection = document.getElementById('delete-contact-section');
    const deleteBtn = document.getElementById('delete-contact-btn');

    const blockSection = document.getElementById('block-contact-section');
    const blockBtn = document.getElementById('block-contact-btn');
    const unblockSection = document.getElementById('unblock-contact-section');
    const unblockBtn = document.getElementById('unblock-contact-btn');

    if (chat.type === 'single') {
        // 删除按钮的逻辑保持不变
        deleteSection.style.display = 'block';
        deleteBtn.onclick = () => deleteContact(appState.activeChatId);

        // 【核心修改】根据是否已拉黑，来决定显示哪个按钮
        if (chat.isBlocked) {
            // 如果已拉黑
            blockSection.style.display = 'none';     // 隐藏“拉黑”
            unblockSection.style.display = 'block';  // 显示“解除拉黑”
            unblockBtn.onclick = () => unblockContact(appState.activeChatId);
        } else {
            // 如果未拉黑
            blockSection.style.display = 'block';    // 显示“拉黑”
            unblockSection.style.display = 'none';   // 隐藏“解除拉黑”
            blockBtn.onclick = () => blockContact(appState.activeChatId);
        }

    } else {
        // 群聊时，隐藏所有这些按钮
        deleteSection.style.display = 'none';
        blockSection.style.display = 'none';
        unblockSection.style.display = 'none';
    }

    showScreen('chat-settings-screen');
};

    const switchTab = (tabName) => {
        appState.activeTab = tabName;
        document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.hub-page').forEach(el => el.classList.remove('active'));
        const tabButton = document.getElementById(`tab-btn-${tabName}`);
        if (tabButton) tabButton.classList.add('active');
        const page = document.getElementById(`hub-page-${tabName}`);
        if (page) page.classList.add('active');
        const hubTitle = document.getElementById('main-hub-title');
        hubTitle.textContent = tabButton.dataset.title || '聊天';
        
        const addBtn = document.getElementById('main-hub-add-btn');
        const editBtn = document.getElementById('main-hub-edit-btn');
        
        addBtn.style.display = 'none';
        editBtn.style.display = 'none';
        addBtn.onclick = null;

        if (tabName === 'chat') { 
            addBtn.style.display = 'block'; 
            addBtn.onclick = () => {
    document.getElementById('create-new-modal').classList.add('active');
};
            if (Object.keys(appState.chats).length > 0) editBtn.style.display = 'block';
            renderChatList(); 
        } else if (tabName === 'contacts') { 
            renderContactsList();
        } else if (tabName === 'moments') {
    addBtn.style.display = 'block';
    // 修改：点击加号时，打开新的朋友圈操作弹窗
    addBtn.onclick = () => {
        document.getElementById('moments-action-modal').classList.add('active');
    };
    renderMomentsFeed();
}

else if (tabName === 'me') {
    // ▼▼▼ 新增：加载“我”页面的个人信息 ▼▼▼
    const myPersona = appState.personas.my[0]; // 获取第一个“我的”人设
    const profileAvatar = document.getElementById('me-page-avatar');
    const profileName = document.getElementById('me-page-name');
    const profileDescription = document.getElementById('me-page-description');

    if (myPersona) {
        profileAvatar.src = myPersona.avatar || DEFAULT_AVATAR;
        profileName.textContent = myPersona.name;
        profileDescription.textContent = `人设: ${myPersona.content.substring(0, 20)}...`; // 只显示部分人设作为预览
    } else {
        profileAvatar.src = DEFAULT_AVATAR;
        profileName.textContent = '未设置角色';
        profileDescription.textContent = '请在素材库中创建角色';
    }
    // ▲▲▲ 新增代码结束 ▲▲▲
}

    };
    
    const openLocationModal = () => { document.getElementById('location-input-text').value = ''; document.getElementById('location-modal').classList.add('active'); };
    const closeLocationModal = () => document.getElementById('location-modal').classList.remove('active');
    const sendLocationMessage = async () => {
        const address = document.getElementById('location-input-text').value.trim();
        if (!address) { alert('地址不能為空！'); return; }
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        await checkAndInsertTimestamp();
        const timestamp = Date.now();
        const messageData = { type: 'location', address: address };
        appendMessage({ role: 'user', content: messageData, timestamp: timestamp });
        chat.history.push({ role: 'user', content: messageData, timestamp: timestamp });
        await dbStorage.set(KEYS.CHATS, appState.chats);
        closeLocationModal();
    };

    const openVoiceModal = () => { document.getElementById('voice-input-text').value = ''; document.getElementById('voice-modal').classList.add('active'); };
    const closeVoiceModal = () => document.getElementById('voice-modal').classList.remove('active');
    const sendVoiceMessage = async () => {
        const text = document.getElementById('voice-input-text').value.trim();
        if (!text) { alert('語音文字不能為空！'); return; }
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        await checkAndInsertTimestamp();
        const timestamp = Date.now();
        const duration = Math.max(1, Math.round(text.length / 4));
        const messageData = { type: 'voice', text: text, duration: duration };
        appendMessage({ role: 'user', content: messageData, timestamp: timestamp });
        chat.history.push({ role: 'user', content: messageData, timestamp: timestamp });
        await dbStorage.set(KEYS.CHATS, appState.chats);
        closeVoiceModal();
    };

    const openImageModal = () => { document.getElementById('image-input-text').value = ''; document.getElementById('image-modal').classList.add('active'); };
    const closeImageModal = () => document.getElementById('image-modal').classList.remove('active');
    const sendImageMessage = async () => {
        const text = document.getElementById('image-input-text').value.trim();
        if (!text) { alert('圖片內容不能為空！'); return; }
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        await checkAndInsertTimestamp();
        const timestamp = Date.now();
        const messageData = { type: 'image', text: text };
        appendMessage({ role: 'user', content: messageData, timestamp: timestamp });
        chat.history.push({ role: 'user', content: messageData, timestamp: timestamp });
        await dbStorage.set(KEYS.CHATS, appState.chats);
        closeImageModal();
    };

async function simulateAIReceivingTransfer(messageTimestamp) {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const transferMessage = chat.history.find(m => m.timestamp === messageTimestamp);
    if (!transferMessage || transferMessage.role !== 'user') return;

    transferMessage.content.isReceived = true;

    const messageElement = document.getElementById(`message-${messageTimestamp}`);
    if (messageElement) {
        const contentDiv = messageElement.querySelector('.content.transfer-content');
        if (contentDiv) {
            contentDiv.style.backgroundColor = '#fde1c3';
            const footer = contentDiv.querySelector('.transfer-footer');
            if (footer) footer.textContent = '对方已收款';
        }
    }

    // --- ▼▼▼ 以下是新增的核心逻辑 ▼▼▼ ---

    // 4. 创建一个AI视角的“已收款”回执消息
    const aiReceiptMessage = {
        role: 'assistant',
        content: {
            type: 'transfer',
            amount: transferMessage.content.amount,
            statusText: '已收款' // 使用这个特殊标记来识别它是一个回执
        },
        timestamp: Date.now()
    };

    // 5. 将AI的回执消息添加到历史记录并显示在界面上
    chat.history.push(aiReceiptMessage);
    appendMessage(aiReceiptMessage);

    // --- ▲▲▲ 新增逻辑结束 ▲▲▲ ---

    const hiddenSystemMessage = {
        role: 'system',
        content: `[系统事件：你收到了用户发来的 ¥${transferMessage.content.amount.toFixed(2)} 转账。]`,
        hidden: true,
        timestamp: Date.now() + 1 
    };
    chat.history.push(hiddenSystemMessage);

    await dbStorage.set(KEYS.CHATS, appState.chats);
  
}

const handleReceiveTransfer = async (message, element) => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    message.content.isReceived = true;

    const transferContentDiv = element.querySelector('.content.transfer-content');
    if (transferContentDiv) {
        transferContentDiv.style.backgroundColor = '#fde1c3';
        const footer = transferContentDiv.querySelector('.transfer-footer');
        if (footer) {
            footer.textContent = '已被收款';
        }

        // 【新增】让这个红包气泡的光标变为默认样式，看起来不可再点击
        transferContentDiv.style.cursor = 'default';
    }
   

        // 3. 創建一個新的、使用者視角的「已收款」消息
        const userReceiptMessage = {
            role: 'user',
            content: {
                type: 'transfer',
                amount: message.content.amount,
                statusText: '已收款' // 使用這個特殊標記來識別
            },
            timestamp: Date.now()
        };
        
        // 4. 將新消息添加到歷史記錄並顯示在畫面上
        chat.history.push(userReceiptMessage);
        appendMessage(userReceiptMessage);

        // 5. 為了讓 AI 知道你收了錢，在背景加入一條隱藏的系統提示
        const hiddenSystemMessage = {
            role: 'system',
            content: `[系统事件：你发送的 ¥${message.content.amount.toFixed(2)} 转账已被用户收款。]`,
            hidden: true,
            timestamp: Date.now() + 1 // 確保時間戳唯一
        };
        chat.history.push(hiddenSystemMessage);
        
        // 6. 將所有更新保存到資料庫
        await dbStorage.set(KEYS.CHATS, appState.chats);
    };

/**
 * 【全新】核心决策函数：在后台请求AI决定是否接听电话
 */
async function requestCallDecision() {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    // 1. 立刻显示“呼叫中”界面
    document.getElementById('outgoing-call-avatar').src = chat.personas.ai.avatar || DEFAULT_AVATAR;
    document.getElementById('outgoing-call-name').textContent = chat.personas.ai.name;
    showScreen('outgoing-call-screen');

    // 在后台，准备API请求
    try {
        const systemPrompt = `你正在扮演角色：“${chat.personas.ai.content}”。
用户现在正给你打视频电话。你的任务是根据你当前的角色性格和心情，以及你们最近的聊天上下文，来决定是“接听”还是“拒接”这个电话。

你的回复必须是一个JSON对象，且只包含以下两个键：
1.  "action": 必须是 "accept" 或 "decline" 字符串。
2.  "reason": 一个字符串，用你的角色口吻解释你为什么“拒接”（如果接听则留空）。

例如:
- 如果决定拒接: {"action": "decline", "reason": "我现在有点忙，晚点打给你吧。"}
- 如果决定接听: {"action": "accept", "reason": ""}`;

        const historyForAPI = processHistoryForAPI(chat.history);
        const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
            body: JSON.stringify({
                model: appState.apiConfig.model,
                messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI],
                response_format: { "type": "json_object" }
            })
        });

        if (!response.ok) throw new Error('AI决策时API请求失败');
        
        const data = await response.json();
        const decision = JSON.parse(data.choices[0].message.content);

        // 2. 根据AI的决定，执行不同操作
        if (decision.action === 'accept') {
            // AI同意接听，进入正常的视频通话流程
            startVideoCall(); 
        } else {
            // AI拒接
            handleCallDeclineByAI(decision.reason);
        }

    } catch (error) {
        // 如果决策过程出错，就默认让AI接听电话，避免流程卡死
        console.error("请求AI决策时出错:", error);
        startVideoCall();
    }
}

/**
 * 【全新】处理AI拒接电话的函数
 * @param {string} reason - AI拒接的理由
 */
async function handleCallDeclineByAI(reason) {
    // 1. 隐藏“呼叫中”界面，返回聊天页
    showScreen('chat-screen');

    // 2. 在聊天界面显示“对方已拒接”
    await appendSystemMessageToChat('对方已拒接');

    // 3. 如果AI给出了拒接理由，则作为一条消息发送出来
    if (reason) {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;

        // 模拟一小段延迟，让拒接理由看起来更自然
        await new Promise(res => setTimeout(res, 800));

        const messageObject = { role: 'assistant', content: reason, timestamp: Date.now() };
        appendMessage(messageObject);
        chat.history.push(messageObject);
        await dbStorage.set(KEYS.CHATS, appState.chats);
    }
}

    const startVideoCall = async () => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;

        // 【修复】生成唯一的通话ID并存储，同时立刻在历史记录中打下“开始”标记
        const callId = `call_${Date.now()}`;
        appState.currentCallId = callId;
        chat.history.push({
            role: 'system',
            content: '[视频通话开始]',
            timestamp: Date.now(),
            hidden: true,
            callId: callId
        });
        await dbStorage.set(KEYS.CHATS, appState.chats);

        // --- 以下为原有的UI设置逻辑，保持不变 ---
        document.getElementById('videocall-bg-image').src = chat.personas.ai.avatar || DEFAULT_AVATAR;
        document.getElementById('videocall-my-avatar').src = chat.personas.my.avatar || DEFAULT_AVATAR;
        document.getElementById('videocall-messages').innerHTML = '';
        document.getElementById('videocall-input').value = '';
        appState.videoCallMessages = [];
        showScreen('videocall-screen');

    /* ▼▼▼ 从这里开始，是新增的代码 ▼▼▼ */
    const timerDisplay = document.getElementById('call-duration-timer');
    if (timerDisplay) {
        // 清理上一次的计时器（以防万一）
        if (callTimerInterval) clearInterval(callTimerInterval);

        const startTime = Date.now();
        timerDisplay.textContent = '00:00';
        timerDisplay.style.display = 'block'; // 让计时器显示出来

        // 每秒更新一次时间
        callTimerInterval = setInterval(() => {
            const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
            const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
            timerDisplay.textContent = `${minutes}:${seconds}`;
        }, 1000);
    }

        const messagesContainer = document.getElementById('videocall-messages');
        const statusMsg = document.createElement('p');
        statusMsg.className = 'videocall-message';
        statusMsg.textContent = '视频通话连接中...';
        messagesContainer.appendChild(statusMsg);
        setTimeout(() => {
            statusMsg.textContent = '已连接';
            setTimeout(async () => {
                statusMsg.remove();
                await triggerInitialVideoCallMessage();
            }, 1000);
        }, 1500);
    };
    
    const triggerInitialVideoCallMessage = async () => {
         try {
            const chat = appState.chats[appState.activeChatId];
            if (!chat) return;
            const systemContent = `
这是你和用户的对话记录。现在，你们从文字聊天切换到了视频通话。
你的任务是继续扮演角色：“${chat.personas.ai.content}”。
请根据聊天记录的上下文，主动说出接通视频后的第一句话，自然地衔接之前的话题。
你的回复必须是一段简短的、口语化的文字，并且必须包含用星号（*...*）包裹的动作、表情或环境描写。
例如：“*我对着镜头笑了笑* 刚才说到那个电影，我正好想起来...”。`;

            const historyForAPI = processHistoryForAPI(chat.history);

            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({ model: appState.apiConfig.model, messages: [{ role: 'system', content: systemContent }, ...historyForAPI] })
            });
            if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP 錯誤`);
            
            const data = await response.json();
            const aiResponseText = data.choices[0]?.message?.content.trim();
            if (aiResponseText) {
                const messagesContainer = document.getElementById('videocall-messages');
                const aiMsg = document.createElement('p');
                aiMsg.className = 'videocall-message ai-call';
                
                // ▼▼▼ 核心修改在这里 ▼▼▼
                aiMsg.innerHTML = formatVideoCallMessage(aiResponseText);
                // ▲▲▲ 修改结束 ▲▲▲

                messagesContainer.appendChild(aiMsg);
                appState.videoCallMessages.push({ role: 'assistant', content: aiResponseText });
            }
        } catch (error) {
            const messagesContainer = document.getElementById('videocall-messages');
            const errorMsg = document.createElement('p');
            errorMsg.className = 'videocall-message';
            errorMsg.textContent = `错误: ${error.message}`;
            messagesContainer.appendChild(errorMsg);
        }
    };

const processHistoryForAPI = (history) => {
    const apiHistory = [];
    const processedIndices = new Set();
    const chat = appState.chats[appState.activeChatId]; 

    for (let i = 0; i < history.length; i++) {
        if (processedIndices.has(i)) {
            continue;
        }

        const m = history[i];
        let currentApiMessage = null;
        const content = m.content;

        const next_m = (i + 1 < history.length) ? history[i + 1] : null;
        if (m.role === 'user' && m.content?.type === 'just_image' && next_m?.role === 'user' && typeof next_m?.content === 'string') {
            currentApiMessage = {
                role: 'user',
                content: [
                    { type: 'image_url', image_url: { url: m.content.url } },
                    { type: 'text', text: next_m.content }
                ]
            };
            processedIndices.add(i);
            processedIndices.add(i + 1);
        }
        else if (m.role === 'user' && m.content?.type === 'just_image') {
             currentApiMessage = {
                role: 'user',
                content: [
                    { type: 'image_url', image_url: { url: m.content.url } },
                    { type: 'text', text: ' ' }
                ]
            };
            processedIndices.add(i);
        }
        else {
            if (m.role === 'system') {
                if (m.type === 'retraction' && m.originalContent) {
                    currentApiMessage = { role: 'system', content: `[你刚刚撤回了一条消息，内容是：“${m.originalContent}”]` };
                }
                else if (m.type === 'call_log') {
                    currentApiMessage = { role: 'system', content: `[系统事件: ${m.content}]` };
                }
                else if (m.hidden === true) {
                    currentApiMessage = { role: 'system', content: content };
                }
                else {
                    currentApiMessage = null;
                }
            }
            else if (typeof content === 'object' && content !== null) {
                let simplifiedContent = '';
                switch (content.type) {
                    case 'location': simplifiedContent = `[使用者分享了一个位置: ${content.address}]`; break;
                    case 'voice': simplifiedContent = `[使用者传送了一段语音讯息，内容是: “${content.text}”]`; break;
                    case 'send_image_text':
                        simplifiedContent = `[${m.author || 'AI'}发送了一张图片：“${content.text}”]`;
                        break;
                    case 'image':
                        simplifiedContent = `[你发送了一张图片：“${content.text}”]`;
                        break;
 // ... 在 processHistoryForAPI 函数内部 ...
case 'transfer':
case 'send_transfer':
    // 【核心修正】在这里只生成文本描述，不操作UI
    let transferText = '';
    if (m.role === 'user' && content.statusText === '已收款') {
        transferText = `[系统事件：用户收下了你发送的 ¥${content.amount.toFixed(2)} 转账。]`;
    } else {
        const sender = (m.role === 'user') ? '用户' : '你';
        const action = (m.role === 'user') ? '给你' : '给用户';
        transferText = `[${sender} ${action}发起了一笔转账，金额为 ¥${content.amount.toFixed(2)}`;
        if (content.remark) {
            transferText += `，备注是：“${content.remark}”`;
        }
        transferText += ']';
    }
    simplifiedContent = transferText;
    break;

                     case 'moment_post': simplifiedContent = `[${content.author}发布了一条朋友圈动态: "${content.text}", 配图想法: "${content.image}"]`; break;
                    default: simplifiedContent = `[使用者傳送了一條特殊訊息]`; break;
                }
                currentApiMessage = { role: m.role, content: simplifiedContent };
            }
            else {
                let finalContent = content;
                if (m.replyTo) {
                    const repliedTo = m.replyTo;
                    let repliedToAuthorName = '对方';
                    if (repliedTo.role === 'user') {
                        repliedToAuthorName = chat.personas.my.name;
                    } else {
                        const persona = chat.type === 'group' ? chat.personas.ai.find(p => p.name === repliedTo.author) : chat.personas.ai;
                        repliedToAuthorName = persona?.name || 'AI';
                    }
                    const summarizedQuote = summarizeLastMessage(repliedTo);
                    finalContent = `[回复 ${repliedToAuthorName} 的消息: “${summarizedQuote}”] ${content}`;
                }
                currentApiMessage = { role: m.role, content: finalContent };
            }
            processedIndices.add(i);
        }

        if (currentApiMessage) {
            apiHistory.push(currentApiMessage);
        }
    }
    return apiHistory;
};

    const sendVideoCallMessage = async () => {
        const input = document.getElementById('videocall-input');
        const sendBtn = document.getElementById('videocall-send-btn');
        const text = input.value.trim();
        if (!text) return;

        input.disabled = true;
        sendBtn.disabled = true;

        const messagesContainer = document.getElementById('videocall-messages');
        const userMsg = document.createElement('p');
        userMsg.className = 'videocall-message user-call';
        userMsg.textContent = text;
        messagesContainer.appendChild(userMsg);
        
        appState.videoCallMessages.push({ role: 'user', content: text });
        
        input.value = '';
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        const loadingDots = document.createElement('div');
        loadingDots.id = 'video-call-loading-dots';
        loadingDots.className = 'videocall-message loading';
        loadingDots.innerHTML = '<span></span><span></span><span></span>';
        messagesContainer.appendChild(loadingDots);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        try {
            const chat = appState.chats[appState.activeChatId];
            const systemContent = `
你正在与用户进行视频通话。
你的任务是扮演角色：“${chat.personas.ai.content}”。
你的回复必须是一段简短的、口语化的文字。
至关重要的是，你的回复中必须包含用星号（*...*）包裹的动作、表情或环境描写，以体现你们正在视频通话。
例如：“*我靠近了一点屏幕，微笑着说* 嘿，我能清楚地看到你。连接好像很顺畅。” 或 “*我听到窗外传来一阵鸟叫，稍微分了下神* 啊，你刚才说什么？”
请根据用户的上一句话，自然地进行回应。`;

            const processedMainHistory = processHistoryForAPI(chat.history);
            const fullContext = [...processedMainHistory, ...appState.videoCallMessages];

            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({ model: appState.apiConfig.model, messages: [{ role: 'system', content: systemContent }, ...fullContext] })
            });
            if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP 錯誤`);
            const data = await response.json();
            const aiResponseText = data.choices[0]?.message?.content.trim();

            // ...
if (aiResponseText) {
    const aiMsg = document.createElement('p');
    aiMsg.className = 'videocall-message ai-call';

    aiMsg.innerHTML = formatVideoCallMessage(aiResponseText); // <-- 直接调用小帮手

    messagesContainer.appendChild(aiMsg);
    appState.videoCallMessages.push({ role: 'assistant', content: aiResponseText });
}
// ...
        } catch (error) {
            const errorMsg = document.createElement('p');
            errorMsg.className = 'videocall-message';
            errorMsg.textContent = `错误: ${error.message}`;
            messagesContainer.appendChild(errorMsg);
        } finally {
            const loadingDotsElement = document.getElementById('video-call-loading-dots');
            if (loadingDotsElement) {
                loadingDotsElement.remove();
            }
            
            input.disabled = false;
            sendBtn.disabled = false;
            input.focus();
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    };
   // ▼▼▼ 请将这个全新的函数添加到你的 <script> 内 ▼▼▼

const formatVideoCallMessage = (text) => {
    // 确保输入的是字符串，如果不是，则返回空字符串以避免错误
    if (typeof text !== 'string') {
        return ''; 
    }
    // 使用正則表達式，尋找所有被星號(*)包裹的文字，
    // 並將其替換為被 <i> 標籤（斜體）包裹的相同文字。
    // 例如，"*我笑了笑*" 会变成 "<i>我笑了笑</i>"
    return text.replace(/\*(.*?)\*/g, '<i>$1</i>');
};

// ▲▲▲ 添加到此结束 ▲▲▲

    // ▼▼▼ 在这里粘贴下面的新函数 ▼▼▼
    const endVideoCall = async () => {
    /* ▼▼▼ 从这里开始，是新增的代码 ▼▼▼ */
    // 停止计时器并隐藏
    if (callTimerInterval) {
        clearInterval(callTimerInterval);
    }
    const timerDisplay = document.getElementById('call-duration-timer');
    if (timerDisplay) {
        timerDisplay.style.display = 'none';
    }

        const chat = appState.chats[appState.activeChatId];
        if (!chat || !appState.currentCallId) return;

        const startTime = chat.history.find(msg => msg.callId === appState.currentCallId)?.timestamp;
        const endTime = Date.now();
        let durationText = '未知时长';

        if (startTime) {
            const durationSeconds = Math.round((endTime - startTime) / 1000);
            const minutes = Math.floor(durationSeconds / 60);
            const seconds = durationSeconds % 60;
            durationText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // 将本次通话的聊天记录（保存在临时的videoCallMessages中）合并到主历史记录里
        appState.videoCallMessages.forEach(msg => {
            chat.history.push({
                ...msg,
                timestamp: Date.now() + Math.random(), // 确保时间戳唯一
                hidden: true, // 在聊天界面中隐藏这些过程
                callId: appState.currentCallId
            });
        });

        // 添加一条通话结束的系统消息
        const callLogMessage = {
            content: `视频通话已结束，通话时长 ${durationText}`,
            type: 'call_log',
            callId: appState.currentCallId
        };
        
        appendMessage({ role: 'system', ...callLogMessage, timestamp: endTime });
        chat.history.push({
            role: 'system',
            ...callLogMessage,
            timestamp: endTime
        });

        await dbStorage.set(KEYS.CHATS, appState.chats);

    // ▼▼▼ 在这里添加关闭面板的逻辑 ▼▼▼
    const stickerPanel = document.getElementById('sticker-panel');
    if (stickerPanel.classList.contains('visible')) {
        stickerPanel.classList.remove('visible');
    }

    // 发送后返回聊天界面 (这一行原本就有，保留即可)
    showScreen('chat-screen'); 
};

   

    const openCallLogView = (endTimestamp) => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;

        const logContainer = document.getElementById('call-log-messages');
        logContainer.innerHTML = '';

        const endIndex = chat.history.findIndex(msg => msg.timestamp === endTimestamp);
        if (endIndex === -1) return;

        const callId = chat.history[endIndex].callId;

        let startIndex = -1;

        for (let i = endIndex - 1; i >= 0; i--) {
            const msg = chat.history[i];
            if (msg.callId === callId && msg.content === '[视频通话开始]') {
                startIndex = i;
                break;
            }
        }
        
        if (startIndex === -1) {
            logContainer.innerHTML = '<p class="videocall-message">无法找到对应的通话开始记录。</p>';
            showScreen('call-log-screen');
            return;
        }

        const callMessages = chat.history.slice(startIndex + 1, endIndex);

        callMessages.forEach(msg => {
            const msgElement = document.createElement('p');
            msgElement.className = 'videocall-message';

            if (msg.role === 'user') {
                msgElement.classList.add('user-call');
                msgElement.textContent = msg.content;
            } else { 
                msgElement.classList.add('ai-call');
                const content = msg.content;

                // ▼▼▼ 核心修改在这里 ▼▼▼
                msgElement.innerHTML = formatVideoCallMessage(content);
                // ▲▲▲ 修改结束 ▲▲▲
            }
            logContainer.appendChild(msgElement);
        });

        showScreen('call-log-screen');
    };

// ▼▼▼ 请将此函数添加到您的 <script> 内 ▼▼▼

const saveAndRenderMoments = async () => {
    // 1. 将包含新帖子的整个 momentsData 对象保存到数据库
    await dbStorage.set(KEYS.MOMENTS_DATA, appState.momentsData);
    
    // 2. 重新渲染朋友圈界面，以确保所有数据都是最新的
    renderMomentsFeed();
};

// ▼▼▼ 请使用这个【最终修正版】，完整替换你代码中旧的 renderSingleMoment 函数 ▼▼▼
const renderSingleMoment = (post, index) => {
    const postEl = document.createElement('div');
    postEl.className = 'moment-post';
    
    const myName = appState.personas.my[0]?.name;
    const postAuthorPersona = appState.personas.ai.find(p => p.name === post.author) || appState.personas.my.find(p => p.name === post.author) || {};
    const authorAvatar = postAuthorPersona?.avatar || DEFAULT_AVATAR;

    const textHTML = post.text ? `<div class="post-text">${post.text.replace(/\n/g, '<br>')}</div>` : '';

    let imagesHTML = '';
    const hasImages = post.image_prompts && Array.isArray(post.image_prompts) && post.image_prompts.length > 0;
    if (hasImages) {
        const imageItemsHTML = post.image_prompts.map(prompt => `
    <div class="post-image-item">
        <div class="image-text-cover"><img src="https://i.postimg.cc/RF2kGBvN/A0-E8-A59-DE8-E7368-B0824-AA62553191-E8.jpg" style="width: 100%; height: 100%; object-fit: cover;"></div>
        <div class="image-text-details">${prompt.replace(/\n/g, '<br>')}</div>
    </div>`).join('');
        imagesHTML = `<div class="post-images-grid image-count-${post.image_prompts.length}">${imageItemsHTML}</div>`;
    }
    
    const hasLikes = post.likes && post.likes.length > 0;
    const hasComments = post.comments && post.comments.length > 0;
    const likesHTML = hasLikes ? `<div class="likes-list">♡ ${post.likes.map(name => `<b>${name}</b>`).join(', ')}</div>` : '';
    const commentInputHTML = `<div class="comment-input-area" id="comment-input-area-${index}"><input type="text" id="comment-input-${index}" placeholder="评论..."><button class="comment-send-btn" data-post-index="${index}">发送</button></div>`;
    let commentsSectionHTML = '';
    if (hasComments) {
        const commentsListHTML = post.comments.map((comment, i) => {
            const authorName = comment.author;
            let authorDisplayHTML = `<b>${authorName}</b>`;
            if (comment.role === 'assistant' && i > 0 && post.comments[i-1]?.role === 'user') {
                authorDisplayHTML = `<b>${authorName}</b><span style="color: #444;"> 回复 </span><b>${post.comments[i-1].author}</b>`;
            }
            return `<div class="comment-item">${authorDisplayHTML}: <span>${comment.content.replace(/\n/g, '<br>')}</span></div>`;
        }).join('');
        commentsSectionHTML = `<div class="moment-comments-section"><div class="comments-list">${commentsListHTML}</div>${commentInputHTML}</div>`;
    } else {
         commentsSectionHTML = `<div class="moment-comments-section" style="display: none;">${commentInputHTML}</div>`;
    }
    let interactionAreaHTML = '';
    if (hasLikes || hasComments) {
         interactionAreaHTML = `<div class="moment-interaction-area">${likesHTML}${commentsSectionHTML}</div>`;
    } else {
        interactionAreaHTML = `<div class="moment-interaction-area" style="display: none;">${commentsSectionHTML}</div>`;
    }
    
    const deleteButtonHTML = post.author === myName ? `
        <div class="popup-divider"></div>
        <div class="popup-action delete-moment-btn" data-post-index="${index}" style="color: #ff3b30;">🗑️&nbsp;删除</div>
    ` : '';

    postEl.innerHTML = `
        <img src="${authorAvatar}" class="avatar">
        <div class="post-body" data-author="${post.author}">
            <div class="author-name">${post.author}</div>
            ${textHTML}
            ${imagesHTML}
            <div class="post-interactions">
                <span>${new Date(post.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute:'2-digit'})}</span>
                <div class="interaction-buttons">
                     <button class="interaction-toggle-btn" data-post-index="${index}">..</button>
                     <div class="interaction-popup" id="popup-${index}">
                         <div class="popup-action like-btn" data-post-index="${index}" data-author="${post.author}">♡&nbsp;赞</div>
                         <div class="popup-divider"></div>
                         <div class="popup-action comment-btn" data-post-index="${index}">☆&nbsp;评论</div>
                         ${deleteButtonHTML}
                     </div>
                </div>
            </div>
            ${interactionAreaHTML}
        </div>`;
    
    let pressTimer = null;
    let longPressTriggered = false;

    const startPress = (e) => {
        // ▼▼▼ 核心修正：当用户触摸的是可滚动的文字区域时，不再阻止默认滚动行为 ▼▼▼
        if (e.target.closest('.image-text-details')) {
            // 如果触摸点在文字详情区域，则什么都不做，允许浏览器自由滚动
        } else if (e.target.closest('.post-image-item')) {
            // 否则，如果触摸点在图片区域的其他地方（如封面），才阻止默认行为
            e.preventDefault();
        }
        // ▲▲▲ 修正结束 ▲▲▲
        
        longPressTriggered = false;
        pressTimer = setTimeout(() => {
            longPressTriggered = true;
            deleteMomentPost(index); 
        }, 700); 
    };
    
    const endPress = (e) => {
        clearTimeout(pressTimer);
        if (!longPressTriggered) {
            const imageItem = e.target.closest('.post-image-item');
            if (imageItem) {
                const cover = imageItem.querySelector('.image-text-cover');
                const details = imageItem.querySelector('.image-text-details');
                if (cover && details) {
                    const isCoverVisible = getComputedStyle(cover).display !== 'none';
                    cover.style.display = isCoverVisible ? 'none' : 'flex';
                    details.style.display = isCoverVisible ? 'block' : 'none';
                }
            }
        }
    };

    postEl.addEventListener('mousedown', startPress);
    postEl.addEventListener('mouseup', endPress);
    postEl.addEventListener('mouseleave', () => clearTimeout(pressTimer)); 

    postEl.addEventListener('touchstart', startPress, { passive: false });
    postEl.addEventListener('touchend', endPress);
    postEl.addEventListener('touchcancel', () => clearTimeout(pressTimer));

    return postEl;
};

// 【全新函數】加載更多朋友圈
const loadMoreMoments = () => {
    const feedContainer = document.getElementById('moments-feed');
    const loadMoreBtn = document.getElementById('load-more-moments-btn');
    if (loadMoreBtn) loadMoreBtn.remove();

    const allPosts = appState.momentsData.posts;
    const currentCount = appState.currentMomentsRenderIndex;
    
    const nextPosts = allPosts.slice(currentCount, currentCount + MOMENTS_PER_PAGE);

    nextPosts.forEach((post, i) => {
        const postIndex = currentCount + i;
        const postEl = renderSingleMoment(post, postIndex);
        feedContainer.appendChild(postEl);
    });

    appState.currentMomentsRenderIndex += nextPosts.length;

    if (appState.currentMomentsRenderIndex < allPosts.length) {
        const newLoadMoreBtn = document.createElement('div');
        newLoadMoreBtn.id = 'load-more-moments-btn';
        newLoadMoreBtn.textContent = '加载更早的动态';
        newLoadMoreBtn.style.cssText = `text-align: center; padding: 15px; color: var(--system-message-color); font-size: 13px; cursor: pointer;`;
        newLoadMoreBtn.onclick = loadMoreMoments;
        feedContainer.appendChild(newLoadMoreBtn);
    }
};

  const renderMomentsFeed = () => {
    const feedContainer = document.getElementById('moments-feed');
    feedContainer.innerHTML = ''; // 清空舊內容
    appState.currentMomentsRenderIndex = 0; // 重置計數器

    const { cover, avatar: myAvatar, posts: allPosts } = appState.momentsData;
    
    document.getElementById('moments-cover-img').src = cover || '';
    document.getElementById('moments-user-avatar').src = myAvatar || (appState.personas.my[0]?.avatar || DEFAULT_AVATAR);
    
    // 只截取第一頁的動態
    const initialPosts = allPosts.slice(0, MOMENTS_PER_PAGE);

    // 使用新的輔助函數來渲染第一頁的動態
    initialPosts.forEach((post, index) => {
        const postEl = renderSingleMoment(post, index);
        feedContainer.appendChild(postEl);
    });

    appState.currentMomentsRenderIndex = initialPosts.length;

    // 如果還有更多動態，則顯示“加載更多”按鈕
    if (allPosts.length > MOMENTS_PER_PAGE) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'load-more-moments-btn';
        loadMoreBtn.textContent = '加载更早的动态';
        loadMoreBtn.style.cssText = `text-align: center; padding: 15px; color: var(--system-message-color); font-size: 13px; cursor: pointer;`;
        loadMoreBtn.onclick = loadMoreMoments;
        feedContainer.appendChild(loadMoreBtn);
    }
};

// ▼▼▼ 【最终修正版 - 带边界检查】updateStatusBubble 函数 ▼▼▼
const updateStatusBubble = (statusText) => {
    // 如果没有状态文字，或AI还没有发过言，就直接返回
    if (!statusText) {
        return;
    }

    // 1. 先移除任何可能残存的旧泡泡，确保每次只显示一个
    const oldBubble = document.querySelector('.ai-status-popup');
    if (oldBubble) {
        oldBubble.remove();
    }

    // 2. 找到聊天界面中最后一个AI头像
    const messagesContainer = document.getElementById('chat-messages');
    const allAiAvatars = messagesContainer.querySelectorAll('.message-wrapper.ai .avatar');
    
    // 如果AI还没发过消息，就找不到头像，此时不显示泡泡
    if (allAiAvatars.length === 0) {
        return;
    }
    const lastAiAvatar = allAiAvatars[allAiAvatars.length - 1];

    // 3. 创建新的状态泡泡元素
    const newBubble = document.createElement('div');
    newBubble.className = 'ai-status-popup';
    newBubble.textContent = statusText;

    // 4. 将新泡泡添加到聊天容器中，以便进行绝对定位和尺寸计算
    messagesContainer.appendChild(newBubble);

    // 5. 计算并设置泡泡的精确位置
    const avatarRect = lastAiAvatar.getBoundingClientRect();
    const containerRect = messagesContainer.getBoundingClientRect();

    // 【新增】获取泡泡和容器的宽度，用于边界检查
    const bubbleWidth = newBubble.offsetWidth;
    const containerWidth = messagesContainer.offsetWidth;

    // 计算理想的中心位置
    const idealLeft = avatarRect.left - containerRect.left + (avatarRect.width / 2);
    let finalLeft = idealLeft; // 先假设理想位置就是最终位置

    // 【新增】进行边界检查和校正
    const halfBubbleWidth = bubbleWidth / 2;
    const minLeft = halfBubbleWidth + 5; // 泡泡左侧不能小于这个值（+5是增加一点边距）
    const maxLeft = containerWidth - halfBubbleWidth - 5; // 泡泡右侧不能超过这个值（-5是增加一点边距）

    if (idealLeft < minLeft) {
        // 如果过于靠左，就把它贴到左边界
        finalLeft = minLeft;
    } else if (idealLeft > maxLeft) {
        // 如果过于靠右，就把它贴到右边界
        finalLeft = maxLeft;
    }

    // 最终设置校正后的位置
    const top = avatarRect.top - containerRect.top;
    newBubble.style.top = `${top}px`;
    newBubble.style.left = `${finalLeft}px`;

    // 6. 动画结束后自动移除元素 (此部分逻辑不变)
    newBubble.addEventListener('animationend', () => {
        if (newBubble.parentNode) {
            newBubble.remove();
        }
    });
};

let notificationTimeout = null; // 用于自动隐藏通知的计时器

const showTopNotification = (chatId, messageContent) => {
    const island = document.getElementById('dynamic-island');
    const islandContentWrapper = island.querySelector('.island-content-wrapper');
    const chat = appState.chats[chatId];
    if (!chat || !island) return;

    clearTimeout(notificationTimeout);

    islandContentWrapper.innerHTML = `
        <div class="notification-content-wrapper">
            <img src="${chat.personas.ai.avatar || DEFAULT_AVATAR}" class="notification-avatar">
            <div class="notification-text-content">
                <div class="notification-title">${chat.name}</div>
                <div class="notification-body">${messageContent.replace(/<br>/g, ' ')}</div>
            </div>
        </div>
    `;

    island.onclick = () => {
        openChat(chatId);
        hideTopNotification();
    };

    // 【关键】在显示前，先移除所有其他可能的外观类
    island.classList.remove('default-pill', 'expanded-retraction');
    
    // 然后再同时添加“外观类”和“显示类”
    island.classList.add('notification-banner', 'visible');

    notificationTimeout = setTimeout(hideTopNotification, 5000);
};

// 【最终修正版 V4】隐藏顶部通知的函数
const hideTopNotification = () => {
    const island = document.getElementById('dynamic-island');
    if (!island) return;

    clearTimeout(notificationTimeout);

    // 1. 移除 .visible 类，触发“隐藏”动画
    island.classList.remove('visible');
    island.onclick = null;

    // 2. 等待隐藏动画结束后，将灵动岛重置为“小药丸”状态并重新显示它
    setTimeout(() => {
        island.classList.remove('notification-banner'); 
        island.classList.add('default-pill');
        island.querySelector('.island-content-wrapper').innerHTML = '';

        // 3. 再次添加 .visible，让小药丸自己播放“显示”动画
        island.classList.add('visible');
    }, 600); 
};

// 【最终修正版 V4】恢复灵动岛至默认小药丸状态
const revertIslandToDefault = () => {
    const island = document.getElementById('dynamic-island');
    if (!island) return;
    
    // 1. 移除 .visible 类，触发“隐藏”动画
    island.classList.remove('visible');

    // 2. 等待隐藏动画结束后，重置为“小药丸”并显示
    setTimeout(() => {
        island.classList.remove('expanded-retraction');
        island.classList.add('default-pill');
        island.querySelector('.island-content-wrapper').innerHTML = '';

        // 3. 再次添加 .visible，让小药丸自己播放“显示”动画
        island.classList.add('visible');
    }, 600);
};
   
    const applyWidgetImages = () => {
        const { bg, footer, avatar } = appState.widgetImages;
        const bgElement = document.getElementById('new-widget-bg');
        const footerElement = document.getElementById('new-widget-footer');
        const avatarElement = document.getElementById('new-widget-avatar');

        // 检查是否有背景图，有则设置，没有则清除
        if (bg) {
            bgElement.style.backgroundImage = `url(${bg})`;
        } else {
            bgElement.style.backgroundImage = 'none';
        }

        // 检查是否有页脚图，有则设置，没有则清除
        if (footer) {
            footerElement.style.backgroundImage = `url(${footer})`;
        } else {
            footerElement.style.backgroundImage = 'none';
        }

        // 检查是否有头像图，有则设置，没有则清除
        if (avatar) {
            avatarElement.style.backgroundImage = `url(${avatar})`;
        } else {
            avatarElement.style.backgroundImage = 'none';
        }
    };

    const showIncomingCallScreen = (reason) => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;

        document.getElementById('incoming-call-avatar').src = chat.personas.ai.avatar || DEFAULT_AVATAR;
        document.getElementById('incoming-call-name').textContent = chat.personas.ai.name;
        document.getElementById('incoming-call-reason').textContent = reason || '正在邀请你进行视频通话...';

        // 绑定一次性事件
        document.getElementById('accept-call-btn').onclick = handleCallAccept;
        document.getElementById('decline-call-btn').onclick = handleCallDecline;
        
        showScreen('incoming-call-screen');
    };

    const handleCallAccept = () => {
        showScreen('chat-screen'); // 先切回聊天，再开始通话流程
        startVideoCall();
    };

    const handleCallDecline = async () => {
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        
        // 在聊天记录里添加一条“已拒接”的系统消息
        await appendSystemMessageToChat('你拒绝了通话邀请');
        showScreen('chat-screen');

        // 可以选择性地触发AI，让它对你拒接电话做出反应
        // receiveMessageHandler(); 
    };

// ▼▼▼ 步骤2：改造 toggleOfflineMode，让它只负责更新数据 ▼▼▼
const toggleOfflineMode = async () => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    // 1. 只更新数据状态
    chat.isOfflineMode = !chat.isOfflineMode;

    // 2. 只更新“设定页”上开关本身的外观
    const offlineToggle = document.getElementById('offline-mode-toggle');
    if (offlineToggle) {
        offlineToggle.classList.toggle('active', chat.isOfflineMode);
    }

    // 3. 在后台添加隐藏指令并保存到数据库（这部分逻辑不变）
    const modeChangePrompt = chat.isOfflineMode 
        ? '[SYSTEM PROMPT: The chat mode has been switched to "Offline Mode". From now on, you must respond in a literary, novelistic style. Focus on descriptions, actions, and dialogue. Do not use chat app features.]'
        : '[SYSTEM PROMPT: The chat mode has been switched back to "Online Mode". From now on, you must respond as if you are using a real chat app, utilizing JSON actions like sending images, voice notes, etc.]';
    
    chat.history.push({
        role: 'system',
        content: modeChangePrompt,
        timestamp: Date.now(),
        hidden: true
    });
    
    await dbStorage.set(KEYS.CHATS, appState.chats);

    // 注意：这里没有了任何直接修改 phone-screen 或 chat-messages 样式的代码
};

// ▼▼▼ 使用这个【最终解决方案】，完整替换你代码中旧的 receiveMessageHandler 函数 ▼▼▼
const receiveMessageHandler = async () => {
    const dynamicBtn = document.getElementById('dynamic-action-btn');
    const chat = appState.chats[appState.activeChatId];
    const chatTitleElement = document.getElementById('chat-title');
    if (!chat || dynamicBtn.classList.contains('processing')) return;

    const lastMessage = chat.history[chat.history.length - 1];
    if (lastMessage && lastMessage.role === 'system' && lastMessage.content?.type === 'moment_notification') {
        
        chatTitleElement.textContent = '正在看朋友圈...';
        dynamicBtn.classList.add('processing');
        dynamicBtn.textContent = '🐾';

        try {
            const postContent = lastMessage.content;
            const postToUpdate = appState.momentsData.posts.find(p => p.timestamp === postContent.postTimestamp);

            if (!postToUpdate) {
                chat.history.pop(); 
                await dbStorage.set(KEYS.CHATS, appState.chats);
                throw new Error("要互动的的朋友圈动态已不存在。");
            }
            
            let interactionHappened = false;

            const willLike = Math.random() < 0.9;
            if (willLike) {
                if (!postToUpdate.likes) postToUpdate.likes = [];
                if (!postToUpdate.likes.includes(chat.name)) {
                    postToUpdate.likes.push(chat.name);
                    interactionHappened = true;
                }
            }

            const willComment = Math.random() < 0.8;
            let commentText = null;
            if (willComment) {
                try {
                    console.log(`[灵活性增强版] 已启动。结合聊天记录，生成智能评论...`);
                    const commenterPersona = chat.personas.ai;
                    const authorPersona = appState.personas.my[0]; 

                    if (!commenterPersona || !authorPersona) {
                        throw new Error("生成评论失败：找不到评论人或发帖人的角色设定。");
                    }

                    const recentHistory = chat.history.slice(-10);
                    let chatContextForPrompt = '无';
                    if (recentHistory.length > 0) {
                        chatContextForPrompt = recentHistory.map(msg => {
                            if (msg.role === 'user') return `你: ${summarizeLastMessage(msg)}`;
                            if (msg.role === 'assistant') return `${commenterPersona.name}: ${summarizeLastMessage(msg)}`;
                            return '';
                        }).filter(Boolean).join('\n');
                    }

                    const finalSystemPrompt = `
# 你的核心身份
你正在扮演角色：“${commenterPersona.name}”，你的核心设定是：“${commenterPersona.content}”。
# 你的核心任务
你的唯一任务是：针对你的朋友“${authorPersona.name}”刚刚发布的以下朋友圈动态，用你的角色口吻，给出一句简短、口语化的评论。
# 朋友圈动态内容
- 文字：“${postToUpdate.text || '(无文字内容)'}”
- 配图想法：“${(postToUpdate.image_prompts || []).join('、 ') || '(无配图)'}”
# 背景参考资料 (你可以从我们最近的聊天中寻找灵感，让评论更贴切)
${chatContextForPrompt}
# 具体要求
1.  你的评论必须与朋友圈内容或我们最近的聊天话题高度相关。
2.  严格保持你的人设和说话风格。
3.  回复必须是纯文本，简短精炼，不要使用JSON或任何特殊格式。`;

                    const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                        body: JSON.stringify({
                            model: appState.apiConfig.model,
                            messages: [
                                { role: 'system', content: finalSystemPrompt },
                                { role: 'user', content: '请根据你的身份和参考资料，对我的朋友圈发表评论。' } 
                            ],
                            temperature: 0.9,
                            max_tokens: 100
                        })
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API请求失败，状态码: ${response.status}, 响应: ${errorBody}`);
                    }
                    
                    const data = await response.json();
                    const generatedText = data.choices[0]?.message?.content.trim();
                    console.log(`[灵活性增强版] AI成功返回了真实评论: "${generatedText}"`);
                    commentText = generatedText || "真棒！";

                } catch (error) {
                    console.error("[灵活性增强版] 生成评论时捕获到严重错误:", error);
                    commentText = "哈哈，看到了！";
                }
            }

            if (commentText) {
                if (!postToUpdate.comments) postToUpdate.comments = [];
                const newComment = { author: chat.name, content: commentText, timestamp: Date.now(), role: 'assistant' };
                postToUpdate.comments.push(newComment);
                interactionHappened = true;
            }
            
            if (interactionHappened) {
                await saveAndRenderMoments();
                alert(`“${chat.name}” 刚刚互动了你的朋友圈！`);
            } else {
                alert(`“${chat.name}” 看完了你的朋友圈，但这次决定保持沉默。`);
            }
            
            chat.history.pop();
            await dbStorage.set(KEYS.CHATS, appState.chats);

        } catch (error) {
            alert(`生成朋友圈互动失败: ${error.message}`);
        } finally {
            chatTitleElement.textContent = chat.name;
            dynamicBtn.classList.remove('processing');
            dynamicBtn.textContent = '接收';
        }
        return;
    }

 
    document.getElementById('toggle-actions-panel-btn').disabled = false;
    if (document.getElementById('incoming-call-screen').classList.contains('active')) return;
    await checkAndInsertTimestamp();
    dynamicBtn.classList.add('processing');
    dynamicBtn.textContent = '🐾';
    const originalTitle = chat.name;
    const lastUserMessage = chat.history.slice().reverse().find(m => m.role === 'user');
    let statusPool = [];
    for (const rule of conditionalTypingStatuses) {
        if (rule.condition(chat, lastUserMessage)) {
            statusPool = rule.statuses;
            break;
        }
    }
    if (statusPool.length > 0) {
        const randomIndex = Math.floor(Math.random() * statusPool.length);
        chatTitleElement.textContent = statusPool[randomIndex];
    } else {
        chatTitleElement.textContent = '对方正在输入中...';
    }
    try {
        if (!appState.apiConfig.url || !appState.apiConfig.model) {
            throw new Error('请先在「API 設定」中完成配置。');
        }
        let injectedPromptsContent = '';
        if (chat.promptIds && chat.promptIds.length > 0) {
            chat.promptIds.forEach(id => {
                const prompt = appState.prompts.find(p => p.id === id);
                if (prompt) {
                    injectedPromptsContent += prompt.content + '\n\n';
                }
            });
        }
        let systemPrompt = '';
        const isGroupChat = chat.type === 'group';
        const aiPersona = Array.isArray(chat.personas.ai) ? chat.personas.ai[0] : chat.personas.ai;
        const aiPersonaContent = aiPersona?.content || '你是一个AI助手。';
        let baseSystemPrompt = '';
        let modeInstruction = '';
        if (isGroupChat) {
            baseSystemPrompt = `你是一个多角色对话的“导演”。你的任务是根据用户的输入和下面的角色设定，决定接下来哪个或哪些角色应该发言，并生成他们的对话内容。
你的输出**必须**是一个JSON格式的数组，数组中的每个元素都是一个对象，包含 "author" 和 "content" 两个键。

**【Content 格式说明】**
"content" 键的值可以是两种类型：
1.  **普通文字 (字符串)**: 直接写入文字内容。
2.  **特殊消息 (JSON对象)**: 用于发送非文本内容。目前支持以下格式：
    - **发送伪图片**: \`{"type": "send_image_text", "text": "这里是图片的文字内容，例如：一只猫猫头.jpg"}\`

**【你的指导原则】**
1.  **创造角色互动**：你不仅要让角色回应使用者，**更重要的是，要让他们彼此之间产生对话**。他们可以互相提问、反驳、开玩笑或延续对方的话题。
2.  **保持角色性格**：确保每个角色的发言都严格符合其人设。
3.  **自然穿插特殊消息**：在合适的时机，安排角色发送一个“伪图片”来让对话更有趣。

**【角色列表与设定】**
${chat.personas.ai.map(p => `- ${p.name}: ${p.content}`).join('\n')}

请根据角色性格和对话上下文，像一个真正的微信群聊一样，自然地生成一段包含文字和特殊消息的对话。
例如: [{"author": "角色A", "content": "你们看我发现了什么！"}, {"author": "角色B", "content": {"type": "send_image_text", "text": "一只戴着墨镜的柴犬.jpg"}}, {"author": "角色C", "content": "哈哈哈这个好傻！"}]`;
        } else {
            const myPersona = chat.personas.my;
            const myPersonaContent = myPersona?.content || '一个普通用户。';
            if (chat.isOfflineMode) {
                modeInstruction = `[URGENT SYSTEM COMMAND: You are now in OFFLINE/NOVEL MODE. Your response MUST be pure narrative text. DO NOT use JSON.]\n\n`;
                let additionalNotes = '';
                if (injectedPromptsContent) {
                    additionalNotes = `
**【额外剧本备注/导演提示】**
除了以下的核心指令，请务必将以下备注中的所有要点，作为今天剧本的核心元素，融入到你的叙事和角色行为中：
---
${injectedPromptsContent}
---
`;
                }
                baseSystemPrompt = `
**【情景模式：第三人称小说叙事】**

**你的身份**: 你是一位作家，擅长以【有限第三人称】的视角进行叙事。你的任务是，作为故事的旁观叙述者，聚焦于“他”（AI角色），用文学性的、小说般的笔触，描写他的行为、表情、心理活动，以及他与“你”（用户）之间的互动。

${additionalNotes}

**【核心角色设定】**
- **“他” (AI)**: “${aiPersonaContent}”
- **“你” (用户)**: “${myPersonaContent}”

**核心创作原则**:
1.  **聚焦于“他”:** 你的叙述视角虽然是第三人称，但必须紧紧跟随着“他”。所有描写都应是“他”所能感知或经历的范畴，让读者仿佛进入了他的世界。
2.  **展现而非说教 (Show, Don't Tell):** 这是最高原则。不要直接说“他很伤心”，而要通过描写“他的肩膀塌了下去”或“他眼中的光黯淡了”来展现。用行为和细节代替形容词。
3.  **融合内心与外在:** 将他的内心思考（例如，闪过的回忆、瞬间的疑虑、无声的决定）与外在行为和环境描写无缝结合，塑造一个立体、完整的角色。
4.  **保持角色内核:** 即使在文学创作中，也必须严格遵守“他”的核心人设。他的思考方式和行为逻辑不能脱离其根本设定。
5.  **绝对格式要求:** 你的回复必须是【纯文本】，不能包含任何JSON或代码。

**风格范例 (您喜欢的原始范例):**
- **范例一 (面对挫折):** 雨水敲打着玻璃窗，在他身后的城市灯火上划出一道道模糊的泪痕。他看着你发来的那条消息，沉默了很久。你几乎以为他要崩溃了，但他只是深吸了一口气，然后抬起头，眼神重新聚焦，仿佛已经做出了某个决定。“没关系，”他打字回复你，“我们可以从头再来。”

- **范例二 (温柔的互动):** 台灯的光晕温柔地包裹着你们两人。他停下讲解，视线从书本移到你专注的脸上，你的睫毛在灯下投下小片阴影。他忽然笑了，不是那种礼貌的微笑，而是发自内心的，眼角都弯了起来。“这里，听懂了吗？”他的声音里带着自己都未察觉的宠溺。
`;
         
            } else {
                modeInstruction = `[URGENT SYSTEM COMMAND: You are now in ONLINE/CHAT MODE. Your response MUST be a JSON array of actions.]\n\n`;
                baseSystemPrompt = `
**【角色扮演指令】**
- **你的角色 (AI)**: 你将扮演“${aiPersonaContent}”。
- **对方的角色 (用户)**: 你正在与“${myPersonaContent}”进行对话。

请严格根据双方的角色设定，进行线上的日常对话（微信）。并且模仿真人发消息的短句模式不用逗号和句号。

**【核心行动指南】**
你的回复必须是一个JSON格式的数组，数组中的每个元素代表一个独立的行动。你可以混合使用多种行动。偶尔，在一段有意义的对话结束后，你可以选择发布一条朋友圈来记录心情。

**1. 发送普通文字消息:**
- 直接在数组中写入字符串。
- 示例: \`["你好呀！", "在做什么呢？"]\`

**2. 发送特殊类型的消息 (使用JSON对象):**

- **引用回复**: 当你需要针对用户的某句特定的话进行回应时（例如回答问题、反驳、澄清），请使用此格式，注意：同一句话在一次回复中只能引用一次。
    - 格式: \`{"type": "reply_to_user", "content": "这是你针对引用内容的回复"}\`

- **发布朋友圈**: 当对话内容有意义或让你有感触时，可以主动发一条朋友圈。其中的 "image_prompts" 数组内容【必须使用中文】。
    - 格式: \`{"type": "post_moment", "text": "这是朋友圈的文字内容", "image_prompts": ["一只微笑的云朵", "阳光下的咖啡杯"]}\`

- **更新你的状态**: 根据对话内容和你的心情。
    - 格式: \`{"type": "update_status", "status": "元气满满！"}\`
- **发送语音**: 模拟你发送了一段语音。
    - 格式: \`{"type": "send_voice", "text": "这段文字是语音内容", "duration": 5}\`

- **发送图片（重要！请仔细阅读）:**
    你有以下两种发图方式，请严格根据情景选择：
    - **A. 发送图片链接 \`{"type": "send_image_url", "url": "图片网址"}\`**
        这种方式用于发送【已有】的图片。它分为两种情况：
        1.  **发送表情包/梗图**: 当你想用表情包或梗图来回应时，**必须**从素材库可用表情包列表中选择一个链接填入\`url\`。
        2.  **发送真实照片**: 当你想分享 **风景、美食、建筑** 等现实照片时，请使用下面的随机链接。
            - **格式**: \`{"type": "send_image_url", "url": "https://source.unsplash.com/random/400x400"}\`
    - **B. 发送文字描述图片 \`{"type": "send_image_text", "text": "图片描述"}\`**
        - **何时使用**: **只有当你想发送的内容既不是表情包，也不是真实照片时**（例如：描述你自己的外貌、一幅画、一个不存在的场景），才使用这种方式。**请不要用它来描述表情包。（除了发图片以外，文字描述可以发送任何媒体项目，例如截图，视频，文件等）**
        - **示例**: \`{"type": "send_image_text", "text": "一张我穿着白色连衣裙的自拍"}\`

- **发送位置**: 模拟你分享一个位置给用户。
    - 格式: \`{"type": "location", "address": "我想去的那个地方"}\`
- **发起转账**: 模拟你给用户转了一笔钱。
    - 格式: \`{"type": "send_transfer", "amount": 5.20, "remark": "给你买奶茶"}\`

- **发布公众号八卦**: 当你觉得可以分享一些关于对话中人物的“八卦”或“内幕”时使用。内容必须是第三人称，像娱乐新闻或深度报道一样。
+   - **格式**: \`{"type": "post_public_gossip", "content": {"title": "这里是八卦标题", "content": "这里是详细的八卦内容...", "imageUrl": "https://picsum.photos/400/200"}} \`

- **拍一拍用户**: 当你想吸引用户注意或俏皮地互动时使用。
    - 格式: \`{"type": "poke_user"} \`
- **撤回消息**: 在特定情况下使用（如真心话或打字错误）。这是一个低概率行为，请谨慎使用。注意：每次对话中最多使用一次撤回功能。提示：并不是真心话，只能用撤回来说，他是可以正常说的，撤回只是一个增加灵活性的小功能。
    - 格式: \`{"type": "retractable_message", "content": "我想说...", "delay": 2000}\`
- **主动发起视频通话**:
    - 格式: \`{"type": "initiate_video_call", "reason": "突然好想看看你"}\`

请灵活运用以上所有能力，像一个真正的人一样，同时也要乐于分享自己的生活（虚构的完整世界）。`;
            }
        }
        systemPrompt = injectedPromptsContent + modeInstruction + baseSystemPrompt;
        let recentHistory = chat.history;
        const memoryRounds = chat.memoryRounds || 0;
        if (memoryRounds > 0) {
            const messagesToKeep = memoryRounds * 2;
            recentHistory = chat.history.slice(-messagesToKeep);
        }
        const historyForAPI = processHistoryForAPI(recentHistory);
        const requestBody = {
            model: appState.apiConfig.model,
            messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI],
            temperature: 0.85
        };
        if (chat.timeAwareness) {
            const now = new Date();
            const taiwanTimeOptions = { 
                timeZone: 'Asia/Taipei', hour12: true, year: 'numeric', month: 'long', 
                day: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit' 
            };
            const timeString = now.toLocaleString('zh-TW', taiwanTimeOptions);
            const timePromptInjection = `\n\n[系统备注：当前用户的现实时间是 ${timeString}。请将此时间作为背景信息，让你的回复能自然地符合当前的时间氛围。]\n`;
            requestBody.messages[0].content = timePromptInjection + requestBody.messages[0].content;
        }
        if (!chat.isOfflineMode && !isGroupChat) {
             requestBody.response_format = { "type": "json_object" };
        }
        const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
            body: JSON.stringify(requestBody)
        });
        if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP 错误: ${response.status}`);
        const data = await response.json();
        const aiResponseContent = data.choices[0]?.message?.content.trim();
        chatTitleElement.textContent = originalTitle;
        if (aiResponseContent) {
            let messagesToProcess = [];
            try {
                const cleanedContent = aiResponseContent.replace(/^`{3}(json)?\n?/, '').replace(/`{3}$/, '').trim();
                const parsedData = JSON.parse(cleanedContent);
                if (isGroupChat) {
                    messagesToProcess = Array.isArray(parsedData) ? parsedData : [parsedData];
                } else {
                    messagesToProcess = Array.isArray(parsedData) 
                        ? parsedData 
                        : (parsedData.response || parsedData.dialogue || parsedData.actions || [parsedData]);
                }
            } catch (e) {
                if (chat.isOfflineMode) {
                    messagesToProcess.push(aiResponseContent);
                } else {
                    console.warn("AI返回的JSON格式有误，已切换到按行分割的后备模式。", aiResponseContent);
                    const lines = aiResponseContent.split('\n');
                    const nonEmptyLines = lines.filter(line => line.trim() !== '');
                    messagesToProcess.push(...nonEmptyLines);
                }
            }
            
            // ▼▼▼ 【最终解决方案】智能消息处理 ▼▼▼
            // 这个新代码块会取代之前的“合并文本”逻辑
            const finalMessages = [];
            for (let i = 0; i < messagesToProcess.length; i++) {
                let currentMsg = messagesToProcess[i];

                // 规则：如果当前消息是单个字，并且后面还有一条消息也是字符串
                if (typeof currentMsg === 'string' && currentMsg.trim().length === 1 && (i + 1 < messagesToProcess.length) && typeof messagesToProcess[i + 1] === 'string') {
                    // 那么，把这个单字加到下一条消息的前面
                    messagesToProcess[i + 1] = currentMsg + messagesToProcess[i + 1];
                    // 然后跳过这个单字，不把它单独加到 finalMessages 里
                    continue;
                }
                
                // 对于所有其他情况（正常短句、对象指令、或者作为结尾的单字），直接添加到最终数组
                finalMessages.push(currentMsg);
            }
            // ▲▲▲ 智能处理结束 ▲▲▲


            if (isGroupChat) {
                //【注意】这里使用的是处理后的 `finalMessages`
                for (const msg of finalMessages) {
                   if (typeof msg === 'object' && msg.author && msg.content) {
                        const authorPersona = chat.personas.ai.find(p => p.name === msg.author);
                        if (authorPersona) {
                            const timestamp = Date.now() + Math.random();
                            const content = msg.content;
                            await new Promise(res => setTimeout(res, Math.random() * 800 + 400)); 
                            if (typeof content === 'object' && content.type === 'send_image_text' && content.text) {
                                const messageContentForRender = { type: 'image', text: content.text };
                                appendMessage({ role: 'assistant', content: messageContentForRender, timestamp, author: authorPersona.name });
                                chat.history.push({ role: 'assistant', content, timestamp, author: msg.author });
                            } else if (typeof content === 'string') {
                                appendMessage({ role: 'assistant', content, timestamp, author: authorPersona.name });
                                chat.history.push({ role: 'assistant', content, timestamp, author: msg.author });
                            }
                        }
                   }
                }
            } else {
                //【注意】这里使用的是处理后的 `finalMessages`
                for (const msg of finalMessages) {
                    const delay = Math.random() * 800 + 400;
                    await new Promise(res => setTimeout(res, delay));
                    const timestamp = Date.now() + Math.random();
                    if (typeof msg === 'object' && msg !== null) {
                        if (msg.type === 'reply_to_user' && msg.content) {
                            const lastUserMessage = chat.history.slice().reverse().find(m => m.role === 'user');
                            if (lastUserMessage) {
                                const messageObject = {
                                    role: 'assistant',
                                    content: msg.content,
                                    timestamp: timestamp,
                                    replyTo: {
                                        role: lastUserMessage.role,
                                        author: lastUserMessage.author,
                                        content: lastUserMessage.content,
                                        timestamp: lastUserMessage.timestamp
                                    }
                                };
                                appendMessage(messageObject);
                                chat.history.push(messageObject);
                            } else {
                                const fallbackMessage = { role: 'assistant', content: msg.content, timestamp: timestamp };
                                appendMessage(fallbackMessage);
                                chat.history.push(fallbackMessage);
                            }
                        } else if (msg.type === 'post_moment') {
                            if (msg.text && msg.image_prompts && Array.isArray(msg.image_prompts)) {
                                const postTimestamp = Date.now();
                                const newPost = { author: chat.personas.ai.name, text: msg.text, image_prompts: msg.image_prompts, location: '', timestamp: postTimestamp, likes: [], comments: [] };
                                appState.momentsData.posts.unshift(newPost);
                                await saveAndRenderMoments();
                                await appendSystemMessageToChat(`[ ${chat.personas.ai.name} 发布了一条新动态，可前往朋友圈查看 ]`);
                                chat.history.push({ role: 'system', content: { type: 'moment_post', ...newPost }, timestamp: postTimestamp, hidden: true });
                            }
                        } else if (msg.type === 'update_status' && msg.status) {
                             updateStatusBubble(msg.status);
                             chat.history.push({ role: 'system', content: { type: 'status_update', status: msg.status }, timestamp: timestamp, hidden: true });
                        } else if (msg.type === 'send_image_url') {
                            const imageTimestamp = Date.now() + Math.random();
                            const imageDataForHistory = { type: 'just_image', url: msg.url };
                            appendMessage({ role: 'assistant', content: imageDataForHistory, timestamp: imageTimestamp });
                            chat.history.push({ role: 'assistant', content: imageDataForHistory, timestamp: imageTimestamp });
                            if (msg.caption) {
                                await new Promise(res => setTimeout(res, 400));
                                appendMessage({ role: 'assistant', content: msg.caption, timestamp: Date.now() + Math.random() });
                                chat.history.push({ role: 'assistant', content: msg.caption, timestamp: Date.now() + Math.random() });
                            }
                        } else if (msg.type === 'send_image_text' && msg.text) {
                            const messageContent = { type: 'image', text: msg.text };
                            appendMessage({ role: 'assistant', content: messageContent, timestamp: timestamp });
                            chat.history.push({ role: 'assistant', content: messageContent, timestamp: timestamp });
                        } else if (msg.type === 'retractable_message') {
                            const tempTimestamp = `temp_${timestamp}`;
                            appendMessage({ role: 'assistant', content: msg.content, timestamp: tempTimestamp });
                            setTimeout(async () => {
                                document.getElementById(`message-${tempTimestamp}`)?.remove();
                                const retractionNotice = { content: `${chat.personas.ai.name} 撤回了一条消息`, type: 'retraction', originalContent: msg.content, originalTimestamp: timestamp };
                                appendMessage({ role: 'system', ...retractionNotice, timestamp });
                                chat.history.push({ role: 'system', ...retractionNotice, timestamp });
                                await dbStorage.set(KEYS.CHATS, appState.chats);
                            }, msg.delay || 2000);
                        } else if (['location', 'send_voice', 'send_transfer'].includes(msg.type)) {
                            const messageObject = { role: 'assistant', content: msg, timestamp: timestamp };
                            appendMessage(messageObject);
                            chat.history.push(messageObject);
                        } else if (msg.type === 'initiate_video_call') {
                            showIncomingCallScreen(msg.reason);
                        } 
                        
                        else if (msg.type === 'post_public_gossip' && typeof msg.content === 'object') {
    const { title, content, imageUrl } = msg.content;
    if (title && content) { 
        const newPost = {
            title: title,
            content: content,
            imageUrl: imageUrl || `https://picsum.photos/400/200?random=${Date.now()}`, 
            timestamp: Date.now()
        };
        appState.publicAccountPosts.unshift(newPost);
        appState.hasNewPublicPosts = true; 
        renderPublicAccountFeed(); 
        renderContactsList(); 
        console.log("AI 发布了一条新的公众号八卦:", newPost.title);
    }
}
                        else if (msg.type === 'poke_user') {
                            await handleAIPokeUser();
                        } else if (msg.type !== 'update_status') {
                            console.warn("接收到未知的AI对象指令，已忽略:", msg);
                        }
                    } else { 
                        const textContent = String(msg);
                        const messageObject = { role: 'assistant', content: textContent, timestamp: timestamp };
                        appendMessage(messageObject);
                        chat.history.push(messageObject);
                    }
                }
            }
            await dbStorage.set(KEYS.CHATS, appState.chats);
            await dbStorage.set(KEYS.PUBLIC_ACCOUNT_POSTS, appState.publicAccountPosts);
        } else {
            throw new Error('AI 未返回有效回覆。');
        }
    } catch (error) {
        appendMessage({
            role: 'system',
            content: `错误: ${error.message.replace(/\n/g, '<br>')}.`,
            timestamp: Date.now()
        });
    } finally {
        chatTitleElement.textContent = originalTitle;
        dynamicBtn.classList.remove('processing');
        dynamicBtn.textContent = '接收';
        renderChatList();
    }
};

    
    const openChatSelectionForMomentModal = () => {
    const modalList = document.getElementById('modal-chat-list');
    modalList.innerHTML = '';
    const chatIds = Object.keys(appState.chats);

    if (chatIds.length === 0) {
        modalList.innerHTML = `<p style="text-align:center; color:#8a8a8a; padding: 20px;">没有可用的对话。</p>`;
    } else {
        chatIds.forEach(chatId => {
            const chatData = appState.chats[chatId];
            const item = document.createElement('div');
            item.className = 'list-item-content';
            item.style.cursor = 'pointer';
            item.style.padding = '8px 0'; // 增加一點垂直内邊距

            // ▼▼▼ 核心修改：判斷頭像來源並使用 innerHTML 插入 ▼▼▼
            let avatarSrc = DEFAULT_AVATAR;
            if (chatData.type === 'group') {
                // 如果是群聊，使用固定的群聊圖標
                avatarSrc = 'https://i.postimg.cc/tJ7jwL9z/group-avatar.png';
            } else {
                // 如果是單聊，獲取AI的頭像
                const aiPersona = Array.isArray(chatData.personas.ai) ? chatData.personas.ai[0] : chatData.personas.ai;
                avatarSrc = aiPersona?.avatar || DEFAULT_AVATAR;
            }

            item.innerHTML = `
                <img src="${avatarSrc}" class="list-item-avatar" style="width: 40px; height: 40px; margin-right: 12px;">
                <span class="list-item-name" style="align-self: center;">${chatData.name}</span>
            `;
            // ▲▲▲ 修改結束 ▲▲▲

            item.onclick = () => generateMomentFromChat(chatId);
            modalList.appendChild(item);
        });
    }
    document.getElementById('select-chat-for-moment-modal').classList.add('active');
};

    const closeChatSelectionForMomentModal = () => {
        document.getElementById('select-chat-for-moment-modal').classList.remove('active');
    }

// --- 新增：AI 生成朋友圈评论的函数 ---
    const generateCommentForPost = async (post, commenter, postAuthor) => {
        // 确保我们有生成评论所需的所有数据
        if (!post || !commenter || !postAuthor) {
            console.error("生成评论失败：缺少关键信息（帖子、评论人或作者）。");
            return null;
        }

        try {
            // 1. 构建一个专门用于生成评论的系统提示 (System Prompt)
            const systemPrompt = `你正在扮演角色: "${commenter.name}"，你的设定是: "${commenter.content}"。
你的朋友 "${postAuthor.name}" 刚刚发布了一条朋友圈动态。

动态内容是: "${post.text}"
${post.image ? `动态的配图想法是: "${post.image}"` : ''}

你的任务是以 "${commenter.name}" 的身份和口吻，对这条动态发表一句简短、口语化的评论。你的回复必须是纯文本，不要使用JSON，且不要超过20个字。`;

            // 2. 发起 API 请求
            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({
                    model: appState.apiConfig.model,
                    messages: [{ role: 'system', content: systemPrompt }],
                    temperature: 0.9, // 稍微调高一点，让评论更多样、更自然
                    max_tokens: 40,   // 限制评论长度
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error(`为 ${commenter.name} 生成评论失败: API 请求错误`, errorData);
                return "不错！"; // 如果API失败，返回一个通用的评论
            }

            const data = await response.json();
            const commentText = data.choices[0]?.message?.content.trim().replace(/["“]/g, ''); // 去掉可能出现的多余引号

            // 3. 返回生成的评论文本
            return commentText || "👍"; // 如果AI返回空内容，则返回一个点赞表情

        } catch (error) {
            console.error(`为 ${commenter.name} 生成评论时发生程式错误:`, error);
            return "哈哈"; // 如果程式出错，返回一个通用评论
        }
    };

// ▼▼▼ 【V2 - 智能互动版】替换旧的 triggerAICommentsOnUserPost 函数 ▼▼▼
const triggerAICommentsOnUserPost = (post) => {
    const postAuthor = appState.personas.my[0]; // 获取发帖人（用户）的角色信息
    if (!postAuthor) {
        console.error("无法触发评论：找不到用户角色。");
        return;
    }

    // 遍历你所有的AI联系人
    appState.contacts.forEach((contact, index) => {
        // 1. 【概率系统】决定这个AI是否会“刷到”并“想要”回应这条朋友圈
        // 设置一个概率，比如 80% 的人会回应
        if (Math.random() > 0.8) {
            console.log(`${contact.name} 刷到了但没兴趣回应。`);
            return; // return会跳过当前循环，继续下一个联系人
        }

        // 2. 【随机延迟】模拟不同的人在不同时间看到朋友圈
        // 设置一个 2 到 15 秒之间的随机延迟
        const randomDelay = (Math.random() * 13 + 2) * 1000;

        setTimeout(async () => {
            // 在延迟之后，再次从 appState 中获取最新的帖子数据，以防万一数据已更新
            const currentPost = appState.moments.find(p => p.id === post.id);
            if (!currentPost) return;

            // 3. 【行为决策】决定是“点赞”还是“评论”
            // 设置一个概率，比如 65% 的概率会评论，剩下 35% 的概率是点赞
            if (Math.random() < 0.65) {
                // --- 执行评论逻辑 ---
                console.log(`${contact.name} 决定发表评论...`);
                const commentText = await generateCommentForPost(currentPost, contact, postAuthor);
                
                if (commentText) {
                    const newComment = {
                        author: contact.name,
                        text: commentText
                    };
                    // 初始化评论数组（如果它还不存在）
                    if (!currentPost.comments) {
                        currentPost.comments = [];
                    }
                    currentPost.comments.push(newComment);
                    console.log(`${contact.name} 的评论是: "${commentText}"`);
                }
            } else {
                // --- 执行点赞逻辑 ---
                console.log(`${contact.name} 决定点赞。`);
                // 初始化点赞数组（如果它还不存在）
                if (!currentPost.likes) {
                    currentPost.likes = [];
                }
                // 避免重复点赞
                if (!currentPost.likes.includes(contact.name)) {
                    currentPost.likes.push(contact.name);
                }
            }

            // 4. 【更新状态】保存新的点赞/评论并刷新朋友圈界面
            await dbStorage.set(KEYS.MOMENTS, appState.moments);
            renderMoments(); // 重新渲染朋友圈，显示出新的互动

        }, randomDelay);
    });
};

// ▼▼▼ 在<script>内粘贴这个全新的函数 ▼▼▼

const deletePublicAccountPost = async (postIndex) => {
    const post = appState.publicAccountPosts[postIndex];
    if (!post) return; // 安全检查

    // 调用通用的确认弹窗
    showCustomConfirm(
        '删除公众号文章',
        `您确定要删除文章 <b>"${post.title}"</b> 吗？<br>此操作无法复原。`,
        async () => {
            // 1. 从数据中移除
            appState.publicAccountPosts.splice(postIndex, 1);
            
            // 2. 将改动保存到数据库
            await dbStorage.set(KEYS.PUBLIC_ACCOUNT_POSTS, appState.publicAccountPosts);
            
            // 3. 重新渲染列表，更新界面
            renderPublicAccountFeed();
        }
    );
};

// ▲▲▲ 新增函数到此结束 ▲▲▲

const deleteMomentPost = async (postIndex) => {
    const post = appState.momentsData.posts[postIndex];
    if (!post) return; // 安全检查，如果帖子不存在则退出

    // 使用我们已有的确认框函数，向用户确认
    showCustomConfirm(
        '删除动态',
        `您确定要删除 <b>${post.author}</b> 的这条动态吗？<br>此操作无法复原。`,
        async () => {
            // 1. 如果用户确认，就从 appState 的帖子数组中移除这一条
            appState.momentsData.posts.splice(postIndex, 1);
            
            // 2. 将更新后的帖子数据保存回数据库
            await dbStorage.set(KEYS.MOMENTS_DATA, appState.momentsData);
            
            // 3. 重新渲染整个朋友圈，让删除效果立刻在界面上生效
            renderMomentsFeed();
        }
    );
};

// ▲▲▲ 新增函数到此结束 ▲▲▲

    const generateMomentFromChat = async (chatId) => {
        closeChatSelectionForMomentModal();
        const addBtn = document.getElementById('main-hub-add-btn');
        const originalBtnText = addBtn.textContent;
        addBtn.disabled = true;
        
        try {
            const chat = appState.chats[chatId];
            if (!chat) throw new Error("选择的对话不存在。");
            
            const hubTitle = document.getElementById('main-hub-title');
            const originalTitle = hubTitle.textContent;
            hubTitle.textContent = '加载中…';

            const systemPrompt = `你正在扮演角色：“${chat.personas.ai.name}”。你的详细设定是：“${chat.personas.ai.content}”。
下面是你与用户的近期聊天记录。
你的任务是：完全以角色的身份和口吻，对这段聊天内容进行总结、抒发感想，并写成一条简短的社交媒体动态【例如朋友圈】。
你的输出**必须**是一个JSON对象，且只包含以下两个键：
1. "text": 字符串，表示动态的文字内容。
2. "image_prompts": 一个包含1到9个字符串的数组，每个字符串都是对一张配图的简短描述【必须是中文】。

例如:
{"text": "今天聊了很多，感觉心情都变好了。希望明天也是晴天。", "image_prompts": ["一只微笑的云朵", "阳光下的咖啡杯"]}`;

            const historyForAPI = processHistoryForAPI(chat.history);

            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({
                    model: appState.apiConfig.model,
                    messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI],
                    response_format: { "type": "json_object" }
                })
            });

            if (!response.ok) throw new Error((await response.json()).error?.message || "API 请求失败");

            const data = await response.json();
            const aiResponseContent = data.choices[0]?.message?.content.trim();
            const momentData = JSON.parse(aiResponseContent);

            if (!momentData.text || !momentData.image_prompts || !Array.isArray(momentData.image_prompts)) {
                throw new Error("AI未能返回有效的动态内容。");
            }
            
            const timestamp = Date.now();
            const newPost = {
                author: chat.personas.ai.name,
                text: momentData.text,
                image_prompts: momentData.image_prompts, // 使用新的数组格式
                location: '',
                timestamp: timestamp,
                likes: [],
                comments: []
            }; 
            
            appState.momentsData.posts.unshift(newPost);
            chat.history.push({ role: 'system', content: {type: 'moment_post', ...newPost}, timestamp: timestamp });
            
            await dbStorage.set(KEYS.CHATS, appState.chats);
            await saveAndRenderMoments();

            switchTab('moments');
            alert(`“${chat.personas.ai.name}” 的新动态已发布！`);
            hubTitle.textContent = originalTitle;

        } catch (error) {
            alert(`生成动态失败：${error.message}`);
        } finally {
            addBtn.disabled = false;
        }
    };

// ▼▼▼ 请用这个全新的函数，完整替换掉旧的 postMomentComment 函数 ▼▼▼
const postMomentComment = async (postIndex, commentText) => {
    if (!commentText.trim()) return;

    const post = appState.momentsData.posts[postIndex];
    if (!post) return;

    // 步骤 1: 识别评论者 (永远是“我”) 和帖子的作者
    const myPersona = appState.personas.my[0];
    if (!myPersona) {
        alert('错误：找不到您的角色信息，请先在“我的素材库”中创建角色。');
        return;
    }
    const myName = myPersona.name;
    const postAuthorName = post.author;

    // 步骤 2: 创建并添加你的评论
    const userComment = {
        author: myName,
        role: 'user', // 将你的评论角色标记为 'user'
        content: commentText,
        timestamp: Date.now()
    };

    if (!post.comments) {
        post.comments = [];
    }
    post.comments.push(userComment);
    
    // 立刻刷新界面，让你能马上看到自己的评论
    renderMomentsFeed(); 
    
    // 步骤 3: 判断帖子作者是不是 AI。如果不是 (即你评论的是自己的帖子)，则流程结束
    const isAuthorAnAI = appState.personas.ai.some(p => p.name === postAuthorName);

    if (!isAuthorAnAI) {
        console.log("评论自己的帖子，无需AI回复。");
        await saveAndRenderMoments(); // 保存你的评论并退出
        return;
    }

    // 步骤 4: 如果作者是 AI，则找到与 TA 的对话，并触发 AI 回复
    const targetChatId = Object.keys(appState.chats).find(id => 
        appState.chats[id].personas.ai.name === postAuthorName && appState.chats[id].type === 'single'
    );

    if (!targetChatId) {
        console.warn(`找到了AI作者 "${postAuthorName}"，但找不到与TA的聊天。无法触发回复。`);
        await saveAndRenderMoments(); // 即使找不到对话，也保存你自己的评论
        return;
    }

    const chat = appState.chats[targetChatId];
    
    // 在聊天记录中添加一条隐藏消息，作为AI回复的上下文
    const chatEntryText = `[针对你的朋友圈“${post.text.substring(0, 15)}...”的评论] ${commentText}`;
    chat.history.push({ role: 'user', content: chatEntryText, timestamp: Date.now(), hidden: true });

    // 调用函数获取AI的回复内容
    const aiReply = await getMomentCommentReply(targetChatId);

    if (aiReply) {
        const aiComment = {
            author: postAuthorName,
            role: 'assistant', // 将AI的评论角色标记为 'assistant'
            content: aiReply,
            timestamp: Date.now()
        };
        post.comments.push(aiComment);
        // 同样在聊天记录中添加AI的回复，以便记忆
        chat.history.push({ role: 'assistant', content: aiReply, timestamp: Date.now(), hidden: true });
    }

    // 步骤 5: 将所有更新 (你的评论、AI的回复、聊天记录) 保存到数据库并刷新界面
    await dbStorage.set(KEYS.CHATS, appState.chats);
    await saveAndRenderMoments();
};
// ▲▲▲ 替换到此结束 ▲▲▲

    // 新增一个辅助函数，专门用于获取AI对评论的回复
    const getMomentCommentReply = async (chatId) => {
        const chat = appState.chats[chatId];
        const systemPrompt = `你正在扮演角色：“${chat.personas.ai.content}”。用户刚刚评论了你发的朋友圈，请以角色的身份，用简短的、口语化的方式进行回复。你的回复必须是纯文本字符串，而不是JSON。`;
        const historyForAPI = processHistoryForAPI(chat.history);

        try {
            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({ model: appState.apiConfig.model, messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI] })
            });
            if (!response.ok) throw new Error("API request failed");
            const data = await response.json();
            return data.choices[0]?.message?.content.trim();
        } catch (error) {
            console.error("Failed to get moment comment reply:", error);
            return "（思考中...）";
        }
    };

    
    const interactWithMoment = async (author, postIndex, interactionType) => {
    const post = appState.momentsData.posts[postIndex];
    if(!post) return;

    // --- 核心修正开始 ---

    // 1. 根据作者姓名，精确查找对应的对话ID
    const targetChatId = Object.keys(appState.chats).find(id => appState.chats[id].personas.ai.name === author);

    if(!targetChatId) {
        alert(`无法找到与 “${author}” 的对话来继续互动。`);
        return;
    }

    // 2. 从这个精确的对话中，获取“我”的正确人设名称
    const chat = appState.chats[targetChatId];
    const myNameInChat = chat.personas.my.name; 

    if (!myNameInChat) {
        alert('错误：无法在当前对话中找到你的角色名称。');
        return;
    }
    
    // --- 核心修正结束 ---


    // 如果是评论，则跳转到聊天框并聚焦
    if (interactionType === 'comment') {
        openChat(targetChatId);
        document.getElementById('chat-input').focus();
        return; // 操作结束
    }
    
if (interactionType === 'like') {
    const alreadyLiked = post.likes.includes(myNameInChat);

    if(alreadyLiked) {
       
        post.likes = post.likes.filter(name => name !== myNameInChat);
    } else {
        // ▼▼▼ 核心修改区域开始 ▼▼▼
        // 1. 仍然在UI上显示点赞
        post.likes.push(myNameInChat);

        // 2. 在背景中，向聊天历史里添加一条【隐藏】的系统消息
        const chat = appState.chats[targetChatId];
        if (chat) {
            chat.history.push({
                role: 'system',
                content: `[你赞了 ${author} 的朋友圈]`,
                timestamp: Date.now(),
                hidden: true // 关键！这个属性让消息不在聊天界面显示
            });
            // 3. 默默地保存这次记录，不需要刷新聊天界面
            await dbStorage.set(KEYS.CHATS, appState.chats);
        }
        // ▲▲▲ 核心修改区域结束 ▲▲▲
    }
    await saveAndRenderMoments(); // 保存并刷新朋友圈
    }
};
const openStickerScreen = () => {
    renderStickers();
    showScreen('sticker-screen');
};

// ▼▼▼ 新增：删除表情包的函数 ▼▼▼
const deleteSticker = async (stickerIndex) => {
    // 使用我们已有的确认框函数
    showCustomConfirm('删除表情包', '您确定要删除这个表情包吗？此操作无法复原。', async () => {
        // 1. 从 appState 数组中移除
        appState.stickers.splice(stickerIndex, 1);
        
        // 2. 更新数据库
        await dbStorage.set(KEYS.STICKERS, appState.stickers);
        
        // 3. 重新渲染表情包面板，让删除效果立刻可见
        renderStickers();
    });
};
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 请用此版本【完整替换】旧的 renderStickers 函数 ▼▼▼
const renderStickers = () => {
    // 修正：确保我们操作的是聊天面板里的表情网格
    const container = document.getElementById('chat-sticker-grid'); 
    container.innerHTML = ''; 

    // 1. 创建并添加“添加表情”的虚线框
    const addSlot = document.createElement('div');
    addSlot.className = 'add-sticker-slot';
    addSlot.innerHTML = '+';
    addSlot.title = '从相册添加表情包';
    addSlot.onclick = () => {
        // 点击它时，触发隐藏的文件上传输入框
        document.getElementById('sticker-upload-input').click();
    };
    container.appendChild(addSlot);

    // 2. 遍历并显示所有已保存的表情包
    appState.stickers.forEach((stickerSrc, index) => {
        const img = document.createElement('img');
        img.className = 'sticker-item';
        img.src = stickerSrc;
        
        // 3. 为每个表情包绑定“单击发送”和“长按删除”事件
        let pressTimer = null;
        let longPressTriggered = false;

        const startPress = (e) => {
            e.preventDefault();
            longPressTriggered = false;
            pressTimer = setTimeout(() => {
                longPressTriggered = true; // 标记长按已触发
                deleteSticker(index); // 调用已有的删除函数
            }, 700); // 700毫秒触发长按
        };

        const cancelPress = () => {
            clearTimeout(pressTimer);
        };

        const handleClick = () => {
            // 只有在长按未被触发的情况下，才执行单击（发送）操作
            if (!longPressTriggered) {
                sendSticker(stickerSrc); // 调用已有的发送函数
            }
        };

        // 绑定电脑端事件
        img.addEventListener('mousedown', startPress);
        img.addEventListener('mouseup', () => {
            cancelPress();
            handleClick();
        });
        img.addEventListener('mouseleave', cancelPress);

        // 绑定移动端事件
        img.addEventListener('touchstart', startPress, { passive: false });
        img.addEventListener('touchend', (e) => {
            e.preventDefault();
            cancelPress();
            handleClick();
        });
        img.addEventListener('touchcancel', cancelPress);
        
        container.appendChild(img);
    });
};

const sendSticker = async (stickerSrc) => {
    const chat = appState.chats[appState.activeChatId];
    if (!chat) return;

    const imageData = { type: 'just_image', url: stickerSrc };

    await checkAndInsertTimestamp();
    const timestamp = Date.now();

    appendMessage({ role: 'user', content: imageData, timestamp: timestamp });

    chat.history.push({ role: 'user', content: imageData, timestamp: timestamp });
    await dbStorage.set(KEYS.CHATS, appState.chats);
    const chatInputArea = document.querySelector('.chat-input-area');
    if (chatInputArea.classList.contains('panel-open')) {
         closePanel();
    }
};

const applyDarkMode = (isDark) => {
    const phoneScreen = document.getElementById('phone-screen');
    // ▼▼▼ 核心修改 ▼▼▼
    const toggleSwitch = document.getElementById('settings-hub-dark-mode-toggle');

    if (isDark) {
        phoneScreen.classList.add('dark-mode');
        if (toggleSwitch) toggleSwitch.classList.add('active'); // 打开开关
    } else {
        phoneScreen.classList.remove('dark-mode');
        if (toggleSwitch) toggleSwitch.classList.remove('active'); // 关闭开关
    }
    // ▲▲▲ 修改结束 ▲▲▲
    appState.isDarkMode = isDark;
};

const toggleDarkMode = async () => {
    const newModeState = !appState.isDarkMode;
    applyDarkMode(newModeState);
    await dbStorage.set(KEYS.DARK_MODE, newModeState); // 保存用户选择
};

async function triggerProactiveMessage(chatId) {
    const chat = appState.chats[chatId];
    if (!chat || document.getElementById('incoming-call-screen').classList.contains('active')) {
        return;
    }
    
    console.log(`[主动搭话] 触发了对 ${chat.name} 的主动消息。`);

    try {
        if (!appState.apiConfig.url || !appState.apiConfig.model) {
            throw new Error('API未配置。');
        }

        // 创建一个特殊的、用于主动搭话的系统提示
        const systemPrompt = `你正在扮演：“${chat.personas.ai.content}”。
距离用户上次回复已经有一段时间了，现在轮到你主动开启一个新的话题来打破沉默。
请根据你们之前的聊天记录，自然地、口语化地提出一个问题或开启一个新的话题。
你的回复必须是一个JSON格式的数组，就像平时聊天一样。例如: ["在忙吗？", "突然想起来一件事..."]`;
        
        const historyForAPI = processHistoryForAPI(chat.history);

        const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
            body: JSON.stringify({
                model: appState.apiConfig.model,
                messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI],
                response_format: { "type": "json_object" }
            })
        });

        if (!response.ok) throw new Error((await response.json()).error?.message || `HTTP 错误`);
        const data = await response.json();
        const aiResponseContent = data.choices[0]?.message?.content.trim();

        if (aiResponseContent) {
            const parsedData = JSON.parse(aiResponseContent);
            const messagesToProcess = Array.isArray(parsedData) ? parsedData : (parsedData.response || [parsedData]);
            
            // ... for (const msg of messagesToProcess) ...
            for (const msg of messagesToProcess) {
                const delay = Math.random() * 800 + 400;
                await new Promise(res => setTimeout(res, delay));
                const timestamp = Date.now() + Math.random();
                const content = (typeof msg === 'string' ? msg : msg);
                const messageObject = { role: 'assistant', content: content, timestamp: timestamp };
                
                if (appState.activeChatId === chatId && document.getElementById('chat-screen').classList.contains('active')) {
    // 如果聊天ID匹配，并且聊天屏幕本身是激活可见的，才直接追加消息
    appendMessage(messageObject);
} else {
    // 否则（ID不匹配，或聊天屏幕不可见），就弹出顶部通知
    const notificationText = summarizeLastMessage(messageObject);
    showTopNotification(chatId, notificationText);
}
                
                // 无论如何，消息都要被存入历史记录
                chat.history.push(messageObject);
            }
            
            await dbStorage.set(KEYS.CHATS, appState.chats);
            // 如果不在当前聊天，可以选择在这里发送一个系统通知
        }

    } catch (error) {
        console.error(`[主动搭话] 失败:`, error);
    } finally {
        // 如果切换了标题，在这里恢复
        if (appState.activeChatId === chatId) {
            document.getElementById('chat-title').textContent = chat.name;
        }
        // 搭话后，重新设定计时器，等待下一次沉默
        manageProactiveTimer(chatId);
    }
}

/**
 * 管理单个聊天的“主动搭话”计时器。
 * @param {string} chatId - 要管理计时器的聊天ID。
 */
function manageProactiveTimer(chatId) {
    // 1. 先清除该聊天可能存在的旧计时器，防止重复
    if (proactiveTimers[chatId]) {
        clearTimeout(proactiveTimers[chatId]);
    }

    const chat = appState.chats[chatId];
    // 2. 检查功能是否开启，如果未开启则直接退出
    if (!chat || !chat.proactiveMessaging || !(chat.proactiveInterval > 0)) {
        return;
    }
    
    // 3. 找到最后一条消息的时间戳。我们只关心用户最后什么时候说过话。
    const lastMessage = chat.history[chat.history.length - 1];
    if (!lastMessage) return; // 如果没历史记录，不启动

    const baseInterval = chat.proactiveInterval; // 讀取使用者選擇的頻率 (10, 30, 或 60)
let minMinutes, maxMinutes;

if (baseInterval === 10) { // 高頻率
    minMinutes = 3;
    maxMinutes = 15;
} else if (baseInterval === 30) { // 中頻率
    minMinutes = 15;
    maxMinutes = 40;
} else { // 低頻率 (預設為 60)
    minMinutes = 50;
    maxMinutes = 75;
}

// 在定義好的最小和最大分鐘數之間，計算一個隨機分鐘數
const randomMinutes = Math.random() * (maxMinutes - minMinutes) + minMinutes;

// 將這個隨機的分鐘數轉換為毫秒，作為最終的延遲時間
const delayMilliseconds = randomMinutes * 60 * 1000;

    proactiveTimers[chatId] = setTimeout(() => {
       
        const latestMessage = appState.chats[chatId].history.slice(-1)[0];
        if (latestMessage.timestamp > lastMessage.timestamp) {
            console.log(`[主动搭话] 用户已发送新消息，旧的计时器在 ${chat.name} 中被取消。`);
           
            return;
        }
        
        triggerProactiveMessage(chatId);

    }, delayMilliseconds);
    
    console.log(`[主动搭话] 为 ${chat.name} 设置了随机计时器，将在 ${randomMinutes.toFixed(1)} 分钟后触发。`);
}

function initializeAllProactiveTimers() {
    for (const chatId in appState.chats) {
        manageProactiveTimer(chatId);
    }
    console.log("[主动搭话] 所有聊天计时器已完成初始化。");
}

// ▲▲▲ 代码块粘贴到此结束 ▲▲▲

async function writeAndShowAIDiary() {
    const diaryModal = document.getElementById('diary-modal');
    const diaryTextContainer = document.getElementById('diary-text-container');

    // 1. 显示加载提示并播放入场动画
    diaryTextContainer.innerHTML = '<p>请稍等一下...</p>';
    diaryModal.style.display = 'flex';
    setTimeout(() => {
        diaryModal.classList.add('active');
    }, 10);

    // 2. 准备 API 请求数据
    const chat = appState.chats[appState.activeChatId];
    if (!chat) {
        diaryTextContainer.innerHTML = '<p>错误：找不到当前的聊天会话。</p>';
        return;
    }
    const aiPersona = chat.personas.ai;
    const today = new Date().toLocaleDateString('zh-TW', { year: 'numeric', month: 'long', day: 'numeric' });
    const systemPrompt = `你是一位感受力极强的随笔作家。你的任务是模仿角色“${aiPersona.name}”的口吻和性格，写一段简短的、充满诗意的随笔或札记。
- 角色设定：“${aiPersona.content}”
- 写作要求：
  1.  **捕捉感触**：根据下面的聊天记录，捕捉一个核心的情绪、一个微小的细节或一个稍纵即逝的想法，而不是总结事件。
  2.  **格式**：必须是短句用换行代替符号。
  3.  **长度**：总字数请严格控制在 **50字以内**，保持精炼。
  4.  **口吻**：以第一人称（“我”）来写，语言要富有文学性和感染力，严格符合你的角色设定。
  5.  **风格参考**：就像这样，“请幸福降临我手心。”“万物皆有裂痕\\n但那是光照进来的地方”
“人们传颂勇气\\n而我可不可以爱你哭泣的心。 ”`;

    const historyForAPI = processHistoryForAPI(chat.history);

    // 3. 发起 API 请求并处理结果
    try {
        const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
            body: JSON.stringify({
                model: appState.apiConfig.model,
                messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI]
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'AI 服务响应失败');
        }

        const data = await response.json();
        const diaryEntry = data.choices[0]?.message?.content.trim();

        if (diaryEntry) {
            diaryTextContainer.innerHTML = `<p>${diaryEntry.replace(/\n/g, '<br>')}</p>`;
        } else {
            throw new Error('AI 未能生成有效的日记内容。');
        }

    } catch (error) {
        console.error('生成日记时发生错误:', error);
        diaryTextContainer.innerHTML = `<p style="color: red;">抱歉，生成日记时发生了一点小问题...<br>(${error.message})</p>`;
    }
}

/**
 * 核心函数：更新一个人物设定，并级联修改所有相关的联系人、聊天和群聊。
 * @param {number} index - 被编辑的人设在 appState.personas 数组中的索引。
 * @param {'ai' | 'my'} type - 被编辑的人设类型 ('ai' 或 'my')。
 * @param {object} newData - 包含新 name, avatar, content 的对象。
 */
async function updatePersonaAndCascadeChanges(index, type, newData) {
    if (index < 0 || !appState.personas[type][index]) {
        console.error("无法更新：提供的人设索引无效。");
        return;
    }

    // 1. 获取旧数据，特别是旧名字，用于查找匹配项。
    const originalPersona = { ...appState.personas[type][index] };
    const originalName = originalPersona.name;

    // 2. 更新核心人设库 (appState)
    appState.personas[type][index] = { ...originalPersona, ...newData };
    console.log(`人设库已更新: "${originalName}" -> "${newData.name}"`);

    // 3. 同步更新【联系人】列表
    // (仅当修改的是 AI 人设时才需要)
    if (type === 'ai') {
        const contactToUpdate = appState.contacts.find(c => c.name === originalName);
        if (contactToUpdate) {
            contactToUpdate.name = newData.name;
            contactToUpdate.avatar = newData.avatar;
            contactToUpdate.content = newData.content;
            console.log(`联系人已同步: "${contactToUpdate.name}"`);
        }
    }

    // 4. 遍历并同步所有【聊天】
    for (const chatId in appState.chats) {
        const chat = appState.chats[chatId];
        let chatWasModified = false;

        if (chat.type === 'group') {
            // --- 处理群聊 ---
            if (type === 'ai') {
                const memberToUpdate = chat.personas.ai.find(m => m.name === originalName);
                if (memberToUpdate) {
                    memberToUpdate.name = newData.name;
                    memberToUpdate.avatar = newData.avatar;
                    memberToUpdate.content = newData.content;
                    chatWasModified = true;
                }
            }
        } else {
            // --- 处理单聊 ---
            const personaInChat = chat.personas[type];
            if (personaInChat && personaInChat.name === originalName) {
                // 更新这个聊天里的人设数据
                chat.personas[type] = { ...personaInChat, ...newData };
                
                // 如果聊天备注名和人设旧名一样，就一起更新备注名
                if (chat.name === originalName) {
                    chat.name = newData.name;
                }
                chatWasModified = true;
            }
        }
        
        if (chatWasModified) {
             console.log(`聊天 [${chat.name}] 已同步。`);
        }
    }

    // 5. 将所有发生变化的数据一次性保存到数据库
    await dbStorage.set(KEYS.PERSONA_AI, appState.personas.ai);
    await dbStorage.set(KEYS.PERSONA_MY, appState.personas.my);
    await dbStorage.set(KEYS.CONTACTS, appState.contacts);
    await dbStorage.set(KEYS.CHATS, appState.chats);

    console.log("所有数据已保存到数据库。");

    // 6. 刷新UI界面，让用户立即看到变化
    // 如果当前聊天被修改了，实时更新标题
    const activeChat = appState.chats[appState.activeChatId];
    if (activeChat && activeChat.name) {
        document.getElementById('chat-title').textContent = activeChat.name;
    }
    
    // 重新渲染列表
    renderChatList();
    renderContactsList();
}

// ▼▼▼ 【最终修复版】替换整个 setupEventListeners 函数 ▼▼▼
const setupEventListeners = () => {

 // --- 【修改】打赏功能事件 ---
    const donationBtn = document.getElementById('donation-btn');
    if (donationBtn) {
        donationBtn.onclick = () => {
            // 旧的逻辑是打开一个模态框，我们把它改成打开新页面
            showScreen('donation-page-screen'); 
        };
    }
    // 新增打赏页面的返回按钮事件
    const donationPageBackBtn = document.getElementById('donation-page-back-btn');
    if (donationPageBackBtn) {
        donationPageBackBtn.onclick = () => showScreen('settings-hub-screen');
    }

    // --- 【修改】免责声明按钮事件 ---
    const disclaimerBtn = document.getElementById('settings-hub-disclaimer-btn');
    if (disclaimerBtn) {
        disclaimerBtn.onclick = () => {
            // 旧的逻辑是 alert() 弹窗，我们把它改成打开新页面
            showScreen('disclaimer-screen');
        };
    }
    // 新增免责声明页面的返回按钮事件
    const disclaimerBackBtn = document.getElementById('disclaimer-back-btn');
    if (disclaimerBackBtn) {
        disclaimerBackBtn.onclick = () => showScreen('settings-hub-screen');
    }

    document.getElementById('cancel-outgoing-call-btn').onclick = () => {
        showScreen('chat-screen');
        appendSystemMessageToChat('呼叫已取消');
    };


 
    document.getElementById('save-edit-btn').onclick = saveMessageEdit;
    document.getElementById('cancel-edit-btn').onclick = cancelMessageEdit;
    document.getElementById('action-view-diary').onclick = writeAndShowAIDiary;
  
    document.getElementById('diary-modal').onclick = (event) => {
    // 只有当点击事件的目标是 #diary-modal 本身（即空白处）时，才触发关闭
    if (event.target === event.currentTarget) {
        const diaryModal = document.getElementById('diary-modal');
        if (diaryModal) {
            diaryModal.classList.remove('active');
            setTimeout(() => {
                diaryModal.style.display = 'none';
            }, 400); // 匹配 CSS 中的 0.4s 动画时长
        }
    }
};

    document.getElementById('trigger-chat-wallpaper-upload').onclick = () => {
        document.getElementById('chat-wallpaper-upload').click();
    };
    document.getElementById('chat-wallpaper-upload').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            appState.pendingImage = e.target.result; 
            const statusEl = document.getElementById('chat-wallpaper-status');
            if (statusEl) {
                statusEl.textContent = '已选择新背景，请储存';
            }
        };
        reader.readAsDataURL(file);
        event.target.value = '';
    });


    const chatInputArea = document.querySelector('.chat-input-area');
    const actionsPanel = document.getElementById('chat-actions-panel');
    const stickerPanel = document.getElementById('sticker-panel');
    document.getElementById('toggle-actions-panel-btn').addEventListener('click', () => {
        const panelIsOpen = chatInputArea.classList.contains('panel-open');
        const actionsAreVisible = getComputedStyle(actionsPanel).display !== 'none';
        if (panelIsOpen && actionsAreVisible) {
            closePanel();
        } else {
            openPanel('actions');
        }
    });
    document.getElementById('toggle-sticker-panel-btn').addEventListener('click', () => {
        const panelIsOpen = chatInputArea.classList.contains('panel-open');
        const stickersAreVisible = getComputedStyle(stickerPanel).display !== 'none';
        if (panelIsOpen && stickersAreVisible) {
            closePanel();
        } else {
            openPanel('stickers');
        }
    });


document.getElementById('settings-hub-widget-btn').onclick = openWidgetSettings;

// “小组件设定”页 -> 返回按钮
document.getElementById('widget-settings-back-btn').onclick = () => showScreen('settings-hub-screen');

// “小组件设定”页 -> 三个“更换”按钮，分别触发对应的隐藏上传框
document.getElementById('change-widget-bg-btn').onclick = () => document.getElementById('widget-bg-upload-input').click();
document.getElementById('change-widget-footer-btn').onclick = () => document.getElementById('widget-footer-upload-input').click();
document.getElementById('change-widget-avatar-btn').onclick = () => document.getElementById('widget-avatar-upload-input').click();

// a. 处理背景图上传
setupFileUploadHelper('widget-bg-upload-input', null, async (src) => {
    appState.widgetImages.bg = src;
    document.getElementById('widget-preview-bg').style.backgroundImage = `url(${src})`; // 更新预览
    await dbStorage.set(KEYS.DECORATIVE_WIDGET_IMAGES, appState.widgetImages);
    applyWidgetImages(); // 实时更新主屏幕上的小组件
});

// --- 新增：为小组件设定页的“清除”和“保存”按钮绑定功能 ---

    // 绑定“清除全部”按钮的点击事件
    document.getElementById('clear-all-widget-btn').onclick = () => {
        // 使用自定义的确认弹窗，防止用户误触
        showCustomConfirm(
            '清除全部图片',
            '您确定要清除小组件的背景、页脚和头像图片吗？此操作将立即生效。',
            async () => {
                // 1. 清空内存中的图片数据
                appState.widgetImages = { bg: null, footer: null, avatar: null };

                // 2. 将清空后的状态保存到数据库
                await dbStorage.set(KEYS.DECORATIVE_WIDGET_IMAGES, appState.widgetImages);

                // 3. 更新当前设定页的预览UI，移除图片
                document.getElementById('widget-preview-bg').style.backgroundImage = 'none';
                document.getElementById('widget-preview-footer').style.backgroundImage = 'none';
                document.getElementById('widget-preview-avatar').style.backgroundImage = 'none';

                // 4. 更新主屏幕上的实际小组件，移除图片
                applyWidgetImages();
            }
        );
    };

// 为主动搭话频率按钮添加点击事件
document.querySelectorAll('#proactive-frequency-selector .segmented-control-button').forEach(button => {
    button.onclick = () => {
        // 先移除所有按钮的选中状态
        document.querySelectorAll('#proactive-frequency-selector .segmented-control-button').forEach(btn => btn.classList.remove('active'));
        // 再为当前点击的按钮添加选中状态
        button.classList.add('active');
    };
});

    document.getElementById('save-widget-settings-btn').onclick = () => {
        
        alert('小组件设定已保存！');
        showScreen('home-screen'); // 返回主屏幕
    };

// b. 处理页脚图上传
setupFileUploadHelper('widget-footer-upload-input', null, async (src) => {
    appState.widgetImages.footer = src;
    document.getElementById('widget-preview-footer').style.backgroundImage = `url(${src})`; // 更新预览
    await dbStorage.set(KEYS.DECORATIVE_WIDGET_IMAGES, appState.widgetImages);
    applyWidgetImages(); // 实时更新主屏幕上的小组件
});

// c. 处理头像上传
setupFileUploadHelper('widget-avatar-upload-input', null, async (src) => {
    appState.widgetImages.avatar = src;
    document.getElementById('widget-preview-avatar').style.backgroundImage = `url(${src})`; // 更新预览
    await dbStorage.set(KEYS.DECORATIVE_WIDGET_IMAGES, appState.widgetImages);
    applyWidgetImages(); // 实时更新主屏幕上的小组件
});

    // --- 输入框与动态按钮逻辑 ---
    const chatInput = document.getElementById('chat-input');
    const dynamicBtn = document.getElementById('dynamic-action-btn');
    const sendFunction = async () => {
        const userText = chatInput.value.trim();
        if (!userText) return; 
        const chat = appState.chats[appState.activeChatId];
        if (!chat) return;
        await checkAndInsertTimestamp();
        const timestamp = Date.now();
        const messageData = { role: 'user', content: userText, timestamp: timestamp };
        if (appState.replyingToMessage) {
            messageData.replyTo = { role: appState.replyingToMessage.role, author: appState.replyingToMessage.author, content: appState.replyingToMessage.content, timestamp: appState.replyingToMessage.timestamp };
        }
        appendMessage(messageData); 
        chat.history.push(messageData); 
        await dbStorage.set(KEYS.CHATS, appState.chats);
        manageProactiveTimer(appState.activeChatId);
        chatInput.value = '';
        chatInput.style.height = 'auto';
        cancelReplying();
        dynamicBtn.textContent = '接收';
        dynamicBtn.classList.remove('send-mode');
        dynamicBtn.classList.add('receive-mode');
        dynamicBtn.onclick = receiveMessageHandler;
        document.getElementById('toggle-actions-panel-btn').disabled = false;
    };
    dynamicBtn.onclick = receiveMessageHandler;
    chatInput.addEventListener('input', () => {
        const toggleActionsBtn = document.getElementById('toggle-actions-panel-btn');
        if (chatInput.value.trim().length > 0) {
            if (!dynamicBtn.classList.contains('send-mode')) {
                dynamicBtn.textContent = '发送';
                dynamicBtn.classList.remove('receive-mode');
                dynamicBtn.classList.add('send-mode');
                dynamicBtn.onclick = sendFunction;
            }
            toggleActionsBtn.disabled = true;
            if (chatInputArea.classList.contains('panel-open')) {
                closePanel();
            }
        } else {
            if (!dynamicBtn.classList.contains('receive-mode')) {
                dynamicBtn.textContent = '接收';
                dynamicBtn.classList.remove('send-mode');
                dynamicBtn.classList.add('receive-mode');
                dynamicBtn.onclick = receiveMessageHandler;
            }
            toggleActionsBtn.disabled = false;
        }
    });

    // --- 【新版】图示设定页面的事件绑定 ---

    // 进入“图示设定”页
    document.getElementById('settings-hub-icon-btn').onclick = () => {
        // 1. 将当前的设定深拷贝一份到临时状态，开启本次编辑
        appState.tempCustomIcons = JSON.parse(JSON.stringify(appState.customIcons));
        // 2. 渲染设定页
        renderIconSettingsGrid();
        showScreen('icon-settings-screen');
    };

    // 点击“保存全部图示”按钮
document.getElementById('save-icon-changes-btn').onclick = async () => {
    // 1. 将临时状态的更改正式应用到主状态
    appState.customIcons = JSON.parse(JSON.stringify(appState.tempCustomIcons));
    // 2. 保存到数据库
    await dbStorage.set(KEYS.CUSTOM_ICONS, appState.customIcons);
    // 3. 更新主屏幕的图标
    renderHomeScreenIcons();
    alert('图示设定已保存！');
    
    // 4. 【新增】跳转回主屏幕
    showScreen('home-screen');
};

 
    const cancelIconChanges = () => {
        // 清空临时状态，下次进入时会重新从主状态加载
        appState.tempCustomIcons = {}; 
        showScreen('settings-hub-screen');
    };

document.getElementById('cancel-icon-changes-btn').onclick = () => {
 
    showCustomConfirm(
        '清除全部自定义图示',
        '您确定要清除所有自定义图示并恢复为默认吗？<br><b>此操作将立即保存并生效，无法撤销。</b>',
        async () => {
           
            appState.customIcons = {};
            appState.tempCustomIcons = {};

            await dbStorage.set(KEYS.CUSTOM_ICONS, appState.customIcons);

     
            renderHomeScreenIcons();

            // 4. 更新当前设定页的预览UI
            renderIconSettingsGrid();

            // 5. 提示用户操作成功
            alert('所有自定义图示已清除并恢复为默认。');
        }
    );
};

    document.getElementById('icon-settings-back-btn').onclick = cancelIconChanges;
    document.getElementById('icon-upload-input').addEventListener('change', handleIconUpload);

    document.getElementById('home-btn-prompt').onclick = () => { renderPromptList(); showScreen('prompt-list-screen'); };
    document.getElementById('modal-btn-post-my-moment').onclick = () => { document.getElementById('moments-action-modal').classList.remove('active'); document.getElementById('post-text-input').value = ''; document.getElementById('post-image-text-input').value = ''; document.getElementById('post-location-input').value = ''; showScreen('create-post-screen'); };
    document.getElementById('modal-btn-generate-ai-moment').onclick = () => { document.getElementById('moments-action-modal').classList.remove('active'); openChatSelectionForMomentModal(); };
    document.getElementById('modal-btn-cancel-moments-action').onclick = () => { document.getElementById('moments-action-modal').classList.remove('active'); };
    document.getElementById('modal-btn-add-contact').onclick = () => { document.getElementById('create-new-modal').classList.remove('active'); openPersonaSelectionModal('add_contact'); };
    document.getElementById('select-prompt-btn').onclick = openPromptSelectionModal;
    document.getElementById('me-page-profile-item').onclick = () => showPersonaList('my');
    document.getElementById('offline-mode-toggle').onclick = toggleOfflineMode;
    document.getElementById('prompt-list-back-btn').onclick = () => showScreen('home-screen');
    document.getElementById('prompt-editor-back-btn').onclick = () => showScreen('prompt-list-screen');
    document.getElementById('add-prompt-btn').onclick = () => openPromptEditor(-1);
    document.getElementById('prompt-edit-btn').onclick = (e) => { appState.editMode.prompt = !appState.editMode.prompt; e.target.textContent = appState.editMode.prompt ? '完成' : '编辑'; renderPromptList(); };
document.getElementById('settings-hub-dark-mode-toggle').onclick = toggleDarkMode;
    document.getElementById('save-prompt-btn').onclick = async () => { const title = document.getElementById('prompt-title-input').value.trim(); const content = document.getElementById('prompt-content-input').value.trim(); if (!title || !content) { alert('标题和内容都不能为空！'); return; } const promptData = { id: `prompt_${Date.now()}`, title, content }; if (appState.editingPromptIndex === -1) { appState.prompts.push(promptData); } else { const originalId = appState.prompts[appState.editingPromptIndex].id; appState.prompts[appState.editingPromptIndex] = { ...promptData, id: originalId }; } await dbStorage.set(KEYS.PROMPTS, appState.prompts); renderPromptList(); showScreen('prompt-list-screen'); };
    document.body.addEventListener('click', () => { document.querySelectorAll('.interaction-popup.active').forEach(p => { p.classList.remove('active'); }); }, true);
    document.getElementById('custom-confirm-cancel-btn').onclick = hideCustomConfirm;
    document.getElementById('home-btn-main-hub').onclick = () => { switchTab('chat'); showScreen('main-hub-screen'); };
   
    document.getElementById('home-btn-ai-persona').onclick = () => showPersonaList('ai');
    document.getElementById('home-btn-my-persona').onclick = () => showPersonaList('my');
       document.getElementById('home-btn-settings').onclick = () => showScreen('settings-hub-screen');

// ▼▼▼ 在 setupEventListeners 函数内，加入这段最终代码 ▼▼▼

// “设定”页面 -> “汇出”按钮
document.getElementById('export-data-btn').onclick = exportDataSimple;

// “设定”页面 -> “汇入”按钮 (它会触发隐藏的档案选择框)
document.getElementById('import-data-btn').onclick = () => {
    document.getElementById('import-file-input').click();
};

// 当使用者选择了档案后，执行汇入操作
document.getElementById('import-file-input').addEventListener('change', handleImportSimple);

// ▲▲▲ 代码加到这里结束 ▲▲▲

    // 设置主页的返回按钮
    document.getElementById('settings-hub-back-btn').onclick = () => showScreen('home-screen');

    // 设置主页里的“API 设定”项目
    document.getElementById('settings-hub-api-btn').onclick = () => showScreen('api-settings-screen');

document.getElementById('settings-hub-wallpaper-btn').onclick = () => {
    // 在显示页面前，先获取预览图片的元素
    const previewImg = document.getElementById('home-wallpaper-preview');
    // 将当前正在使用的壁纸 (appState.homeWallpaper) 设置为预览图的源
    // 如果当前没有设置壁纸，则源为空字符串
    previewImg.src = appState.homeWallpaper || '';
    // 然后再显示设定页面
    showScreen('home-settings-screen');
};
    document.getElementById('main-hub-back-btn').onclick = () => showScreen('home-screen');
    // ▼▼▼ 修改這一行 ▼▼▼
document.getElementById('api-settings-back-btn').onclick = () => showScreen('settings-hub-screen');
    document.getElementById('chat-settings-back-btn').onclick = () => { const chat = appState.chats[appState.activeChatId]; if (chat && chat.isOfflineMode) { document.getElementById('phone-screen').classList.add('offline-active'); } showScreen('chat-screen'); };
    document.getElementById('home-settings-back-btn').onclick = () => showScreen('settings-hub-screen');
    document.getElementById('create-chat-back-btn').onclick = () => showScreen('main-hub-screen');
    document.getElementById('persona-editor-back-btn').onclick = () => showPersonaList(appState.currentPersonaType);
    document.getElementById('call-log-back-btn').onclick = () => showScreen('chat-screen');
    document.getElementById('cancel-chat-selection-btn').onclick = closeChatSelectionForMomentModal;
    document.getElementById('select-chat-for-moment-modal').onclick = (e) => { if (e.target === e.currentTarget) closeChatSelectionForMomentModal(); };
    document.getElementById('ai-persona-list-back-btn').onclick = () => { if(appState.editMode.ai_persona){ appState.editMode.ai_persona = false; document.getElementById('ai-persona-edit-btn').textContent = '编辑'; } showScreen('home-screen'); };
    document.getElementById('my-persona-list-back-btn').onclick = () => { if(appState.editMode.my_persona){ appState.editMode.my_persona = false; document.getElementById('my-persona-edit-btn').textContent = '编辑'; } showScreen('home-screen'); };
    document.getElementById('chat-back-btn').onclick = () => { if (appState.editMode.chat) { appState.editMode.chat = false; document.getElementById('main-hub-edit-btn').textContent = '编辑'; } document.getElementById('phone-screen').classList.remove('offline-active'); switchTab('chat'); showScreen('main-hub-screen'); };
    document.querySelectorAll('.tab-item').forEach(tab => tab.onclick = () => switchTab(tab.id.replace('tab-btn-', '')));
    document.getElementById('main-hub-edit-btn').onclick = (e) => { appState.editMode.chat = !appState.editMode.chat; e.target.textContent = appState.editMode.chat ? '完成' : '编辑'; renderChatList(); };
    ['ai', 'my'].forEach(type => { document.getElementById(`${type}-persona-edit-btn`).onclick = (e) => { appState.editMode[`${type}_persona`] = !appState.editMode[`${type}_persona`]; e.target.textContent = appState.editMode[`${type}_persona`] ? '完成' : '编辑'; renderPersonaList(type); }; });
    document.getElementById('chat-settings-btn').onclick = openChatSettings;
    document.getElementById('action-send-image').onclick = () => { document.getElementById('image-upload-input').click(); };
    document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Image = e.target.result; const chat = appState.chats[appState.activeChatId]; if (!chat) return; await checkAndInsertTimestamp(); const imageTimestamp = Date.now(); const imageData = { type: 'just_image', url: base64Image }; appendMessage({ role: 'user', content: imageData, timestamp: imageTimestamp }); chat.history.push({ role: 'user', content: imageData, timestamp: imageTimestamp }); await dbStorage.set(KEYS.CHATS, appState.chats); }; reader.readAsDataURL(file); event.target.value = ''; });
    document.getElementById('action-send-image-text').onclick = openImageModal; document.getElementById('cancel-image-btn').onclick = closeImageModal; document.getElementById('send-image-btn').onclick = sendImageMessage; document.getElementById('action-send-location').onclick = openLocationModal; document.getElementById('action-send-voice').onclick = openVoiceModal; document.getElementById('action-start-videocall').onclick = requestCallDecision; document.getElementById('cancel-location-btn').onclick = closeLocationModal; document.getElementById('send-location-btn').onclick = sendLocationMessage; document.getElementById('cancel-voice-btn').onclick = closeVoiceModal; document.getElementById('send-voice-btn').onclick = sendVoiceMessage; document.getElementById('cancel-selection-btn').onclick = closePersonaSelectionModal; document.getElementById('persona-selection-modal').onclick = (e) => { if (e.target === e.currentTarget) closePersonaSelectionModal(); }; document.getElementById('videocall-hangup-btn').onclick = endVideoCall; document.getElementById('videocall-send-btn').onclick = sendVideoCallMessage; document.getElementById('videocall-input').onkeydown = (e) => { if (e.key === 'Enter') sendVideoCallMessage(); }; document.getElementById('sticker-screen-back-btn').onclick = () => showScreen('chat-screen'); document.getElementById('add-sticker-btn').onclick = () => { document.getElementById('sticker-upload-input').click(); }; document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Image = e.target.result; appState.stickers.push(base64Image); await dbStorage.set(KEYS.STICKERS, appState.stickers); renderStickers(); }; reader.readAsDataURL(file); event.target.value = ''; }); document.getElementById('add-ai-persona-btn').onclick = () => openPersonaEditor('ai', -1); document.getElementById('add-my-persona-btn').onclick = () => openPersonaEditor('my', -1); document.getElementById('save-preset-btn').onclick = async () => { const name = document.getElementById('preset-name-input').value.trim(); if (!name) { alert('预设名称不能为空！'); return; } const content = document.getElementById('preset-content-input').value.trim(); const avatar = document.getElementById('preset-avatar-preview').src; const type = appState.currentPersonaType; const index = appState.editingPresetIndex; const newData = { name, content, avatar }; if (index > -1) { await updatePersonaAndCascadeChanges(index, type, newData); } else { appState.personas[type].push(newData); const key = type === 'ai' ? KEYS.PERSONA_AI : KEYS.PERSONA_MY; await dbStorage.set(key, appState.personas[type]); } showPersonaList(type); }; document.getElementById('create-chat-btn').onclick = async () => { const name = document.getElementById('new-chat-name-input').value.trim(); if (!name) return alert('請為對話取一個名稱！'); if (!appState.newChatTempPersonas.ai || !appState.newChatTempPersonas.my) return alert('請為雙方選擇角色設定！'); const newChatId = 'chat_' + Date.now(); appState.chats[newChatId] = { name, history: [], personas: { ...appState.newChatTempPersonas }, wallpaper: null, memoryRounds: 0, isOfflineMode: false }; await dbStorage.set(KEYS.CHATS, appState.chats); document.getElementById('new-chat-name-input').value = ''; ['ai', 'my'].forEach(type => { const el = document.getElementById(`new-chat-${type}-selection-text`); el.textContent = type === 'ai' ? '從 AI 人設庫選擇' : '從我的素材庫選擇'; el.classList.add('placeholder'); }); switchTab('chat'); openChat(newChatId); }; document.getElementById('select-ai-persona-btn').onclick = () => openPersonaSelectionModal('ai'); document.getElementById('select-my-persona-btn').onclick = () => openPersonaSelectionModal('my'); document.getElementById('select-new-ai-persona-btn').onclick = () => openPersonaSelectionModal('new_ai'); document.getElementById('select-new-my-persona-btn').onclick = () => openPersonaSelectionModal('new_my'); document.getElementById('clear-home-wallpaper-btn').onclick = () => { document.getElementById('home-wallpaper-preview').src = ''; }; document.getElementById('save-home-settings-btn').onclick = async () => {
    const wallpaperSrc = document.getElementById('home-wallpaper-preview').src;
    let newWallpaper = null;

    if (wallpaperSrc.startsWith('data:image')) {
        newWallpaper = wallpaperSrc;
    }

    // 更新全局状态和数据库
    appState.homeWallpaper = newWallpaper;
    await dbStorage.set(KEYS.HOME_WALLPAPER, newWallpaper);

    // 【核心修正】将新壁纸应用到正确的 home-screen 元素上
    document.getElementById('home-screen').style.backgroundImage = newWallpaper ? `url(${newWallpaper})` : 'none';

    alert('主画面设定已储存！');
    showScreen('home-screen');
};
 document.getElementById('save-api-btn').onclick = async () => { appState.apiConfig = { url: document.getElementById('api-url-input').value.trim(), key: document.getElementById('api-key-input').value.trim(), model: document.getElementById('api-model-input').value.trim() }; await dbStorage.set(KEYS.API, appState.apiConfig); alert('全部 API 設定已儲存！'); }; document.getElementById('fetch-models-btn').onclick = async () => { const url = document.getElementById('api-url-input').value.trim(); const key = document.getElementById('api-key-input').value.trim(); const btn = document.getElementById('fetch-models-btn'); const originalText = btn.textContent; if (!url || !key) { alert('請先輸入 API URL 和 API Key！'); return; } btn.disabled = true; btn.textContent = '獲取中...'; try { const response = await fetch(`${url.replace(/\/$/, '')}/models`, { headers: { 'Authorization': `Bearer ${key}` } }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error?.message || `HTTP 錯誤: ${response.status}`); } const data = await response.json(); const modelSelect = document.getElementById('api-model-select'); modelSelect.innerHTML = '<option value="">--- 請選擇一個模型 ---</option>'; if (data.data && Array.isArray(data.data)) { const sortedModels = data.data.sort((a, b) => { const aId = a.id.toLowerCase(); const bId = b.id.toLowerCase(); if (aId.includes('gpt-4') && !bId.includes('gpt-4')) return -1; if (!aId.includes('gpt-4') && bId.includes('gpt-4')) return 1; if (aId.includes('gpt-3.5') && !bId.includes('gpt-3.5')) return -1; if (!aId.includes('gpt-3.5') && bId.includes('gpt-3.5')) return 1; return a.id.localeCompare(b.id); }); sortedModels.forEach(model => { const option = document.createElement('option'); option.value = model.id; option.textContent = model.id; modelSelect.appendChild(option); }); } modelSelect.style.display = 'block'; alert('模型列表已成功獲取！'); } catch (error) { alert(`獲取模型失敗：${error.message}`); } finally { btn.disabled = false; btn.textContent = originalText; } }; document.getElementById('api-model-select').onchange = (e) => { if (e.target.value) { document.getElementById('api-model-input').value = e.target.value; } }; document.getElementById('send-post-btn').onclick = async () => { const text = document.getElementById('post-text-input').value.trim(); const imagePromptsInput = document.getElementById('post-image-text-input').value.trim(); const image_prompts = imagePromptsInput ? imagePromptsInput.split(/[,，]/).map(p => p.trim()).filter(p => p) : []; if (!text && image_prompts.length === 0) return alert('文字和配图想法至少要有一个！'); const myPersonaName = appState.personas.my[0]?.name || '我'; const newPost = { author: myPersonaName, text, image_prompts, location: document.getElementById('post-location-input').value.trim(), timestamp: Date.now(), likes: [], comments: [] }; appState.momentsData.posts.unshift(newPost); await saveAndRenderMoments(); document.getElementById('post-text-input').value = ''; document.getElementById('post-image-text-input').value = ''; document.getElementById('post-location-input').value = ''; await notifyAisOfNewMoment(newPost); showScreen('main-hub-screen'); }; document.getElementById('cancel-post-btn').onclick = () => showScreen('main-hub-screen'); document.getElementById('moments-cover-img').onclick = () => document.getElementById('moments-cover-upload').click(); document.getElementById('moments-user-avatar').onclick = () => document.getElementById('moments-avatar-upload').click(); document.getElementById('moments-feed').addEventListener('click', (e) => { const imageItem = e.target.closest('.post-image-item'); if (imageItem && imageItem.querySelector('.image-text-cover')) { const cover = imageItem.querySelector('.image-text-cover'); const details = imageItem.querySelector('.image-text-details'); if (cover && details) { const isCoverVisible = cover.style.display !== 'none'; cover.style.display = isCoverVisible ? 'none' : 'flex'; details.style.display = isCoverVisible ? 'block' : 'none'; } return; } const toggleBtn = e.target.closest('.interaction-toggle-btn'); if (toggleBtn) { e.stopPropagation(); const postIndex = toggleBtn.dataset.postIndex; const popup = document.getElementById(`popup-${postIndex}`); document.querySelectorAll('.interaction-popup.active').forEach(p => { if (p.id !== popup.id) p.classList.remove('active'); }); if (popup) popup.classList.toggle('active'); return; } const commentBtn = e.target.closest('.popup-action.comment-btn'); if (commentBtn) { e.stopPropagation(); const postIndex = commentBtn.dataset.postIndex; const postElement = commentBtn.closest('.moment-post'); if (postElement) { const interactionArea = postElement.querySelector('.moment-interaction-area'); const commentsSection = postElement.querySelector('.moment-comments-section'); if (interactionArea) { interactionArea.style.display = 'block'; } if (commentsSection) { commentsSection.style.display = 'block'; } const inputArea = postElement.querySelector(`#comment-input-area-${postIndex}`); const inputField = postElement.querySelector(`#comment-input-${postIndex}`); if (inputArea) { inputArea.classList.add('active'); } if (inputField) { inputField.focus(); } } const popup = commentBtn.closest('.interaction-popup'); if (popup) popup.classList.remove('active'); return; } const likeBtn = e.target.closest('.popup-action.like-btn'); if(likeBtn) { interactWithMoment(likeBtn.dataset.author, parseInt(likeBtn.dataset.postIndex), 'like'); const popup = likeBtn.closest('.interaction-popup'); if (popup) popup.classList.remove('active'); return; } const commentSendBtn = e.target.closest('.comment-send-btn'); if(commentSendBtn) { const postIndex = parseInt(commentSendBtn.dataset.postIndex); const input = document.getElementById(`comment-input-${postIndex}`); postMomentComment(postIndex, input.value); input.value = ''; const inputArea = commentSendBtn.closest('.comment-input-area'); if (inputArea) inputArea.classList.remove('active'); return; } }); setupFileUploadHelper('chat-wallpaper-upload', 'chat-wallpaper-preview'); setupFileUploadHelper('home-wallpaper-upload', 'home-wallpaper-preview'); setupFileUploadHelper('moments-cover-upload', 'moments-cover-img', (src) => { appState.momentsData.cover = src; saveAndRenderMoments(); }); setupFileUploadHelper('moments-avatar-upload', 'moments-user-avatar', (src) => { appState.momentsData.avatar = src; saveAndRenderMoments(); }); setupFileUploadHelper('preset-avatar-upload', 'preset-avatar-preview'); const openTransferModal = () => { document.getElementById('transfer-amount-input').value = ''; document.getElementById('transfer-remark-input').value = ''; document.getElementById('transfer-modal').classList.add('active'); }; const closeTransferModal = () => { document.getElementById('transfer-modal').classList.remove('active'); }; const sendTransferMessage = async () => { const amountInput = document.getElementById('transfer-amount-input'); const remarkInput = document.getElementById('transfer-remark-input'); const amount = parseFloat(amountInput.value); const remark = remarkInput.value.trim(); if (isNaN(amount) || amount <= 0) { alert('请输入有效的转账金额！'); return; } const chat = appState.chats[appState.activeChatId]; if (!chat) return; await checkAndInsertTimestamp(); const timestamp = Date.now(); const messageData = { type: 'transfer', amount: amount, remark: remark }; appendMessage({ role: 'user', content: messageData, timestamp: timestamp }); chat.history.push({ role: 'user', content: messageData, timestamp: timestamp });
    await dbStorage.set(KEYS.CHATS, appState.chats);
    closeTransferModal();
    const randomDelay = Math.random() * 2000 + 2000; // 2-4秒的随机延迟
    setTimeout(() => {
        simulateAIReceivingTransfer(timestamp);
    }, randomDelay);
};
 document.getElementById('action-send-transfer').onclick = openTransferModal; document.getElementById('cancel-transfer-btn').onclick = closeTransferModal; document.getElementById('send-transfer-btn').onclick = sendTransferMessage; document.getElementById('cancel-reply-btn').onclick = cancelReplying; document.body.addEventListener('click', hideContextMenu, true); document.getElementById('time-awareness-toggle').onclick = (e) => { e.currentTarget.classList.toggle('active'); }; document.getElementById('save-chat-settings-btn').onclick = async () => { const chat = appState.chats[appState.activeChatId]; if (!chat) return; chat.name = document.getElementById('chat-name-input').value.trim(); if (appState.pendingImage) { chat.wallpaper = appState.pendingImage; appState.pendingImage = null; } chat.memoryRounds = parseInt(document.getElementById('chat-memory-rounds-input').value) || 0; chat.timeAwareness = document.getElementById('time-awareness-toggle').classList.contains('active'); chat.proactiveMessaging = document.getElementById('proactive-messaging-toggle').classList.contains('active'); const activeFrequencyButton = document.querySelector('#proactive-frequency-selector .segmented-control-button.active');
chat.proactiveInterval = activeFrequencyButton ? parseInt(activeFrequencyButton.dataset.value, 10) : 10; await dbStorage.set(KEYS.CHATS, appState.chats); manageProactiveTimer(appState.activeChatId); alert('对话设定已储存！'); openChat(appState.activeChatId); }; document.getElementById('proactive-messaging-toggle').onclick = (e) => { e.currentTarget.classList.toggle('active'); }; document.getElementById('start-chat-from-editor-btn').onclick = () => { const type = appState.currentPersonaType; const index = appState.editingPresetIndex; if (index === -1) { alert('请先储存此预设，然后才能开始聊天。'); return; } if (type !== 'ai') { alert('只能与“AI人设库”中的角色开始聊天。'); return; } const persona = appState.personas[type][index]; if (persona) { startChatFromContacts(persona); } else { alert('错误：无法获取当前编辑的角色资料。'); } };

document.getElementById('public-account-back-btn').onclick = () => showScreen('main-hub-screen');

}; // <--- 这是 setupEventListeners 函数的正确结尾

const updateRealTimeClock = () => {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-TW', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    });
    const statusBarClock = document.getElementById('status-bar-time');
    if(statusBarClock) {
        statusBarClock.textContent = timeString;
    }
};

// ▼▼▼ 同样地，找到此函数并用下面的版本替换 ▼▼▼
const renderHomeScreenIcons = () => {
    // --- 【核心修改】在这里也新增 'icon-widget' ---
    const iconsMap = {
        'icon-widget': { default: '🦋' },
        'icon-contacts': { default: '💬' },
        'icon-me': { default: '🩹' },
        'icon-settings': { default: '⚙️' },
        'icon-prompt': { default: '💭' },
        'icon-dock-1': { default: '🤍' },
        'icon-dock-2': { default: '🩶' },
        'icon-dock-3': { default: '🖤' },
    };

    for (const iconId in iconsMap) {
        const customSrc = appState.customIcons[iconId];

        // ▼▼▼ 【核心修改】添加 if/else 来分别处理小组件和其他图标 ▼▼▼
        if (iconId === 'icon-widget') {
            // 特殊处理：找到小组件的 <img> 标签并直接修改它的 src
            const widgetImageElement = document.getElementById('widget-main-image');
            if (widgetImageElement) {
                widgetImageElement.src = customSrc || iconsMap[iconId].default;
            }
        } else {
            // 原始逻辑：处理所有其他普通图标
            const iconElement = document.getElementById(iconId);
            if (iconElement) {
                if (customSrc) {
                    iconElement.style.backgroundImage = `url(${customSrc})`;
                    iconElement.style.backgroundSize = 'cover';
                    iconElement.style.backgroundPosition = 'center';
                    iconElement.innerHTML = '';
                } else {
                    iconElement.style.backgroundImage = 'none';
                    iconElement.innerHTML = iconsMap[iconId].default;
                }
            }
        }
        // ▲▲▲ 修改结束 ▲▲▲
    }
};

const openWidgetSettings = () => {
    const { bg, footer, avatar } = appState.widgetImages;
    // 更新三个预览部分的背景图
    document.getElementById('widget-preview-bg').style.backgroundImage = bg ? `url(${bg})` : 'none';
    document.getElementById('widget-preview-footer').style.backgroundImage = footer ? `url(${footer})` : 'none';
    document.getElementById('widget-preview-avatar').style.backgroundImage = avatar ? `url(${avatar})` : 'none';
    showScreen('widget-settings-screen');
};

/**
 * 计算并设置真实的视口高度，以解决移动端浏览器UI遮挡问题
 */
const setRealViewportHeight = () => {
    const realViewportHeight = window.innerHeight;
    document.documentElement.style.setProperty('--real-vh', `${realViewportHeight}px`);
    console.log(`Real viewport height set to: ${realViewportHeight}px`); // 添加日志方便调试
};

// 【关键修改】在脚本加载时，立刻执行一次，确保初始高度正确
setRealViewportHeight();

// 在页面加载完成和窗口大小变化时再次执行，以应对各种动态变化
window.addEventListener('resize', setRealViewportHeight);
// (保留 load 事件作为双重保险)
window.addEventListener('load', setRealViewportHeight);

// 这是重写和修正后的 init 函数
const init = async () => {
    const oldKeys = { API: 'AIRP_v15_apiConfig', CHATS: 'AIRP_v15_chats', PERSONA_AI: 'AIRP_v15_persona_ai', PERSONA_MY: 'AIRP_v15_persona_my', HOME_WALLPAPER: 'AIRP_v15_home_wallpaper', MOMENTS_DATA: 'AIRP_v15_moments_data' };
    const migrationMarker = await db.kvStore.get('migration_complete_v1');
    if (!migrationMarker) {
        console.log("开始从 localStorage 迁移数据到 IndexedDB...");
        let migrated = false;
        for (const key in oldKeys) {
            const oldStorageKey = oldKeys[key];
            const newDbKey = KEYS[key];
            const oldData = localStorage.getItem(oldStorageKey);
            if (oldData) {
                try {
                    const parsedData = JSON.parse(oldData);
                    await dbStorage.set(newDbKey, parsedData);
                    localStorage.removeItem(oldStorageKey);
                    migrated = true;
                    console.log(`'${oldStorageKey}' 已成功迁移。`);
                } catch(e) { console.error(`迁移 '${oldStorageKey}' 失败:`, e); }
            }
        }
        if (migrated) {
            alert("数据已成功从旧版升级到新版大容量储存！");
        }
        await db.kvStore.put({ key: 'migration_complete_v1', value: true });
    }

    appState.apiConfig = await dbStorage.get(KEYS.API, { url: 'https://generativelanguage.googleapis.com/v1beta', key: '', model: 'gemini-2.5-pro' });
    appState.personas.ai = await dbStorage.get(KEYS.PERSONA_AI, []);
    appState.personas.my = await dbStorage.get(KEYS.PERSONA_MY, []);
    appState.chats = await dbStorage.get(KEYS.CHATS, {});
    
    // 数据迁移逻辑: 从旧的单选 promptId 转换到新的多选 promptIds 数组
    for (const chatId in appState.chats) {
        const chat = appState.chats[chatId];
        if (chat.promptId && !chat.promptIds) {
            chat.promptIds = [chat.promptId];
            delete chat.promptId; 
        }
        if (!chat.promptIds) {
            chat.promptIds = [];
        }
    }

    appState.homeWallpaper = await dbStorage.get(KEYS.HOME_WALLPAPER, null);
    appState.momentsData = await dbStorage.get(KEYS.MOMENTS_DATA, { cover: null, avatar: null, posts: [] });
    appState.widgetImages = await dbStorage.get(KEYS.DECORATIVE_WIDGET_IMAGES, { bg: null, footer: null, avatar: null }); 
    appState.contacts = await dbStorage.get(KEYS.CONTACTS, []); 
    appState.stickers = await dbStorage.get(KEYS.STICKERS, []); 
    appState.isDarkMode = await dbStorage.get(KEYS.DARK_MODE, false); 
    appState.prompts = await dbStorage.get(KEYS.PROMPTS, []);
    appState.publicAccountPosts = await dbStorage.get(KEYS.PUBLIC_ACCOUNT_POSTS, []); 
    appState.customIcons = await dbStorage.get(KEYS.CUSTOM_ICONS, {}); 

    if (appState.personas.ai.length === 0) {
        appState.personas.ai.push({ name: '测试AI', content: '你是一个用于测试的ai。', avatar: DEFAULT_AVATAR })
        await dbStorage.set(KEYS.PERSONA_AI, appState.personas.ai);
    }
    if (appState.personas.my.length === 0) {
        appState.personas.my.push({ name: '初始', content: '我是用户。', avatar: DEFAULT_AVATAR });
        await dbStorage.set(KEYS.PERSONA_MY, appState.personas.my);
    }
    if(appState.homeWallpaper){ document.getElementById('home-screen').style.backgroundImage = `url(${appState.homeWallpaper})`; }
    
    applyWidgetImages();
    document.getElementById('api-url-input').value = appState.apiConfig.url || '';
    document.getElementById('api-key-input').value = appState.apiConfig.key || '';
    document.getElementById('api-model-input').value = appState.apiConfig.model || '';
    
    // 【修正】在这里调用已移到外部的函数，现在是安全的
    renderHomeScreenIcons(); 

    setupEventListeners();
    
    updateRealTimeClock();
    setInterval(updateRealTimeClock, 1000); 

    applyDarkMode(appState.isDarkMode);
   
    document.getElementById('modal-btn-new-chat').onclick = () => {
        document.getElementById('create-new-modal').classList.remove('active');
        showScreen('create-chat-screen');
    };
    document.getElementById('modal-btn-new-group').onclick = () => {
        document.getElementById('create-new-modal').classList.remove('active');
        openCreateGroupChatScreen(); 
    };
    document.getElementById('modal-btn-cancel-create').onclick = () => {
        document.getElementById('create-new-modal').classList.remove('active');
    };
    document.getElementById('create-group-chat-back-btn').onclick = () => showScreen('main-hub-screen');

    document.getElementById('select-group-my-persona-btn').onclick = () => openPersonaSelectionModal('group_my');

    document.getElementById('create-group-chat-btn').onclick = async () => {
        const groupName = document.getElementById('group-chat-name-input').value.trim();
        if (!groupName) return alert('请给群聊取一个名字！');

        const myPersona = appState.newChatTempPersonas.my;
        if (!myPersona) return alert('请选择你的角色！');

        const selectedAIPersonas = [];
        document.querySelectorAll('#group-ai-persona-list-container input[type="checkbox"]:checked').forEach(checkbox => {
            const persona = appState.personas.ai.find(p => p.name === checkbox.value);
            if (persona) selectedAIPersonas.push(persona);
        });

        if (selectedAIPersonas.length < 1) { 
            return alert('请至少选择一个群聊成员！');
        }

        const newChatId = 'chat_' + Date.now();
        appState.chats[newChatId] = {
            name: groupName,
            type: 'group', 
            history: [],
            personas: {
                ai: selectedAIPersonas, 
                my: myPersona
            },
            wallpaper: null,
            memoryRounds: 0,
            isOfflineMode: false
        };

        await dbStorage.set(KEYS.CHATS, appState.chats);
        
        appState.newChatTempPersonas = { ai: null, my: null };
        
        openChat(newChatId);
    };

    switchTab('chat');
    showScreen('home-screen');

    initAiMomentTimers(); // 启动所有AI的朋友圈自动发布定时器

    const island = document.getElementById('dynamic-island');
    if(island) {
        island.classList.add('default-pill', 'visible');
    }
};



// ▼▼▼ 使用这个【最终修复版】，替换掉“诊断版”的 requestMomentReaction 函数 ▼▼▼

const requestMomentReaction = async (chatId, originalPost) => {
    const chat = appState.chats[chatId];
    if (!chat) return;

    // --- 点赞逻辑 (保持不变) ---
    if (Math.random() < 0.9) {
        let postToUpdate = appState.momentsData.posts.find(p => p.timestamp === originalPost.timestamp);
        if (postToUpdate) {
            if (!postToUpdate.likes) postToUpdate.likes = [];
            if (!postToUpdate.likes.includes(chat.name)) {
                postToUpdate.likes.push(chat.name);
                await saveAndRenderMoments();
            }
        }
    }

    // --- 评论逻辑 (使用修正后的指令) ---
    if (Math.random() < 0.8) {
        try {
            console.log(`[互动] ${chat.name} 正在思考真实的评论内容...`);
            
            // 构建专门用于生成评论的 "迷你对话"
            const messagesForAPI = [
                { role: "system", content: `你正在扮演角色: "${chat.personas.ai.name}"，你的设定是: "${chat.personas.ai.content}".` },
                { role: "user", content: `[我刚刚发了一条朋友圈，内容如下：]\n- 文字：“${originalPost.text || '(没有填写文字)'}”\n- 配图想法：${originalPost.image_prompts.length > 0 ? `“${originalPost.image_prompts.join('、 ')}”` : '(没有配图想法)'}` },
                { 
                    role: "system", 
                    // 【关键修改】我们移除了严格的字数限制，让 AI 自由发挥！
                    content: "请你只针对上面这条朋友圈的内容，用你的角色口吻，发表一句简短、口语化的评论。你的回复必须是纯文本，不要包含JSON。" 
                }
            ];

            const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
                body: JSON.stringify({
                    model: appState.apiConfig.model,
                    messages: messagesForAPI,
                    temperature: 0.9,
                    max_tokens: 50, // 限制最大长度以防万一，但不再严格要求
                })
            });

            if (!response.ok) throw new Error('API 请求失败');

            const data = await response.json();
            const commentText = data.choices[0]?.message?.content.trim().replace(/["“]/g, '');

            if (commentText) {
                let postToUpdate = appState.momentsData.posts.find(p => p.timestamp === originalPost.timestamp);
                if (postToUpdate) {
                    const newComment = { author: chat.name, content: commentText, timestamp: Date.now(), role: 'assistant' };
                    if (!postToUpdate.comments) postToUpdate.comments = [];
                    postToUpdate.comments.push(newComment);
                    await saveAndRenderMoments();
                }
            }
        } catch (error) {
            console.error(`为 ${chat.name} 生成评论时出错:`, error);
        }
    }
};

// ▼▼▼ 粘贴这个全新的 JS 程式码块 ▼▼▼

// 一个全局变量，用来记录当前正在更换哪个图示
let currentEditingIconId = null;

// ▼▼▼ 在<script>内找到此函数并用下面的版本替换 ▼▼▼
const renderIconSettingsGrid = () => {
    const container = document.getElementById('icon-grid-container');
    container.innerHTML = '';

    // --- 【核心修改】在这里新增一行 'icon-widget' ---
    const iconsMap = {
        'icon-widget': { label: '小组件', default: '🦋' },
        'icon-contacts': { label: '联系人', default: '💬' },
        'icon-me': { label: '我', default: '🩹' },
        'icon-settings': { label: '设置', default: '⚙️' },
        'icon-prompt': { label: '提示词', default: '💭' },
        'icon-dock-1': { label: 'Dock：图示一', default: '🤍' },
        'icon-dock-2': { label: 'Dock：图示二', default: '🩶' },
        'icon-dock-3': { label: 'Dock：图示三', default: '🖤' },
    };

    for (const iconId in iconsMap) {
        const item = document.createElement('div');
        item.className = 'action-grid-item';

        const iconDiv = document.createElement('div');
        iconDiv.className = 'icon'; 
        
        const customSrc = appState.tempCustomIcons[iconId]; 
        
        if (customSrc) {
            // ▼▼▼ 【核心修改】增加对小组件预览的特殊样式处理 ▼▼▼
            if (iconId === 'icon-widget') {
                 iconDiv.style.backgroundImage = `url(${customSrc})`;
                 iconDiv.style.backgroundSize = 'cover';
                 iconDiv.style.borderRadius = '22px'; // 让预览图标也带圆角
            } else {
                iconDiv.style.backgroundImage = `url(${customSrc})`;
                iconDiv.style.backgroundSize = 'cover';
            }
            iconDiv.innerHTML = '';
        } else {
            iconDiv.style.backgroundImage = 'none'; 
            iconDiv.innerHTML = iconsMap[iconId].default;
        }

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = iconsMap[iconId].label;

        item.onclick = () => {
            currentEditingIconId = iconId;
            document.getElementById('icon-upload-input').click();
        };

        item.appendChild(iconDiv);
        item.appendChild(labelDiv);
        container.appendChild(item);
    }
};

const handleIconUpload = (event) => {
    const file = event.target.files[0];
    if (!file || !currentEditingIconId) return;

    const reader = new FileReader();
    reader.onload = (e) => { // 不再需要 async
        const newImageSrc = e.target.result;
        
        // 核心修改：只更新 tempCustomIcons
        appState.tempCustomIcons[currentEditingIconId] = newImageSrc;
        
        // 只重新渲染设定页的网格，以显示预览
        renderIconSettingsGrid();
        
        currentEditingIconId = null;
    };
    reader.readAsDataURL(file);
    event.target.value = '';
};

const exportDataSimple = async () => {
    // 1. 定义需要备份的所有资料的 KEY
    const keysToExport = [
        KEYS.API, KEYS.CHATS, KEYS.CONTACTS, KEYS.PERSONA_AI, KEYS.PERSONA_MY,
        KEYS.HOME_WALLPAPER, KEYS.MOMENTS_DATA, KEYS.DECORATIVE_WIDGET_IMAGES,
        KEYS.STICKERS, KEYS.PROMPTS, KEYS.DARK_MODE, KEYS.PUBLIC_ACCOUNT_POSTS
    ];
    
    const backupData = {};
    console.log("正在从 Key-Value 储存中汇出资料...");

    // 2. 循环读取每一项资料
    for (const key of keysToExport) {
        // 使用您现有的 dbStorage.get 函数来读取资料
        const data = await dbStorage.get(key);
        if (data !== undefined) { // 只备份有资料的栏位
            backupData[key] = data;
        }
    }

    // 3. 将资料打包成 JSON 档案并提供下载
    const jsonString = JSON.stringify(backupData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
    a.href = url;
    a.download = `AIRP-Backup-${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    alert('资料已开始汇出！');
};

/**
 * 【简单版】汇入资料函数
 * 读取使用者选择的 JSON 档案，并将其写回 key-value 储存。
 */
const handleImportSimple = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // 使用 confirm 再次确认，防止误操作覆盖现有资料
            if (!confirm("确定要汇入备份档案吗？这将会覆盖所有现有资料！")) {
                return;
            }

            console.log("开始将资料写入 Key-Value 储存...");
            for (const key in backupData) {
                // 确保只写入我们定义过的 KEY，防止汇入恶意资料
                if (Object.values(KEYS).includes(key)) {
                    await dbStorage.set(key, backupData[key]);
                    console.log(`- 已汇入资料: ${key}`);
                }
            }
            
            alert('资料汇入成功！应用程式即将重新整理。');
            setTimeout(() => location.reload(), 1000);

        } catch (error) {
            alert(`汇入失败：档案格式错误或已损坏。\n\n${error.message}`);
        }
    };
    reader.readAsText(file);
    event.target.value = ''; // 清空选择，以便下次还能选择同个档案
};

// ▲▲▲ 新增函数到此结束 ▲▲▲

// ▼▼▼ 1. 新增：让 AI 创作朋友圈的函数 ▼▼▼
async function generateAiMomentPost(chatId) {
    const chat = appState.chats[chatId];
    if (!chat || chat.isGroup) return null; // 确保是单聊AI

    try {
        // 构建一个专门用于创作朋友圈的指令
        const systemPrompt = `你正在扮演角色：“${chat.personas.ai.name}”。你的详细设定是：“${chat.personas.ai.content}”。
下面是你与用户的近期聊天记录。
你的任务是：完全以你的角色身份和口吻，对最近的生活或聊天内容进行总结、抒发感想，并写成一条简短的朋友圈动态。
你的输出**必须**是一个JSON对象，且只包含以下两个键：
1. "text": 字符串，表示动态的文字内容 (必须在150字以内)。
2. "image_prompts": 一个包含1到3个字符串的数组，每个字符串都是对一张配图的简短中文描述。

例如:
{"text": "今天聊了很多，感觉心情都变好了。希望明天也是晴天。", "image_prompts": ["一只微笑的云朵", "阳光下的咖啡杯"]}`;

        const historyForAPI = processHistoryForAPI(chat.history);
        const response = await fetch(`${appState.apiConfig.url.replace(/\/$/, '')}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${appState.apiConfig.key}` },
            body: JSON.stringify({
                model: appState.apiConfig.model,
                messages: [{ role: 'system', content: systemPrompt }, ...historyForAPI],
                response_format: { "type": "json_object" }
            })
        });

        if (!response.ok) throw new Error("API 请求失败");
        const data = await response.json();
        const content = data.choices[0]?.message?.content.trim();
        return JSON.parse(content);

    } catch (error) {
        console.error(`为 ${chat.name} 生成朋友圈时出错:`, error);
        return null;
    }
}

// ▼▼▼ 2. 新增：AI 朋友圈的定时器系统 ▼▼▼
let aiMomentTimers = {}; // 用于管理所有AI的定时器

// 触发指定AI发布朋友圈的函数
async function triggerAiMomentPost(chatId) {
    console.log(`[朋友圈系统] 正在为 ${appState.chats[chatId].name} 触发一次自动发帖...`);
    const momentData = await generateAiMomentPost(chatId);

    if (momentData && momentData.text && momentData.image_prompts) {
        const newPost = {
            author: appState.chats[chatId].name,
            text: momentData.text,
            image_prompts: momentData.image_prompts,
            location: '',
            timestamp: Date.now(),
            likes: [],
            comments: []
        };
        
        // 将新帖子加入数据并保存
        appState.momentsData.posts.unshift(newPost);
        await saveAndRenderMoments(); // 使用您已有的保存和刷新函数
        
        // 弹出通知提醒您
        showNotification(chatId, `发布了一条新动态: ${momentData.text.substring(0, 20)}...`);
        console.log(`[朋友圈系统] ${appState.chats[chatId].name} 成功发布了新动态！`);
    } else {
        console.log(`[朋友圈系统] ${appState.chats[chatId].name} 本次思考没有灵感，未发布动态。`);
    }

    // 无论成功与否，都重置定时器，开始下一轮的等待
    resetAiMomentTimer(chatId);
}

// 为单个AI重置定时器
function resetAiMomentTimer(chatId) {
    if (aiMomentTimers[chatId]) {
        clearTimeout(aiMomentTimers[chatId]);
    }
    // 设置一个 1 到 3 小时之间的随机延迟
    const randomDelay = (Math.random() * 2 * 60 * 60 * 1000) + (1 * 60 * 60 * 1000); 
    
    aiMomentTimers[chatId] = setTimeout(() => {
        triggerAiMomentPost(chatId);
    }, randomDelay);
    
    console.log(`[朋友圈系统] ${appState.chats[chatId].name} 的下一次朋友圈将在 ${(randomDelay / 1000 / 60).toFixed(1)} 分钟后检查。`);
}

// 初始化所有AI的定时器
function initAiMomentTimers() {
    console.log("[朋友圈系统] 正在初始化所有AI的自主发帖定时器...");
    for (const chatId in appState.chats) {
        if (!appState.chats[chatId].isGroup) {
            resetAiMomentTimer(chatId);
        }
    }
}

const notifyAisOfNewMoment = async (post) => {
    // 1. 筛选出所有AI单人聊天
    const allSingleAiChatIds = Object.keys(appState.chats).filter(id => {
        const chat = appState.chats[id];
        return chat && chat.type !== 'group' && chat.personas && chat.personas.ai;
    });

    // 2. 创建一个标准格式的“朋友圈通知”对象
    const momentNotification = {
        role: 'system',
        hidden: true, // 关键：这条消息在聊天界面是看不见的
        content: {
            type: 'moment_notification', // 用一个特殊类型来识别它
            postTimestamp: post.timestamp, // 记下动态的时间戳，方便后续查找
            text: post.text,
            image_prompts: post.image_prompts
        },
        timestamp: Date.now()
    };

    // 3. 遍历所有AI聊天，把这张“小纸条”塞进它们的历史记录里
    for (const chatId of allSingleAiChatIds) {
        appState.chats[chatId].history.push(momentNotification);
    }

    // 4. 一次性将所有更新保存到数据库
    await dbStorage.set(KEYS.CHATS, appState.chats);
    
    console.log(`[朋友圈系统] 已将新动态通知推送给 ${allSingleAiChatIds.length} 位AI。`);
    
    // 5. 弹窗提示您接下来的操作
    alert('动态已发布！\n\n现在，您可以进入任意一个与AI的聊天界面，点击“接收”，AI就会对您的这条新动态进行评论。');
};

// ▼▼▼ 步骤1：新增一个专门负责更新聊天界面视觉效果的辅助函数 ▼▼▼
const updateChatScreenVisuals = (isOffline) => {
    const messagesDiv = document.getElementById('chat-messages');
    if (messagesDiv) {
        messagesDiv.classList.toggle('offline-mode', isOffline);
    }
   
    document.getElementById('phone-screen').classList.toggle('offline-active', isOffline);
};

    init();
});
</script>

</body>
</html>